<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>运维工程师</title>
      <link href="10007/06/07/si-wei-dao-tu/"/>
      <url>10007/06/07/si-wei-dao-tu/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/09/29/0evdtx.png" alt="0evdtx.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mycat</title>
      <link href="2020/09/28/sql/mycat/"/>
      <url>2020/09/28/sql/mycat/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-Replication"><a href="#MySQL-Replication" class="headerlink" title="MySQL-Replication"></a>MySQL-Replication</h2><h3 id="MySQL-Replication-1"><a href="#MySQL-Replication-1" class="headerlink" title="MySQL Replication"></a>MySQL Replication</h3><p>主从复制（也称 AB 复制）允许将来自一个MySQL数据库服务器（主服务器）的数据复制到一个或多个MySQL数据库服务器（从服务器）。</p><blockquote><p>复制是异步的 从站不需要永久连接以接收来自主站的更新。</p></blockquote><p>根据配置，您可以复制数据库中的所有数据库，所选数据库甚至选定的表。</p><p>MySQL中复制的优点包括：</p><ul><li>横向扩展解决方案 - 在多个从站之间分配负载以提高性能。在此环境中，所有写入和更新都必须在主服务器上进行。但是，读取可以在一个或多个从设备上进行。该模型可以提高写入性能（因为主设备专用于更新），同时显着提高了越来越多的从设备的读取速度。</li><li>数据安全性 - 因为数据被复制到从站，并且从站可以暂停复制过程，所以可以在从站上运行备份服务而不会破坏相应的主数据。</li><li>分析 - 可以在主服务器上创建实时数据，而信息分析可以在从服务器上进行，而不会影响主服务器的性能。</li><li>远程数据分发 - 您可以使用复制为远程站点创建数据的本地副本，而无需永久访问主服务器。</li></ul><h3 id="Replication的原理"><a href="#Replication的原理" class="headerlink" title="Replication的原理"></a>Replication的原理</h3><p><img src="https://i.loli.net/2019/08/13/b8YDSUo3ZM6wLtx.jpg" alt=""></p><p>前提是作为主服务器角色的数据库服务器必须开启二进制日志</p><pre><code>主服务器上面的任何修改都会通过自己的 I/O tread(I/O 线程)保存在二进制日志 Binary log 里面。从服务器上面也启动一个 I/O thread，通过配置好的用户名和密码, 连接到主服务器上面请求读取二进制日志，然后把读取到的二进制日志写到本地的一个Realy log（中继日志）里面。从服务器上面同时开启一个 SQL thread 定时检查 Realy log(这个文件也是二进制的)，如果发现有更新立即把更新的内容在本机的数据库上面执行一遍。每个从服务器都会收到主服务器二进制日志的全部内容的副本。从服务器设备负责决定应该执行二进制日志中的哪些语句。除非另行指定，否则主从二进制日志中的所有事件都在从站上执行。如果需要，您可以将从服务器配置为仅处理一些特定数据库或表的事件。重要: 您无法将主服务器配置为仅记录特定事件。每个从站(从服务器)都会记录二进制日志坐标：     文件名     文件中它已经从主站读取和处理的位置。由于每个从服务器都分别记录了自己当前处理二进制日志中的位置，因此可以断开从服务器的连接，重新连接然后恢复继续处理。</code></pre><h5 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h5><p>如果一主多从的话，这时主库既要负责写又要负责为几个从库提供二进制日志。此时可以稍做调整，将二进制日志只给某一从，这一从再开启二进制日志并将自己的二进制日志再发给其它从。或者是干脆这个从不记录只负责将二进制日志转发给其它从，这样架构起来性能可能要好得多，而且数据之间的延时应该也稍微要好一些。工作原理图如下：</p><p><img src="https://i.loli.net/2019/08/13/1e8xfpo5rMt3Blg.jpg" alt=""></p><p>练习题:</p><pre class=" language-reStructuredText"><code class="language-reStructuredText">使用三台机器搭建一主多从的mysql架构并能够实现数据同步, 部署形式不限<脚本、手动都可></code></pre><h4 id="关于二进制日志"><a href="#关于二进制日志" class="headerlink" title="关于二进制日志"></a>关于二进制日志</h4><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fmysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>将数字扩展名附加到二进制日志基本名称以生成二进制日志文件名。每次服务器创建新日志文件时，该数字都会增加，从而创建一系列有序的文件。每次启动或刷新日志时，服务器都会在系列中创建一个新文件。服务器还会在当前日志大小达到<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Freplication-options-binary-log.html%23sysvar_max_binlog_size" target="_blank" rel="noopener"><code>max_binlog_size</code></a>参数设置的大小后自动创建新的二进制日志文件 。二进制日志文件可能会比<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Freplication-options-binary-log.html%23sysvar_max_binlog_size" target="_blank" rel="noopener"><code>max_binlog_size</code></a>使用大型事务时更大， 因为事务是以一个部分写入文件，而不是在文件之间分割。</p><p>为了跟踪已使用的二进制日志文件， <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fmysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>还创建了一个二进制日志索引文件，其中包含所有使用的二进制日志文件的名称。默认情况下，它具有与二进制日志文件相同的基本名称，并带有扩展名<code>&#39;.index&#39;</code>。在<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fmysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>运行时，您不应手动编辑此文件。</p><p>术语<code>二进制日志文件</code>通常表示包含数据库事件的单个编号文件。</p><p>术语 <code>二进制日志</code>  表示含编号的二进制日志文件集加上索引文件。</p><p><code>SUPER</code> 权限的用户可以使用<code>SET sql_log_bin=0</code>语句禁用其当前环境下自己的语句的二进制日志记录</p><h3 id="配置Replication"><a href="#配置Replication" class="headerlink" title="配置Replication"></a>配置Replication</h3><h5 id="配置步骤："><a href="#配置步骤：" class="headerlink" title="配置步骤："></a>配置步骤：</h5><ol><li>在主服务器上，您必须启用二进制日志记录并配置唯一的服务器ID。需要重启服务器。</li></ol><p>编辑主服务器的配置文件 <code>my.cnf</code>，添加如下内容</p><pre><code>[mysqld]log-bin=/var/log/mysql/mysql-binserver-id=1</code></pre><p>创建日志目录并赋予权限</p><pre><code>[root@mysql ~]#  mkdir /var/log/mysql[root@mysql ~]# chown mysql.mysql /var/log/mysql</code></pre><p>重启服务</p><pre><code>[root@mysql ~]# systemctl restart mysqld</code></pre><p><strong>注意：：</strong></p><pre><code>如果省略server-id（或将其显式设置为默认值0），则主服务器拒绝来自从服务器的任何连接。为了在使用带事务的InnoDB进行复制设置时尽可能提高持久性和一致性，您应该在master my.cnf文件中使用以下配置项：innodb_flush_log_at_trx_commit = 1sync_binlog = 1确保未在复制主服务器上启用skip-networking选项。如果已禁用网络，则从站无法与主站通信，并且复制失败。</code></pre><p>2.应该创建一个专门用于复制数据的用户</p><p>每个从服务器需要使用MySQL 主服务器上的用户名和密码连接到主站。</p><p>例如，计划使用用户 <code>repl</code> 可以从任何主机上连接到 <code>master</code> 上进行复制操作, 并且用户 <code>repl</code> 仅可以使用复制的权限。</p><p>在 <code>主服务器</code> 上执行如下操作</p><pre><code>mysql&gt; CREATE USER &#39;repl&#39;@&#39;%&#39; mysql&gt; GRANT REPLICATION SLAVE ON *.*  TO  &#39;repl&#39;@&#39;%&#39;  identified by  &#39;123&#39;;mysql&gt; </code></pre><p>3.在<code>从服务器</code>上使用刚才的用户进行测试连接</p><pre><code>[root@mysql ~]# mysql -urepl -p&#39;123&#39; -hmysql-master1</code></pre><p>下面的操作根据如下情况继续</p><h5 id="主服务器中有数据"><a href="#主服务器中有数据" class="headerlink" title="主服务器中有数据"></a>主服务器中有数据</h5><ul><li>如果在启动复制之前有现有数据需要与从属设备同步，请保持客户端正常运行，以便锁定保持不变。这可以防止进行任何进一步的更改，以便复制到从站的数据与主站同步。</li></ul><ol><li>在主服务器中导出先有的数据</li></ol><p>如果主数据库包含现有数据，则必须将此数据复制到每个从站。有多种方法可以实现:</p><ul><li>使用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fmysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a>工具创建要复制的所有数据库的转储。这是推荐的方法，尤其是在使用时 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>。</li></ul><pre><code>[root@mysql ~]# mysqldump  -u用户名  -p密码  --all-databases  --master-data=1 &gt; dbdump.db这里的用户是主服务器的用户</code></pre><p>如果不使用 <code>--master-data</code> 参数，则需要手动锁定单独会话中的所有表。</p><ol start="2"><li>从主服务器中使用 <code>scp</code> 或 <code>rsync</code> 等工具，把备份出来的数据传输到从服务器中。</li></ol><p>在主服务中执行如下命令</p><pre><code>[root@mysql ~]# scp  dbdump.db root@mysql-slave1:/root/这里的 mysql-slave1 需要能被主服务器解析出 IP 地址，或者说可以在主服务器中 ping 通。</code></pre><ol start="3"><li>配置从服务器，并重启<br>在<code>从服务器</code> 上编辑其配置文件 <code>my.cnf</code> 并添加如下内容</li></ol><pre><code>// my.cnf 文件[mysqld]server-id=2</code></pre><ol start="4"><li>导入数据到从服务器，并配置连接到主服务器的相关信息</li></ol><p>登录到从服务器上，执行如下操作</p><pre><code>/*导入数据*/mysql&gt; source   /root/fulldb.dump</code></pre><p>在从服务器配置连接到主服务器的相关信息</p><pre><code>mysql&gt; CHANGE MASTER TOMASTER_HOST=&#39;mysql-master1&#39;,  -- 主服务器的主机名(也可以是 IP) MASTER_USER=&#39;repl&#39;,           -- 连接到主服务器的用户MASTER_PASSWORD=&#39;123&#39;;        -- 到主服务器的密码</code></pre><ol start="5"><li><p>启动从服务器的复制线程</p><pre><code>mysql&gt; start slave;Query OK, 0 rows affected (0.09 sec)</code></pre></li></ol><p>检查是否成功</p><p>在从服务上执行如下操作，加长从服务器端 IO线程和 SQL 线程是否是 <code>OK</code></p><pre><code>mysql&gt; show slave status\G</code></pre><p>输出结果中应该看到 I/O 线程和 SQL 线程都是 <code>YES</code>, 就表示成功。</p><p>执行此过程后，在主服务上操作的修改数据的操作都会在从服务器中执行一遍，这样就保证了数据的一致性。</p><h5 id="主服务器中无数据"><a href="#主服务器中无数据" class="headerlink" title="主服务器中无数据"></a>主服务器中无数据</h5><p><strong>主服务器中设置</strong></p><ol><li><code>my.cnf</code>配置文件</li></ol><pre><code>[mysqld]log-bin=/var/log/mysql/mysql-binserver-id=1</code></pre><p>创建日志目录并赋予权限</p><pre><code>[root@mysql ~]#  mkdir /var/log/mysql[root@mysql ~]#  chown mysql.mysql /var/log/mysql</code></pre><p>重启服务</p><p><strong>从服务器设置</strong></p><ol><li><code>my.cnf</code>配置文件</li></ol><pre><code>[mysqld]server-id=3</code></pre><p>重启服务</p><ol start="2"><li>查看主服务器的二进制日志的名称</li></ol><p>通过使用命令行客户端连接到主服务器来启动主服务器上的会话，并通过执行以下 <code>FLUSH TABLES WITH READ LOCK</code>  语句来刷新所有表和阻止写语句：</p><pre><code>mysql&gt; FLUSH TABLES WITH READ LOCK;mysql&gt; show master status \G****************** 1. row ****************             File: mysql-bin.000001         Position: 0     Binlog_Do_DB: Binlog_Ignore_DB:Executed_Gtid_Set:1 row in set (0.00 sec)</code></pre><ol start="3"><li>在从服务器的 mysql 中执行如下语句</li></ol><pre><code>mysql&gt; CHANGE MASTER TOMASTER_HOST=&#39;mysql-master1&#39;,MASTER_USER=&#39;repl&#39;,MASTER_PASSWORD=&#39;123&#39;,MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;,MASTER_LOG_POS=0;mysql&gt; start slave;</code></pre><p><strong>查看</strong></p><p>在master上执行show binlog events命令，可以看到第一个binlog文件的内容。</p><pre><code>mysql&gt; show binlog events\G*************************** 1. row ***************************   Log_name: mysql-bin.000001        Pos: 4 Event_type: Format_desc  Server_id: 1End_log_pos: 107       Info: Server ver: 5.5.28-0ubuntu0.12.10.2-log, Binlog ver: 4*************************** 2. row ***************************   Log_name: mysql-bin.000001        Pos: 107 Event_type: Query  Server_id: 1End_log_pos: 181       Info: create user rep*************************** 3. row ***************************   Log_name: mysql-bin.000001        Pos: 181 Event_type: Query  Server_id: 1End_log_pos: 316       Info: grant replication slave on *.* to rep identified by &#39;123456&#39;3 rows in set (0.00 sec)Log_name 是二进制日志文件的名称，一个事件不能横跨两个文件Pos 这是该事件在文件中的开始位置Event_type 事件的类型，事件类型是给slave传递信息的基本方法，每个新的binlog都以Format_desc类型开始，以Rotate类型结束Server_id 创建该事件的服务器idEnd_log_pos 该事件的结束位置，也是下一个事件的开始位置，因此事件范围为Pos~End_log_pos  -  1Info 事件信息的可读文本，不同的事件有不同的信息</code></pre><h4 id="在从站上暂停复制"><a href="#在从站上暂停复制" class="headerlink" title="在从站上暂停复制"></a>在从站上暂停复制</h4><p>您可以使用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fstop-slave.html" target="_blank" rel="noopener"><code>STOP SLAVE</code></a>和 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fstart-slave.html" target="_blank" rel="noopener"><code>START SLAVE</code></a>语句停止并启动从站上的复制 。</p><p>要停止从主服务器处理二进制日志，请使用 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fstop-slave.html" target="_blank" rel="noopener"><code>STOP SLAVE</code></a>：</p><pre><code>mysql&gt; STOP SLAVE;</code></pre><p>当复制停止时，从I / O线程停止从主二进制日志读取事件并将它们写入中继日志，并且SQL线程停止从中继日志读取事件并执行它们。您可以通过指定线程类型单独暂停I / O或SQL线程：</p><pre><code>mysql&gt; STOP SLAVE IO_THREAD;mysql&gt; STOP SLAVE SQL_THREAD;</code></pre><p>要再次开始执行，请使用以下<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fstart-slave.html" target="_blank" rel="noopener"><code>START SLAVE</code></a>语句：</p><pre><code>mysql&gt; START SLAVE;</code></pre><p>要启动特定线程，请指定线程类型：</p><pre><code>mysql&gt; START SLAVE IO_THREAD;mysql&gt; START SLAVE SQL_THREAD;</code></pre><pre><code>复制原理实现细节（了解）MySQL复制功能使用三个线程实现，一个在主服务器上，两个在从服务器上：Binlog转储线程 主设备创建一个线程，以便在从设备连接时将二进制日志内容发送到从设备。可以SHOW PROCESSLIST在主服务器的输出中将此线程标识为Binlog Dump线程。二进制日志转储线程获取主机二进制日志上的锁，用于读取要发送到从机的每个事件。一旦读取了事件，即使在事件发送到从站之前，锁也会被释放。从属 I/O线程 在从属服务器上发出 START SLAVE 语句时，从属服务器会创建一个 I/O 线程，该线程连接到主服务器并要求主服务器发送其在二进制日志中的更新记录。从属 I/O线程读取主Binlog Dump线程发送的更新 （请参阅上一项）并将它们复制到包含从属中继日志的本地文件。此线程的状态显示为 Slave_IO_running输出 SHOW SLAVE STATUS或 Slave_running输出中的状态SHOW STATUS。从属SQL线程 从属设备创建一个SQL线程来读取由从属 I/O 线程写入的中继日志，并执行其中包含的事件。当从属服务器从放的事件，追干上主服务器的事件后，从属服务器的 I/O 线程将会处于休眠状态，直到主服务器的事件有更新时，被主服务器发送的信号唤醒。在前面的描述中，每个主/从连接有三个线程。具有多个从站的主站为每个当前连接的从站创建一个二进制日志转储线程，每个从站都有自己的I / O和SQL线程。从站使用两个线程将读取更新与主站分开并将它们执行到独立任务中。因此，如果语句执行缓慢，则不会减慢读取语句的任务。例如，如果从服务器尚未运行一段时间，则当从服务器启动时，其I / O线程可以快速从主服务器获取所有二进制日志内容，即使SQL线程远远落后。如果从服务器在SQL线程执行了所有获取的语句之前停止，则I / O线程至少已获取所有内容，以便语句的安全副本本地存储在从属的中继日志中，准备在下次执行时执行奴隶开始。</code></pre><h3 id="配置Replication-gtid方式"><a href="#配置Replication-gtid方式" class="headerlink" title="配置Replication(gtid方式)"></a>配置Replication(gtid方式)</h3><p>基于事务的Replication，就是利用GTID来实现的复制</p><p>GTID（全局事务标示符）最初由google实现，在MySQL 5.6中引入.GTID在事务提交时生成，由UUID和事务ID组成.uuid会在第一次启动MySQL时生成，保存在数据目录下的auto .cnf文件里，事务ID则从1开始自增使用GTID的好处主要有两点：</p><ol><li>不再需要指定传统复制中的master_log_files和master_log_pos，使主从复制更简单可靠</li><li>可以实现基于库的多线程复制，减小主从复制的延迟</li></ol><p><strong>实验环境要求： 5.7.6 以上版本</strong></p><h5 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h5><pre><code>[mysqld]log-bin=/var/log/mysql/mysql-binserver-id=1gtid_mode=ONenforce_gtid_consistency=1   # 强制执行GTID一致性。</code></pre><p>重启服务</p><p>其他和之前的一样</p><ul><li>创建专属用户并授权</li><li>假如有数据导出数据</li></ul><pre><code>mysql&gt; CREATE USER &#39;repl&#39;@&#39;%&#39; IDENTIFIED BY &#39;123&#39;;mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#39;repl&#39;@&#39;%&#39;;mysql&gt; </code></pre><h5 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h5><p>测试用户有效性</p><pre><code>mysql -urepl -p&#39;123&#39; -hmysql-master1</code></pre><pre><code>[mysqld]server-id=2gtid_mode=ONenforce_gtid_consistency=1# 可选项, 把连接到 master 的信息存到数据库中的表中master-info-repository=TABLErelay-log-info-repository=TABLE</code></pre><p>重启服务</p><p>假如有数据，先导入数据</p><pre><code>mysql&gt; source dump.db</code></pre><p>Mysql 终端执行连接信息</p><pre><code>mysql&gt; CHANGE MASTER TOMASTER_HOST=&#39;172.16.153.10&#39;,MASTER_USER=&#39;repl&#39;,MASTER_PASSWORD=&#39;123&#39;,MASTER_AUTO_POSITION=1;&gt; start slave;</code></pre><h3 id="Replication故障排除"><a href="#Replication故障排除" class="headerlink" title="Replication故障排除"></a>Replication故障排除</h3><h4 id="开启-GTID-后的导出导入数据的注意点"><a href="#开启-GTID-后的导出导入数据的注意点" class="headerlink" title="开启 GTID 后的导出导入数据的注意点"></a>开启 GTID 后的导出导入数据的注意点</h4><blockquote><p>Warning: A partial dump from a server that has GTIDs will by default include the GTIDs of all transactions, even those that changed suppressed parts of the database. If you don’t want to restore GTIDs, pass –set-gtid-purged=OFF. To make a complete dump, pass –all-databases –triggers –routines –events</p></blockquote><p>意思是： 当前数据库实例中开启了 GTID 功能, 在开启有 GTID 功能的数据库实例中, 导出其中任何一个库, 如果没有显示地指定–set-gtid-purged参数, 都会提示这一行信息. 意思是默认情况下, 导出的库中含有 GTID 信息, 如果不想导出包含有 GTID 信息的数据库, 需要显示地添加–set-gtid-purged=OFF参数.</p><pre><code>mysqldump -uroot  -p  --set-gtid-purged=OFF   --all-databases &gt; alldb.db</code></pre><p>导入数据是就可以相往常一样导入了。</p><h4 id="UUID一致，导致主从复制I-O线程不是yes"><a href="#UUID一致，导致主从复制I-O线程不是yes" class="headerlink" title="UUID一致，导致主从复制I/O线程不是yes"></a>UUID一致，导致主从复制I/O线程不是yes</h4><blockquote><p>Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work</p></blockquote><p>致命错误：由于master和slave具有相同的mysql服务器uuid，从I/O线程将停止；这些uuid必须不同才能使复制工作。</p><p>问题提示主从使用了相同的server UUID，一个个的检查：</p><p>检查主从server_id</p><p>主库：</p><p>mysql&gt;  show variables like ‘server_id’;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| server_id     | 1     |<br>+—————+——-+<br>1 row in set (0.01 sec)</p><p>从库：</p><p>mysql&gt;  show variables like ‘server_id’;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| server_id     | 2     |<br>+—————+——-+<br>1 row in set (0.01 sec)</p><p>server_id不一样，排除。</p><p>检查主从状态：</p><p>主库：</p><p>mysql&gt; show master status;<br>+——————+———-+————–+——————+——————-+<br>| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+——————+———-+————–+——————+——————-+<br>| mysql-bin.000001 |      154 |              |                  |                   |<br>+——————+———-+————–+——————+——————-+<br>1 row in set (0.00 sec)<br>从库：</p><p>mysql&gt; show master status;<br>+——————+———-+————–+——————+——————-+<br>| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+——————+———-+————–+——————+——————-+<br>| mysql-bin.000001 |      306 |              |                  |                   |<br>+——————+———-+————–+——————+——————-+<br>1 row in set (0.00 sec)</p><p>File一样，排除。</p><p>最后检查发现他们的auto.cnf中的server-uuid是一样的。。。</p><p>[root@localhost ~]# vim /var/lib/mysql/auto.cnf</p><p>[auto]</p><p>server-uuid=4f37a731-9b79-11e8-8013-000c29f0700f</p><p>修改uuid并重启服务</p><h3 id="数据库中间MyCAT读写分离实现-重要！！！"><a href="#数据库中间MyCAT读写分离实现-重要！！！" class="headerlink" title="数据库中间MyCAT读写分离实现 (重要！！！)"></a>数据库中间MyCAT读写分离实现 (重要！！！)</h3><p>Mycat 是一个开源的分布式数据库系统，但是由于真正的数据库需要存储引擎，而 Mycat 并没有存 储引擎，所以并不是完全意义的分布式数据库系统。 那么 Mycat 是什么？Mycat 是数据库中间件，就是介于数据库与应用之间，进行数据处理与交互的中间服 务。</p><p><img src="https://i.loli.net/2019/08/12/ZXJxhqTER2UFak5.jpg" alt=""></p><p>MyCAT 是使用 JAVA 语言进行编写开发，使用前需要先安装 JAVA 运行环境(JRE),由于 MyCAT 中使用了 JDK7 中的一些特性，所以要求必须在 JDK7 以上的版本上运行。</p><h4 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h4><p>1下载JDK</p><pre><code>[root@mycat ~]# wget --no-cookies \--no-check-certificate \--header \&quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; \http://download.oracle.com/otn-pub/java/jdk/8u181-\b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-\x64.tar.gz// --no-check-certificate 表示不校验SSL证书，因为中间的两个302会访问https，会涉及到证书的问题，不校验能快一点，影响不大.</code></pre><p>2.解压文件</p><pre><code>[root@mycat ~]# tar -xf jdk-8u181-linux-x64.tar.gz   -C  /usr/local/[root@mycat ~]# ln -s /usr/local/jdk1.8.0_181/ /usr/local/java</code></pre><p>3.配置环境变量</p><pre><code>[root@mycat ~]# vim /etc/profile.d/java.shexport JAVA_HOME=/usr/local/javaexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar使环境变量生效[root@mycat ~]# source /etc/profile.d/java.sh</code></pre><h4 id="部署Mycat"><a href="#部署Mycat" class="headerlink" title="部署Mycat"></a>部署Mycat</h4><p><img src="https://i.loli.net/2019/08/12/zlZOf4dv95xPkS1.jpg" alt=""></p><pre><code>下载[root@mycat ~]# wget http://dl.mycat.io/1.6.5/Mycat-server-1.6.5-release-20180122220033-linux.tar.gz解压[root@mycat ~]# tar xf Mycat-server-1.6.5-release-20180122220033-linux.tar.gz -C /usr/local/</code></pre><h5 id="配置Mycat"><a href="#配置Mycat" class="headerlink" title="配置Mycat"></a>配置Mycat</h5><p>认识配置文件</p><p>MyCAT 目前主要通过配置文件的方式来定义逻辑库和相关配置:</p><p>/usr/local/mycat/conf/server.xml             定义用户以及系统相关变量，如端口等。其中用户信息是前端应用程序连接 mycat 的用户信息。</p><p>/usr/local/mycat/conf/schema.xml       定义逻辑库，表、分片节点等内容。</p><h5 id="配置-server-xml"><a href="#配置-server-xml" class="headerlink" title="配置 server.xml"></a>配置 server.xml</h5><p>以下为代码片段</p><p>下面的用户和密码是应用程序连接到 MyCat 使用的，可以自定义配置</p><p>而其中的schemas 配置项所对应的值是逻辑数据库的名字，也可以自定义，但是这个名字需要和后面 schema.xml 文件中配置的一致。</p><pre><code>vim server.xml&lt;!--下面的用户和密码是应用程序连接到 MyCat 使用的.schemas 配置项所对应的值是逻辑数据库的名字,这个名字需要和后面 schema.xml 文件中配置的一致。--&gt;       &lt;user name=&quot;mycatdb&quot; defaultAccount=&quot;true&quot;&gt;                &lt;property name=&quot;password&quot;&gt;1&lt;/property&gt;                &lt;property name=&quot;schemas&quot;&gt;mycat_db&lt;/property&gt;                &lt;!-- 表级 DML 权限设置 --&gt;                &lt;!--                            &lt;privileges check=&quot;false&quot;&gt;                        &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt;                                &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt;                                &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt;                        &lt;/schema&gt;                &lt;/privileges&gt;                            --&gt;        &lt;/user&gt;&lt;!--下面是另一个用户，并且设置的访问 TESTED 逻辑数据库的权限是 只读        &lt;user name=&quot;mycatuser&quot;&gt;                &lt;property name=&quot;password&quot;&gt;123&lt;/property&gt;                &lt;property name=&quot;schemas&quot;&gt;mycat_db&lt;/property&gt;                &lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt;        &lt;/user&gt;--&gt;&lt;/mycat:server&gt;</code></pre><p>== 上面的配置中，假如配置了用户访问的逻辑库，那么必须在 <code>schema.xml</code> 文件中也配置这个逻辑库，否则报错，启动 mycat 失败 ==</p><h5 id="配置schema-xml"><a href="#配置schema-xml" class="headerlink" title="配置schema.xml"></a>配置schema.xml</h5><p>以下是配置文件中的每个部分的配置块儿</p><p><strong>逻辑库和分表设置</strong></p><pre><code>&lt;schema name=&quot;mycat_db&quot;           // 逻辑库名称,与server.xml的一致        checkSQLschema=&quot;false&quot;    // 不检查        sqlMaxLimit=&quot;100&quot;         // 最大连接数        dataNode=&quot;tiger1&quot;&gt;        //  数据节点名称&lt;!--这里定义的是分表的信息--&gt;        &lt;/schema&gt;</code></pre><p><strong>数据节点</strong></p><pre><code>&lt;dataNode name=&quot;tiger1&quot;             // 此数据节点的名称          dataHost=&quot;localhost1&quot;     // 主机组          database=&quot;mycat_test&quot; /&gt;  // 真实的数据库名称</code></pre><p><strong>主机组</strong></p><pre><code>&lt;dataHost name=&quot;localhost1&quot;                       // 主机组          maxCon=&quot;1000&quot; minCon=&quot;10&quot;               // 连接          balance=&quot;0&quot;                             // 负载均衡          writeType=&quot;0&quot;                           // 写模式配置          dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;        // 数据库配置          switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;&lt;!--这里可以配置关于这个主机组的成员信息，和针对这些主机的健康检查语句--&gt;&lt;/dataHost&gt;</code></pre><pre><code>balance 属性负载均衡类型,目前的取值有 3 种:1. balance=&quot;0&quot;, 不开启读写分离机制,所有读操作都发送到当前可用的 writeHost 上。2. balance=&quot;1&quot;, 全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡,简单的说,当双主双从模式(M1-&gt;S1,M2-&gt;S2,并且 M1 与 M2     互为主备),正常情况下,M2,S1,S2 都参与 select 语句的负载均衡。4. balance=&quot;2&quot;, 所有读操作都随机的在 writeHost、readhost 上分发。5. balance=&quot;3&quot;, 所有读请求随机的分发到 wiriterHost 对应的 readhost 执行,writerHost 不负担读压力,注意 balance=3 只在 1.4 及其以后版本有,1.3 没有。writeType 属性负载均衡类型,目前的取值有 3 种:1. writeType=&quot;0&quot;, 所有写操作发送到配置的第一个 writeHost,第一个挂了切到还生存的第二个writeHost,重新启动后已切换后的为准.2. writeType=&quot;1&quot;,所有写操作都随机的发送到配置的 writeHost,1.5 以后废弃不推荐。</code></pre><p><strong>健康检查</strong></p><pre><code>&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;</code></pre><p><strong>读写配置</strong></p><pre><code>&lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.19.176:3306&quot; user=&quot;root&quot; password=&quot;1&quot;&gt;                        &lt;!-- can have multi read hosts --&gt;       &lt;readHost host=&quot;hostS2&quot; url=&quot;192.168.19.177:3306&quot; user=&quot;root&quot; password=&quot;1&quot; /&gt;&lt;/writeHost&gt;</code></pre><p>以下是组合为完整的配置文件，适用于一主一从的架构</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt;  &lt;schema name=&quot;mycat_db&quot;         checkSQLschema=&quot;false&quot;         sqlMaxLimit=&quot;100&quot;         dataNode=&quot;tiger1&quot;&gt;    &lt;!--这里定义的是分库分表的信息--&gt;        &lt;/schema&gt;  &lt;dataNode name=&quot;tiger1&quot;           dataHost=&quot;localhost1&quot; database=&quot;mycat_test&quot; /&gt;  &lt;dataHost name=&quot;localhost1&quot;             maxCon=&quot;1000&quot; minCon=&quot;10&quot;             balance=&quot;0&quot;            writeType=&quot;0&quot;             dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;             switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;   &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;       &lt;!-- can have multi write hosts --&gt;   &lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.19.176:3306&quot;               user=&quot;root&quot;  password=&quot;1&quot;&gt;      &lt;!-- can have multi read hosts --&gt;      &lt;readHost host=&quot;hostS2&quot; url=&quot;192.168.19.177:3306&quot;                 user=&quot;root&quot; password=&quot;1&quot; /&gt;     &lt;/writeHost&gt;   &lt;/dataHost&gt;&lt;/mycat:schema&gt;</code></pre><h4 id="启动-mycat"><a href="#启动-mycat" class="headerlink" title="启动 mycat"></a>启动 mycat</h4><pre><code>[root@mycat ~]# /usr/local/mycat/bin/mycat  start支持一下参数start | restart |stop | status</code></pre><h4 id="在真实的-master-数据库上给用户授权"><a href="#在真实的-master-数据库上给用户授权" class="headerlink" title="在真实的 master 数据库上给用户授权"></a>在真实的 master 数据库上给用户授权</h4><pre><code>mysql&gt; grant all on mycat_test.* to root@&#39;%&#39; identified by &#39;1&#39;;mysql&gt; flush privileges;</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在 mycat 的机器上测试用户权限有效性</p><p>测试是否能正常登录上 主服务器</p><pre><code>mysql -uroot -p&#39;123&#39; -h192.168.19.176</code></pre><p>继续测试是否能登录上从服务器</p><pre><code>mysql -uroot -p&#39;123&#39; -h192.168.19.177</code></pre><p>通过客户端进行测试是否能登录到 mycat 上</p><p>192.168.19.178 是 mycat 的主机地址</p><p>注意端口号是 <code>8066</code></p><pre><code>[root@mysqlclient ~]# mysql -umycatdb -p1 -h192.168.19.178 -P8066MySQL [(none)]&gt; show databases;+----------+| DATABASE |+----------+| mycat_db |+----------+1 row in set (0.00 sec)</code></pre><p>继续测试读写分离策略</p><p>使用  <code>mysql</code> 客户端工具使用  <code>mycat</code> 的账户和密码登录 <code>mycat</code> ,<br> 之后执行 <code>select</code> 语句。</p><p>之后查询 <code>mycat</code> 主机上 <code>mycat</code> 安装目录下的 <code>logs/mycat.log</code> 日志。</p><p>在日志重搜索查询的语句或者查询 从库的 ip 地址，应该能搜索到</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Mycat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 NFS 服务</title>
      <link href="2020/09/24/linux/bu-shu-nfs-fu-wu/"/>
      <url>2020/09/24/linux/bu-shu-nfs-fu-wu/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>目的：部署 NFS 服务进行跨主机文件共享</p><p>Network File System<br>      通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。</p><h3 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h3><pre class=" language-shell"><code class="language-shell">1.系统版本：CentOS7.42.NFS版本：nfs-utils （使用当前最新版本）3.初始化系统环境4.关闭防火墙[root@localhost ~]#  systemctl stop iptables firewalld[root@localhost ~]#  systemctl disable iptables firewalld5.关闭SELinux[root@localhost ~]#  sed -ri '/SELINUX=/cSELINUX=disabled' /etc/selinux/config[root@localhost ~]#  setenforce 0           # 临时关闭SELinux</code></pre><h3 id="2、部署NFS"><a href="#2、部署NFS" class="headerlink" title="2、部署NFS"></a>2、部署NFS</h3><pre class=" language-shell"><code class="language-shell">    1、sudo yum -y install nfs-utils     2、配置    sudo vi /etc/sysconfig/nfs    加入     LOCKD_TCPPORT=30001 #TCP锁使用端口    LOCKD_UDPPORT=30002 #UDP锁使用端口    MOUNTD_PORT=30003 #挂载使用端口    STATD_PORT=30004 #状态使用端口</code></pre><h3 id="3、启动-重启服务"><a href="#3、启动-重启服务" class="headerlink" title="3、启动/重启服务"></a>3、启动/重启服务</h3><pre class=" language-shell"><code class="language-shell">1、sudo systemctl restart rpcbind.service 2、sudo systemctl restart nfs-server.service开机启动：1、sudo  systemctl enable rpcbind.service2、 sudo systemctl enable nfs-server.service</code></pre><h3 id="4、编辑共享目录"><a href="#4、编辑共享目录" class="headerlink" title="4、编辑共享目录"></a>4、编辑共享目录</h3><pre class=" language-shell"><code class="language-shell">编辑/etc/exports  sudo vi /etc/exports 写入如下内容   /home/cyy/goapi    10.0.0.0/24(rw,async,insecure,no_root_squash)</code></pre><h6 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h6><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">ro</td><td align="center">只读</td></tr><tr><td align="center">rw</td><td align="center">读写</td></tr><tr><td align="center">root_squash</td><td align="center">当NFS客户端以root管理员访问时，映射为NFS服务器的匿名用户</td></tr><tr><td align="center">no_root_squash</td><td align="center">当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员</td></tr><tr><td align="center">all_squash</td><td align="center">无论NFS客户端使用什么账户访问，均映射为NFS服务器的匿名用户</td></tr><tr><td align="center">sync</td><td align="center">同时将数据写入到内存与硬盘中，保证不丢失数据</td></tr><tr><td align="center">async</td><td align="center">优先将数据保存到内存，然后再写入硬盘;这样效率更高，但可能会丢失数据</td></tr><tr><td align="center">secure（默认）</td><td align="center">限制客户端只能从小于1024的tcp/ip端口连接服务器</td></tr><tr><td align="center">insecure</td><td align="center">允许客户端从大于1024的tcp/ip端口连接服务器</td></tr><tr><td align="center">anonuid</td><td align="center">匿名用户的UID值，通常是nobody或nfsnobody，可以在此处自行设定</td></tr><tr><td align="center">anongid</td><td align="center">匿名用户的GID值</td></tr><tr><td align="center">no_subtree_check</td><td align="center">如果NFS输出的是一个子目录，则无需检查其父目录的权限（可以提高效率）</td></tr></tbody></table><h3 id="5、查看挂载"><a href="#5、查看挂载" class="headerlink" title="5、查看挂载"></a>5、查看挂载</h3><pre class=" language-shell"><code class="language-shell">showmount -e localhost发现没有重启nfs服务  (sudo systemctl restart nfs-server.service)接下来  创建刚才的文件夹 </code></pre><h5 id="来到另外一台服务器上"><a href="#来到另外一台服务器上" class="headerlink" title="来到另外一台服务器上"></a>来到另外一台服务器上</h5><pre class=" language-shell"><code class="language-shell">sudo yum -y install nfs-utils 不需要启动nfs服务直接执行如下：showmount -e 10.0.0.145尝试进行挂载  mount -t nfs 10.0.0.145:/home/cyy/goapi   /home/cyy/goapi卸载只需 umount /home/cyy/goapi</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab-ci 入门</title>
      <link href="2020/09/20/devops/gitlab-ci-ru-men/"/>
      <url>2020/09/20/devops/gitlab-ci-ru-men/</url>
      
        <content type="html"><![CDATA[<h5 id="gitlab-ci入门"><a href="#gitlab-ci入门" class="headerlink" title="gitlab-ci入门"></a>gitlab-ci入门</h5><h6 id="示范："><a href="#示范：" class="headerlink" title="示范："></a>示范：</h6><pre class=" language-dockerfile"><code class="language-dockerfile">docker run -d --name gitlab-runner   \  -v /data/cyy/gitlab-runner:/etc/gitlab-runner \  -v /var/run/docker.sock:/var/run/docker.sock \ -v /usr/bin/docker:/usr/bin/docker \ -v /usr/lib64/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7  \  gitlab/gitlab-runner在宿主机上执行 ：chmod 666 /var/run/docker.sock</code></pre><pre class=" language-yml"><code class="language-yml"># cat  .gitlab-ci.ymlstages:  - test  - buildjob1:  stage: test  script:    - echo "it is test"job2:  stage: build  script:    - echo "it is build"</code></pre><h6 id="各种参数说明"><a href="#各种参数说明" class="headerlink" title="各种参数说明"></a>各种参数说明</h6><pre class=" language-shell"><code class="language-shell">script             由Runner执行的Shell脚本。image              使用docker镜像，  image：nameservice            使用docker  services镜像, services：namebefore_script      执行作业前运行的脚本after_script       作业完成后运行的脚本stages             定义管道中的步骤，依次运行stage              定义管道中步骤的作业段only    　　        指定作业限制only:refs，only:kubernetes，only:variables，和only:changestags               指定执行作业的runnerallow_failure      允许job失败when               什么时候开始工作，  on_success       只有当前一个阶段的所有工作都成功时（或者因为它们被标记而被认为是成功的allow_failure）才执行工作 。这是默认值。  on_failure       仅当前一阶段的至少一个作业失败时才执行作业。  always           无论先前阶段的工作状态如何，都可以执行工作。  manual           手动执行作业  delayed          延迟作业。后面跟start_in,start_in 30minutes(延迟30分钟)，不加单位，默认为秒。最长可延迟1小时。environment     作业部署到的环境名称   #暂未搞清 cache    　　key："$CI_JOB_STAGE-$CI_COMMIT_REF_SLUG" #为每分支，每步骤启用缓存artifacts         job成功时附加到作业的文件或目录dependencies      此job依赖其他jobz,主要作用于作业优先级converage         给定作业代码覆盖率设置　　　　　　 retry             在发生故障时，可以自动重试作业的次数。parallel　　      应该并行运行多少个作业实例trigger          定义下游管道触发器include          允许此作业包含外部YAMLextends          此作业将继承的配置项pages            上传作业结果用于gitlab pagesvariables        作业级别定义作业变量</code></pre><h6 id="案例-1-自动构建-go-程序"><a href="#案例-1-自动构建-go-程序" class="headerlink" title="案例 1  自动构建 go 程序"></a>案例 1  自动构建 go 程序</h6><pre class=" language-yam"><code class="language-yam">stages:  - testjob1:  stage: test  script:    - docker build -t mygo:v1  .  tags:    - go</code></pre><pre class=" language-dockerfile"><code class="language-dockerfile">FROM golang:1.14.4-alpine3.12RUN mkdir /src /appADD . ../srcENV GOPROXY="https://goproxy.io"RUN cd /src && ls && go build -o ../app/mygo main.go && cd /app && chmod +x mygo && cd /RUN rm src -frWORKDIR /appENTRYPOINT  ["/app/mygo"]</code></pre><h6 id="压缩镜像"><a href="#压缩镜像" class="headerlink" title="压缩镜像"></a>压缩镜像</h6><pre class=" language-dockerfile"><code class="language-dockerfile">FROM golang:1.14.4-alpine3.12RUN mkdir /src /appADD . ../srcENV GOPROXY="https://goproxy.io"RUN cd /src && ls && go build -o ../app/mygo main.go && cd /app && chmod +x mygo && cd /FROM alpine:3.12RUN mkdir /appCOPY --from=0 /app/mygo /appENTRYPOINT ["/app/mygo"]</code></pre><h6 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h6><pre class=" language-dockerfile"><code class="language-dockerfile">FROM golang:1.14.4-alpine3.12ADD . /srcWORKDIR /srccmd ["go","test"]</code></pre><pre class=" language-yml"><code class="language-yml">stages:  - test  - buildGoTest:  stage: test  script:    - docker build -f DockerfileTest -t test-mygo:v1 .    - docker run --rm test-mygo:v1  after_script:    - docker rmi test-mygo:v1  tags:    - goGoBuild:  stage: build  script:    - docker build -t mygo:v1  .  after_script:    - docker rmi $(docker images -af "dangling=true" -q)  tags:    - goGoDeploy:   #使用私有镜像仓库    stage: deploy    script:      - docker tag  mygo:v1  10.0.0.169:5000/mygo:v1      - docker push 10.0.0.169:5000/mygo:v1    after_script:        - docker rmi 10.0.0.169:5000/mygo:v1        - docker rmi mygo:v1    tags:      - go</code></pre><pre class=" language-shell"><code class="language-shell">查看数据curl http://10.0.0.169:5000/v2/_catalog   (查看列表)curl http://10.0.0.169:5000/v2/mygo/manifests/v1   (查看redis镜像详情)curl http://10.0.0.169:5000/v2/mygo/tags/list</code></pre><h6 id="自动更新服务"><a href="#自动更新服务" class="headerlink" title="自动更新服务"></a>自动更新服务</h6><pre class=" language-shell"><code class="language-shell">docker run -d --name gitlab-runner   \  -v /data/cyy/gitlab-runner:/etc/gitlab-runner \  -v /var/run/docker.sock:/var/run/docker.sock \ -v /usr/bin/docker:/usr/bin/docker \ -v /usr/lib64/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7  \-v /usr/local/bin/kubectl:/usr/local/bin/kubectl \-v /home/cyy/kubectl/config:/kubeconfig \-e KUBECONFIG=/kubeconfig \  gitlab/gitlab-runner</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">stages</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> build  <span class="token punctuation">-</span> deploy  <span class="token punctuation">-</span> pub<span class="token key atrule">GoBuild</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> build  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> docker build <span class="token punctuation">-</span>t mygo<span class="token punctuation">:</span>v1  .  <span class="token key atrule">after_script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> docker rmi $(docker images <span class="token punctuation">-</span>af "dangling=true" <span class="token punctuation">-</span>q)  <span class="token key atrule">tags</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> go<span class="token key atrule">GoDeploy</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> deploy  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> docker tag  mygo<span class="token punctuation">:</span>v1  10.0.0.169<span class="token punctuation">:</span>5000/mygo<span class="token punctuation">:</span>v1    <span class="token punctuation">-</span> docker push 10.0.0.169<span class="token punctuation">:</span>5000/mygo<span class="token punctuation">:</span>v1  <span class="token key atrule">after_script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> docker rmi 10.0.0.169<span class="token punctuation">:</span>5000/mygo<span class="token punctuation">:</span>v1    <span class="token punctuation">-</span> docker rmi mygo<span class="token punctuation">:</span>v1  <span class="token key atrule">tags</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> go<span class="token key atrule">GoPub</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> pub  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> kubectl get pod <span class="token punctuation">-</span>n myweb<span class="token punctuation">|</span> grep mygo <span class="token punctuation">|</span> awk '<span class="token punctuation">{</span>print $1<span class="token punctuation">}</span>'  <span class="token punctuation">|</span> xargs kubectl delete pod <span class="token punctuation">-</span>n myweb  <span class="token key atrule">tags</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> go</code></pre>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes组件—介绍002</title>
      <link href="2020/09/15/rong-qi/kubernetes-zu-jian-jie-shao-002/"/>
      <url>2020/09/15/rong-qi/kubernetes-zu-jian-jie-shao-002/</url>
      
        <content type="html"><![CDATA[<h5 id="本文档描述了-Kubernetes-的组件。"><a href="#本文档描述了-Kubernetes-的组件。" class="headerlink" title="本文档描述了 Kubernetes 的组件。"></a>本文档描述了 Kubernetes 的组件。</h5><h5 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h5><p>Namespace是对一组资源和对象的抽象集合， 用来将系统内部的对象划分为不同的项目组或用户组  </p><p>常用来隔离不同的用户，比如Kubernetes自带的服务一般运行在kube-system namespace中。</p><h5 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h5><p>ingress 相当于一个7层负载均衡器，理解为进行反代并定义规则的一个api对象<br>ingress Controller 通过监听 Ingress  api 转化为各自的配置(常用的有nginx -ingress,  trafik-ingress )</p><h5 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h5><h6 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a><strong>NodePort</strong></h6><p>​    在所有节点（虚拟机）上开放一个特定端口，任何发送到该端口的流量都被转发到对应服务</p><p>端口范围30000-32767</p><h6 id="hostPort"><a href="#hostPort" class="headerlink" title="hostPort"></a><strong>hostPort</strong></h6><p>直接将容器的端口与所调度的节点上的端口进行映射</p><h6 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h6><p>  创建集群内的服务， 应用只要在集群内都可以访问,外部（如公网）无法访问它。</p><p>k8s-coredns：</p><p>在同一个命名空间内：<br>    可以通过  service_name 直接解析</p><p>  不同命名空间内容：<br> service_name. namespace_name</p><h5 id="PVC-和-PV"><a href="#PVC-和-PV" class="headerlink" title="PVC 和 PV"></a>PVC 和 PV</h5><p>Persistent Volume Claim(PVC)和Persistent Volume（PV）</p><p>  PV： 定义Volume的类型、挂载目录、远程存储服务器等<br>  PVC：定义 Pod想要使用的持久化属性，比如存储大小、读写权限等..</p><p>StorageClass： PV的模板，自动为PVC创建PV</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 游标</title>
      <link href="2020/07/16/sql/mysql-you-biao/"/>
      <url>2020/07/16/sql/mysql-you-biao/</url>
      
        <content type="html"><![CDATA[<h5 id="mysql游标的用法及作用"><a href="#mysql游标的用法及作用" class="headerlink" title="[mysql游标的用法及作用]"></a>[mysql游标的用法及作用]</h5><p>例子：</p><p>当前有三张表A、B、C其中A和B是一对多关系，B和C是一对多关系，现在需要将B中A表的主键存到C中；<br>常规思路就是将B中查询出来然后通过一个update语句来更新C表就可以了，但是B表中有2000多条数据，<br>难道要执行2000多次？显然是不现实的；最终找到写一个存储过程然后通过循环来更新C表，<br>然而存储过程中的写法用的就是游标的形式。</p><h5 id="【简介】"><a href="#【简介】" class="headerlink" title="【简介】"></a>【简介】</h5><p>​    游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制。</p><p>​    游标充当指针的作用。</p><p>​    尽管游标能遍历结果中的所有行，但他一次只指向一行。</p><p>​    游标的作用就是用于对查询数据库所返回的记录进行遍历，以便进行相应的操作。</p><h5 id="【用法】"><a href="#【用法】" class="headerlink" title="【用法】"></a>【用法】</h5><p>​    一、声明一个游标: declare 游标名称 CURSOR for table;(这里的table可以是你查询出来的任意集合)<br>​    二、打开定义的游标:open 游标名称;<br>​    三、获得下一行数据:FETCH  游标名称 into testrangeid,versionid;<br>​    四、需要执行的语句(增删改查):这里视具体情况而定<br>​    五、释放游标:CLOSE 游标名称;<br>  注:mysql存储过程每一句后面必须用;结尾，使用的临时字段需要在定义游标之前进行声明。</p><h5 id="【实例】"><a href="#【实例】" class="headerlink" title="【实例】"></a>【实例】</h5><pre class=" language-sql"><code class="language-sql"><span class="token operator">-</span>  <span class="token keyword">BEGIN</span>  <span class="token comment" spellcheck="true">--定义变量  </span><span class="token keyword">declare</span> testrangeid <span class="token keyword">BIGINT</span><span class="token punctuation">;</span>  <span class="token keyword">declare</span> versionid <span class="token keyword">BIGINT</span><span class="token punctuation">;</span>   <span class="token keyword">declare</span> done <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--创建游标，并存储数据  </span><span class="token keyword">declare</span> cur_test <span class="token keyword">CURSOR</span> <span class="token keyword">for</span>      <span class="token keyword">select</span> id <span class="token keyword">as</span> testrangeid<span class="token punctuation">,</span>version_id <span class="token keyword">as</span> versionid <span class="token keyword">from</span> tp_testrange<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--游标中的内容执行完后将done设置为1  </span> <span class="token keyword">DECLARE</span> <span class="token keyword">CONTINUE</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> <span class="token operator">NOT</span> FOUND <span class="token keyword">SET</span> done<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--打开游标  </span><span class="token keyword">open</span> cur_test<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--执行循环  </span>  posLoop:LOOP  <span class="token comment" spellcheck="true">--判断是否结束循环  </span>        <span class="token keyword">IF</span> done<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">THEN</span>          LEAVE posLoop<span class="token punctuation">;</span>      <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--取游标中的值  </span>    <span class="token keyword">FETCH</span>  cur_test <span class="token keyword">into</span> testrangeid<span class="token punctuation">,</span>versionid<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--执行更新操作  </span>    <span class="token keyword">update</span> tp_data_execute <span class="token keyword">set</span> version_id<span class="token operator">=</span>versionid <span class="token keyword">where</span> testrange_id <span class="token operator">=</span> testrangeid<span class="token punctuation">;</span>    <span class="token keyword">END</span> LOOP posLoop<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--释放游标  </span><span class="token keyword">CLOSE</span> cur_test<span class="token punctuation">;</span>  <span class="token keyword">END</span>  <span class="token operator">-</span>  </code></pre><p> 例子2：</p><p>我们现在要用存储过程做一个功能，统计iphone的总库存是多少，并把总数输出到控制台。</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--在windows系统中写存储过程时，如果需要使用declare声明变量，需要添加这个关键字，否则会报错。  </span><span class="token keyword">delimiter</span> <span class="token comment" spellcheck="true">//  </span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> StatisticStore<span class="token punctuation">;</span>  <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> StatisticStore<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">BEGIN</span>      <span class="token comment" spellcheck="true">--创建接收游标数据的变量  </span>    <span class="token keyword">declare</span> <span class="token number">c</span> <span class="token keyword">int</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> n <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--创建总数变量  </span>    <span class="token keyword">declare</span> total <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--创建结束标志变量  </span>    <span class="token keyword">declare</span> done <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--创建游标  </span>    <span class="token keyword">declare</span> cur <span class="token keyword">cursor</span> <span class="token keyword">for</span> <span class="token keyword">select</span> name<span class="token punctuation">,</span>count <span class="token keyword">from</span> store <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'iphone'</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--指定游标循环结束时的返回值  </span>    <span class="token keyword">declare</span> <span class="token keyword">continue</span> <span class="token keyword">HANDLER</span> <span class="token keyword">for</span> <span class="token operator">not</span> found <span class="token keyword">set</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--设置初始值  </span>    <span class="token keyword">set</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--打开游标  </span>    <span class="token keyword">open</span> cur<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--开始循环游标里的数据  </span>    read_loop:loop      <span class="token comment" spellcheck="true">--根据游标当前指向的一条数据  </span>    <span class="token keyword">fetch</span> cur <span class="token keyword">into</span> n<span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--判断游标的循环是否结束  </span>    <span class="token keyword">if</span> done <span class="token keyword">then</span>          leave read_loop<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">--跳出游标循环  </span>    <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--获取一条数据时，将count值进行累加操作，这里可以做任意你想做的操作，  </span>    <span class="token keyword">set</span> total <span class="token operator">=</span> total <span class="token operator">+</span> <span class="token number">c</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--结束游标循环  </span>    <span class="token keyword">end</span> loop<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--关闭游标  </span>    <span class="token keyword">close</span> cur<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">--输出结果  </span>    <span class="token keyword">select</span> total<span class="token punctuation">;</span>  <span class="token keyword">END</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--调用存储过程  </span><span class="token keyword">call</span> StatisticStore<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p> fetch是获取游标当前指向的数据行，并将指针指向下一行，当游标已经指向最后一行时继续执行会造成游标溢出。<br>使用loop循环游标时，他本身是不会监控是否到最后一条数据了，像下面代码这种写法，就会造成死循环；</p><pre class=" language-sql"><code class="language-sql">read_loop:loop  <span class="token keyword">fetch</span> cur <span class="token keyword">into</span> n<span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">;</span>  <span class="token keyword">set</span> total <span class="token operator">=</span> total<span class="token operator">+</span><span class="token number">c</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> loop<span class="token punctuation">;</span>  </code></pre><p>在MySql中，造成游标溢出时会引发mysql预定义的NOT FOUND错误，所以在上面使用下面的代码指定了当引发not found错误时定义一个continue 的事件，指定这个事件发生时修改done变量的值。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">declare</span> <span class="token keyword">continue</span> <span class="token keyword">HANDLER</span> <span class="token keyword">for</span> <span class="token operator">not</span> found <span class="token keyword">set</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  </code></pre><p>所以在循环时加上了下面这句代码：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--判断游标的循环是否结束  </span><span class="token keyword">if</span> done <span class="token keyword">then</span>      leave read_loop<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">--跳出游标循环  </span><span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span>  </code></pre><p>如果done的值是true，就结束循环。继续执行下面的代码</p><p>使用方式</p><p>游标有三种使用方式：<br>第一种就是上面的实现，使用loop循环；<br>第二种方式如下，使用while循环：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> StatisticStore1<span class="token punctuation">;</span>  <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> StatisticStore1<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">BEGIN</span>      <span class="token keyword">declare</span> <span class="token number">c</span> <span class="token keyword">int</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> n <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> total <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> done <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> cur <span class="token keyword">cursor</span> <span class="token keyword">for</span> <span class="token keyword">select</span> name<span class="token punctuation">,</span>count <span class="token keyword">from</span> store <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'iphone'</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> <span class="token keyword">continue</span> <span class="token keyword">HANDLER</span> <span class="token keyword">for</span> <span class="token operator">not</span> found <span class="token keyword">set</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">set</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">open</span> cur<span class="token punctuation">;</span>      <span class="token keyword">fetch</span> cur <span class="token keyword">into</span> n<span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">not</span> done<span class="token punctuation">)</span> <span class="token keyword">do</span>          <span class="token keyword">set</span> total <span class="token operator">=</span> total <span class="token operator">+</span> <span class="token number">c</span><span class="token punctuation">;</span>          <span class="token keyword">fetch</span> cur <span class="token keyword">into</span> n<span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span>      <span class="token keyword">close</span> cur<span class="token punctuation">;</span>      <span class="token keyword">select</span> total<span class="token punctuation">;</span>  <span class="token keyword">END</span><span class="token punctuation">;</span>  <span class="token keyword">call</span> StatisticStore1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p>第三种方式是使用repeat执行：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> StatisticStore2<span class="token punctuation">;</span>  <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> StatisticStore2<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">BEGIN</span>      <span class="token keyword">declare</span> <span class="token number">c</span> <span class="token keyword">int</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> n <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> total <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> done <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> cur <span class="token keyword">cursor</span> <span class="token keyword">for</span> <span class="token keyword">select</span> name<span class="token punctuation">,</span>count <span class="token keyword">from</span> store <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'iphone'</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> <span class="token keyword">continue</span> <span class="token keyword">HANDLER</span> <span class="token keyword">for</span> <span class="token operator">not</span> found <span class="token keyword">set</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">set</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">open</span> cur<span class="token punctuation">;</span>      repeat      <span class="token keyword">fetch</span> cur <span class="token keyword">into</span> n<span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token operator">not</span> done <span class="token keyword">then</span>          <span class="token keyword">set</span> total <span class="token operator">=</span> total <span class="token operator">+</span> <span class="token number">c</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span>      until done <span class="token keyword">end</span> repeat<span class="token punctuation">;</span>      <span class="token keyword">close</span> cur<span class="token punctuation">;</span>      <span class="token keyword">select</span> total<span class="token punctuation">;</span>  <span class="token keyword">END</span><span class="token punctuation">;</span>  <span class="token keyword">call</span> StatisticStore2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="游标嵌套"><a href="#游标嵌套" class="headerlink" title="游标嵌套"></a>游标嵌套</h5><p>在mysql中，每个begin end 块都是一个独立的scope区域，由于MySql中同一个error的事件只能定义一次，如果多定义的话在编译时会提示Duplicate handler declared in the same block。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> StatisticStore3<span class="token punctuation">;</span>  <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> StatisticStore3<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">BEGIN</span>      <span class="token keyword">declare</span> _n <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> done <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">declare</span> cur <span class="token keyword">cursor</span> <span class="token keyword">for</span> <span class="token keyword">select</span> name <span class="token keyword">from</span> store <span class="token keyword">group</span> <span class="token keyword">by</span> name<span class="token punctuation">;</span>      <span class="token keyword">declare</span> <span class="token keyword">continue</span> <span class="token keyword">HANDLER</span> <span class="token keyword">for</span> <span class="token operator">not</span> found <span class="token keyword">set</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">open</span> cur<span class="token punctuation">;</span>      read_loop:loop      <span class="token keyword">fetch</span> cur <span class="token keyword">into</span> _n<span class="token punctuation">;</span>      <span class="token keyword">if</span> done <span class="token keyword">then</span>          leave read_loop<span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span>      <span class="token keyword">begin</span>          <span class="token keyword">declare</span> <span class="token number">c</span> <span class="token keyword">int</span><span class="token punctuation">;</span>          <span class="token keyword">declare</span> n <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">declare</span> total <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">declare</span> done <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>          <span class="token keyword">declare</span> cur <span class="token keyword">cursor</span> <span class="token keyword">for</span> <span class="token keyword">select</span> name<span class="token punctuation">,</span>count <span class="token keyword">from</span> store <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'iphone'</span><span class="token punctuation">;</span>          <span class="token keyword">declare</span> <span class="token keyword">continue</span> <span class="token keyword">HANDLER</span> <span class="token keyword">for</span> <span class="token operator">not</span> found <span class="token keyword">set</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token keyword">set</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">open</span> cur<span class="token punctuation">;</span>          iphone_loop:loop          <span class="token keyword">fetch</span> cur <span class="token keyword">into</span> n<span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> done <span class="token keyword">then</span>              leave iphone_loop<span class="token punctuation">;</span>          <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span>          <span class="token keyword">set</span> total <span class="token operator">=</span> total <span class="token operator">+</span> <span class="token number">c</span><span class="token punctuation">;</span>          <span class="token keyword">end</span> loop<span class="token punctuation">;</span>          <span class="token keyword">close</span> cur<span class="token punctuation">;</span>          <span class="token keyword">select</span> _n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>total<span class="token punctuation">;</span>      <span class="token keyword">end</span><span class="token punctuation">;</span>      <span class="token keyword">begin</span>              <span class="token keyword">declare</span> <span class="token number">c</span> <span class="token keyword">int</span><span class="token punctuation">;</span>              <span class="token keyword">declare</span> n <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">declare</span> total <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token keyword">declare</span> done <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>              <span class="token keyword">declare</span> cur <span class="token keyword">cursor</span> <span class="token keyword">for</span> <span class="token keyword">select</span> name<span class="token punctuation">,</span>count <span class="token keyword">from</span> store <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'android'</span><span class="token punctuation">;</span>              <span class="token keyword">declare</span> <span class="token keyword">continue</span> <span class="token keyword">HANDLER</span> <span class="token keyword">for</span> <span class="token operator">not</span> found <span class="token keyword">set</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>              <span class="token keyword">set</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token keyword">open</span> cur<span class="token punctuation">;</span>              android_loop:loop              <span class="token keyword">fetch</span> cur <span class="token keyword">into</span> n<span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> done <span class="token keyword">then</span>                  leave android_loop<span class="token punctuation">;</span>              <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span>              <span class="token keyword">set</span> total <span class="token operator">=</span> total <span class="token operator">+</span> <span class="token number">c</span><span class="token punctuation">;</span>              <span class="token keyword">end</span> loop<span class="token punctuation">;</span>              <span class="token keyword">close</span> cur<span class="token punctuation">;</span>          <span class="token keyword">select</span> _n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>total<span class="token punctuation">;</span>      <span class="token keyword">end</span><span class="token punctuation">;</span>      <span class="token keyword">begin</span>      <span class="token keyword">end</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> loop<span class="token punctuation">;</span>      <span class="token keyword">close</span> cur<span class="token punctuation">;</span>  <span class="token keyword">END</span><span class="token punctuation">;</span>  <span class="token keyword">call</span> StatisticStore3<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p>上面就是实现一个嵌套循环，当然这个例子比较牵强。凑合看看就行。</p><h5 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h5><p>Mysql 支持动态SQL的功能</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token variable">@sqlStr</span><span class="token operator">=</span><span class="token string">'select * from table where condition1 = ?'</span><span class="token punctuation">;</span>  prepare s1 <span class="token keyword">for</span> <span class="token variable">@sqlStr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--如果有多个参数用逗号分隔  </span><span class="token keyword">execute</span> s1 <span class="token keyword">using</span> <span class="token variable">@condition1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--手工释放，或者是 connection 关闭时， server 自动回收  </span><span class="token keyword">deallocate</span> prepare s1<span class="token punctuation">;</span>  </code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus学习笔记_01</title>
      <link href="2020/06/18/jian-kong/prometheus-xue-xi-bi-ji-1/"/>
      <url>2020/06/18/jian-kong/prometheus-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h3 id="Prometheus-监控"><a href="#Prometheus-监控" class="headerlink" title="Prometheus 监控"></a>Prometheus 监控</h3><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>本文介绍Prometheus 监控及在k8s集群中使用node-exporter、prometheus、grafana对集群进行监控。实现原理类似ELK、EFK组合。node-exporter组件负责收集节点上的metrics监控数据，并将数据推送给prometheus, prometheus负责存储这些数据，grafana将这些数据通过网页以图形的形式展现给用户。</p><p>在开始之前有必要了解下Prometheus是什么?<br>        Prometheus （中文名：普罗米修斯）是由 SoundCloud 开发的开源监控报警系统和时间序列数据库(TSDB).自2012年起,许多公司及组织已经采用 Prometheus,并且该项目有着非常活跃的开发者和用户社区.现在已经成为一个独立的开源项目。Prometheus 在2016加入 CNCF ( Cloud Native Computing Foundation 云原生计算基金会 ), 作为在 kubernetes 之后的第二个由基金会主持的项目。 Prometheus 的实现参考了Google内部的监控实现，与源自Google的Kubernetes结合起来非常合适。另外相比influxdb的方案，性能更加突出，而且还内置了报警功能。它针对大规模的集群环境设计了拉取式的数据采集方式，只需要在应用里面实现一个metrics接口，然后把这个接口告诉Prometheus就可以完成数据采集了，下图为prometheus的架构图。</p><p><img src="https://s1.ax1x.com/2020/06/18/NZwhWt.png" alt="NZwhWt.png"></p><p>​        promethues是一套开源的系统监控报警框架。Prometheus 所有采集的监控数据均以指标（metric）的形式保存在内置的<a href="https://www.wikiwand.com/zh/時間序列" target="_blank" rel="noopener">时间序列</a>数据库当中（TSDB）：属于同一指标名称，同一标签集合的、有时间戳标记的数据流。除了存储的时间序列，Prometheus 还可以根据查询请求产生临时的、衍生的时间序列作为返回结果。包含了以下组件</p><ul><li>prometheus server: 主要负责数据采集和存储，提供promQL查询语言支持。prometheus是一个时序数据库，将采集到的监控数据按照时间序列的方式存储到本地磁盘。</li><li>Push Gateway: 支持临时性job主动推送指标的中间网关。</li><li>PromDash： 使用rails开发的dashboard，用于可视化指标数据。</li><li>Exporters: 负责监控机器运行状态，提供被监控组件信息的 HTTP 接口被叫做 exporter。<ul><li>直接采集： exporter内置了prometheus支持，直接向prometheus暴露数据端点。</li><li>间接采集：原不支持prometheus。通过prometheus提供的clien library编写的目标监控采集程序。</li></ul></li><li>Altermanager: 从 Prometheus server 端接收到 alerts 后，会进行去除重复数据，分组，并路由到对收的接受方式，发出报警。常见的接收方式有：电子邮件，企业微信，钉钉 ,  webhook </li><li>WebUI: Prometheus内置一个简单的Web控制台，可以查询指标，查看配置信息或者Service Discovery等，实际工作中，查看指标或者创建仪表盘通常使用Grafana，Prometheus作为Grafana的数据源；9090提供图形化界面功能。</li></ul><p>promethues 的各个组件基本都是用 golang 编写,对编译和部署十分友好.并且没有特殊依赖.基本都是独立工作。</p><h3 id="二、基本工作原理"><a href="#二、基本工作原理" class="headerlink" title="二、基本工作原理"></a><strong>二、基本工作原理</strong></h3><ul><li>Prometheus server 定期从配置好的 jobs 或者 exporters 中拉 metrics，或者接收来自 Pushgateway 发过来的 metrics，或者从其他的 Prometheus server 中拉 metrics。</li><li>Prometheus server 在本地存储收集到的 metrics，并运行已定义好的 alert.rules，记录新的时间序列或者向 Alertmanager 推送警报。</li><li>Alertmanager 根据配置文件，对接收到的警报进行处理，发出告警。</li><li>在图形界面中，可视化采集数据。</li></ul><h3 id="三、Prometheus-的优势和不足"><a href="#三、Prometheus-的优势和不足" class="headerlink" title="三、Prometheus 的优势和不足"></a>三、Prometheus 的优势和不足</h3><h4 id="1、prometheus-的优势"><a href="#1、prometheus-的优势" class="headerlink" title="1、prometheus 的优势"></a>1、prometheus 的优势</h4><ol><li>强大的多维度数据模型：<br>时间序列数据通过 metric 名和键值对来区分。<br>所有的 metrics 都可以设置任意的多维标签。<br>数据模型更随意，不需要刻意设置为以点分隔的字符串。<br>可以对数据模型进行聚合，切割和切片操作。<br>支持双精度浮点类型，标签可以设为全 unicode。</li><li>灵活而强大的查询语句（PromQL）：<br>在同一个查询语句，可以对多个 metrics 进行乘法、加法、连接、取分数位等操作。</li><li>易于管理：<br>Prometheus server 是一个单独的二进制文件，可直接在本地工作，不依赖于分布式存储。</li><li>高效：<br>平均每个采样点仅占 3.5 bytes，且一个 Prometheus server 可以处理数百万的 metrics。<br>使用 pull 模式采集时间序列数据，这样不仅有利于本机测试而且可以避免有问题的服务器推送坏的 metrics。</li><li>可以采用 push gateway 的方式把时间序列数据推送至 Prometheus server 端。</li><li>可以通过服务发现或者静态配置去获取监控的 targets。</li><li>有多种可视化图形界面。</li><li>易于伸缩。</li></ol><h4 id="2、prometheus-的不足-有待于改进"><a href="#2、prometheus-的不足-有待于改进" class="headerlink" title="2、prometheus 的不足 有待于改进"></a>2、prometheus 的不足 有待于改进</h4><ol><li>不支持集群化 (这个是当前最迫切的需求)</li><li>被监控集群过大后 本身性能有一定瓶颈(如果有集群 就可以解决这个问题)</li><li>偶尔发生数据丢失(这个问题 在2.0之前 会偶尔发生几次， 2.0之后貌似已经彻底解决 )</li><li>中文支持不好 中文资料也很少(这个问题 也是老生常谈了 往往新的 很牛的国外工具都不太支持中文)</li></ol><p>注：<br>    由于数据采集可能会有丢失，所以 Prometheus 不适用对采集数据要 100% 准确的情形。但如果用于记录时间序列数据，Prometheus 具有很大的查询优势，此外，Prometheus 适用于微服务的体系架构。</p><h3 id="四、prometheus-的基本概念"><a href="#四、prometheus-的基本概念" class="headerlink" title="四、prometheus 的基本概念"></a><strong>四、prometheus 的基本概念</strong></h3><h4 id="1、数据模型"><a href="#1、数据模型" class="headerlink" title="1、数据模型"></a><strong>1、数据模型</strong></h4><p>  prometheus中存储的数据为时间序列，是由Metric的名字和一系列的标签（键值对）唯一标识的，不同的标签代表不同的时间序列。</p><p> 样本：实际时间序列，每个序列包括一个float64的值和一个毫秒级的时间戳。（指标+时间戳+样本值）</p><p> metric名字： 具有语义，表示功能：例如：http_requeststotal, 表示 http 请求的总数。其中，metric 名字由 ASCII 字符，数字，下划线，以及冒号组成，且必须满足正则表达式[a-zA-Z:][a-zA-Z0-9_:]*。</p><p> 标签：使一个时间序列有不同未读的识别。例如 http_requeststotal{method=”Get”} 表示所有 http 请求中的 Get 请求。当 method=”post” 时，则为新的一个 metric。标签中的键由 ASCII 字符，数字，以及下划线组成，且必须满足正则表达式[a-zA-Z:][a-zA-Z0-9_:]*。</p><p> 格式：<metric name>{<label name>=<label value>, …}，例如：http_requests_total{method=”POST”,endpoint=”/api/tracks”}。</p><h4 id="2、Metric类型"><a href="#2、Metric类型" class="headerlink" title="2、Metric类型"></a><strong>2、Metric类型</strong></h4><p>Prometheus 客户端库主要提供四种主要的 metric 类型：</p><h5 id="1、Counter（累加性metirc）"><a href="#1、Counter（累加性metirc）" class="headerlink" title="1、Counter（累加性metirc）"></a>1、Counter（累加性metirc）</h5><p>一种累加的 metric，典型的应用如：<br>    请求的个数<br>    结束的任务数<br>    出现的错误数<br>    。。。</p><p>例如：<br>    查询 promhttp_metric_handler_requests_total{code=”200”,instance=”localhost:9090”,job=”prometheus”}<br>    返回 8，10 秒后再次查询，则返回 14。</p><h5 id="2、Gauge（可增减性metric）"><a href="#2、Gauge（可增减性metric）" class="headerlink" title="2、Gauge（可增减性metric）"></a>2、Gauge（可增减性metric）</h5><p>一种常规的 metric，典型的应用如：<br>    温度<br>    运行的 go routines 的个数<br>可以任意加减。</p><p>例如：<br>    go_goroutines{instance=”localhost:9090”,job=”prometheus”}<br>    返回值 147，10 秒后返回 124。</p><p>注：<br>    routines: go的日常工作？</p><h5 id="3、Histogram（树状图）"><a href="#3、Histogram（树状图）" class="headerlink" title="3、Histogram（树状图）"></a>3、Histogram（树状图）</h5><p>注：<br> histogram    英[ˈhɪstəɡræm] 美[ˈhɪstəɡræm]   直方图；矩形图</p><p> 可以理解为柱状图，典型的应用如：<br>     请求持续时间<br>     响应大小<br> 可以对观察结果采样，分组及统计。</p><p> 例如：<br>     查询 go_gc_duration_seconds_sum{instance=”localhost:9090”,job=”prometheus”}时<br>      返回结果如下：Histogram metric 返回结果图</p><p><img src="https://s1.ax1x.com/2020/06/18/NZwjWq.png" alt="NZwjWq.png"></p><h5 id="4、Summary（汇总）"><a href="#4、Summary（汇总）" class="headerlink" title="4、Summary（汇总）"></a>4、Summary（汇总）</h5><p>类似于 Histogram，典型的应用如：<br>    请求持续时间<br>    响应大小<br>提供观测值的 count 和 sum 功能。<br>提供百分位的功能，即可以按百分比划分跟踪结果。</p><p>instance 和 jobs<br>instance:<br>    一个单独 scrape(抓取) 的目标， 一般对应于一个进程。</p><p>jobs:<br>    一组同种类型的 instances（主要用于保证可扩展性和可靠性），例如：<br>注：<br>    scrape    英[skreɪp] 美[skreɪp] 刮掉; 削去; 擦坏; 擦伤; 刮坏; 蹭破; (使) 发出刺耳的刮擦声</p><p>当 scrape 目标时，Prometheus 会自动给这个 scrape 的时间序列附加一些标签以便更好的分别<br>例如： instance，job。</p><p>下面以实际的 metric 为例，对上述概念进行说明：<br>Metrics 示例</p><p><img src="https://s1.ax1x.com/2020/06/18/NZwzlV.png" alt="NZwzlV.png"></p><p>如图所示，这三个 metric 的名字都一样，他们仅凭 handler 不同而被标识为不同的 metrics。<br>这类 metrics 只会向上累加，是属于 Counter 类型的 metric，且 metrics 中都含有 instance 和 job 这两个标签。</p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue之入门篇_001</title>
      <link href="2020/05/31/devops/vue-ru-men-zhi-001/"/>
      <url>2020/05/31/devops/vue-ru-men-zhi-001/</url>
      
        <content type="html"><![CDATA[<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">https://cli.vuejs.org/zh/</a></p><p><strong>以文档为主</strong></p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p><a href="https://cli.vuejs.org/zh/guide/installation.html" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/installation.html</a></p><h6 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h6><blockquote><p>1、打开终端执行 npm install -g @vue/cli</p><p>接下来可以用vue -V 看版本，或where vue 看下装到哪了</p></blockquote><h6 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h6><p><a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><p>在你的当前文件夹下执行</p><pre><code>vue create myvue </code></pre><p>1、具体看文档操作（使用默认选项）</p><p>2、创建好后，会出现一个myvue文件夹，然后用webstorm打开它</p><h5 id="运行和配置"><a href="#运行和配置" class="headerlink" title="运行和配置"></a>运行和配置</h5><blockquote><ol><li><p>首先运行<br>在当前项目目录下执行 npm run serve</p></li><li><p>默认会启动webpack –devserver(仅仅开发使用),默认端口是 8080</p></li></ol></blockquote><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>进入<br><a href="https://cli.vuejs.org/zh/config/#vue-config-js" target="_blank" rel="noopener">https://cli.vuejs.org/zh/config/#vue-config-js</a></p><h6 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h6><p>vue.config.js  （注意和package.json同级、同级、同级）</p><p>写入如下内容</p><pre class=" language-vue"><code class="language-vue">module.exports = { devServer: {    port: 3000  }}</code></pre><p>或者看<br><a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7</a></p><pre class=" language-vue"><code class="language-vue"> new Vue({        data:{name:"lisi"}    }).$mount('#app');</code></pre><h6 id="使用template"><a href="#使用template" class="headerlink" title="使用template"></a>使用template</h6><pre class=" language-vue"><code class="language-vue">new Vue({             data:{                 name:"aa"             },             template:"<h1>{{name}}</h1>"     }     ).$mount('#app');</code></pre><h6 id="使用渲染函数"><a href="#使用渲染函数" class="headerlink" title="使用渲染函数"></a>使用渲染函数</h6><pre class=" language-vue"><code class="language-vue">new Vue({             data:{                 name:"aa"             },             template:"<h1>{{name}}</h1>"     }     ).$mount('#app');已及new Vue({             data:{                 name:"lisi"             },             render(c){                 return c("h1",{style:{color:'red'}},this.name)             }     }     ).$mount('#app');</code></pre><h5 id="路由入门"><a href="#路由入门" class="headerlink" title="路由入门"></a>路由入门</h5><h6 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h6><p><a href="https://router.vuejs.org/zh/installation.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/installation.html</a></p><h6 id="2、使用引导"><a href="#2、使用引导" class="headerlink" title="2、使用引导"></a>2、使用引导</h6><p><a href="https://router.vuejs.org/zh/guide/#html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/#html</a></p><p>在项目目录下执行</p><pre class=" language-vue"><code class="language-vue">npm install vue-router</code></pre><h5 id="iview文档"><a href="#iview文档" class="headerlink" title="iview文档"></a>iview文档</h5><p><a href="http://iview.talkingdata.com/#/components/guide/start" target="_blank" rel="noopener">http://iview.talkingdata.com/#/components/guide/start</a></p><pre class=" language-shell"><code class="language-shell">首先 搞一个 文件夹 ，执行 1、vue create myui 2、用webstorm 打开这个文件夹3、npm install iview --save  安装iview框架4 、 npm install --save vue-router  安装vue路由</code></pre>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-fabric</title>
      <link href="2020/05/31/devops/python-zhi-fabric-mo-kuai/"/>
      <url>2020/05/31/devops/python-zhi-fabric-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h3 id="python-之-fabric-模块"><a href="#python-之-fabric-模块" class="headerlink" title="python 之 fabric 模块"></a>python 之 fabric 模块</h3><p>Fabric 是一个用 Python 开发的部署工具，最大特点是不用登录远程服务器，在本地运行远程命令，几行 Python 脚本就可以轻松部署。</p><pre><code># doc http://docs.fabfile.org/en/2.5/getting-started.html# pip install fabric -i http://mirrors.aliyun.com/pypi/simple/</code></pre><h5 id="G站部署脚本-参考-示范"><a href="#G站部署脚本-参考-示范" class="headerlink" title="G站部署脚本 参考 示范"></a>G站部署脚本 参考 示范</h5><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> fabric <span class="token keyword">import</span> Connection<span class="token punctuation">,</span> task<span class="token keyword">from</span> fabric<span class="token punctuation">.</span>api <span class="token keyword">import</span> env<span class="token punctuation">,</span>hosts<span class="token punctuation">,</span>run<span class="token punctuation">,</span>execute@task<span class="token keyword">def</span> <span class="token function">deploy</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> Connection<span class="token punctuation">(</span><span class="token string">'root@x.x.x.x'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> c<span class="token punctuation">:</span>        c<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">"rm -rf giligili"</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">"git clone https://github.com/bydmm/giligili.git"</span><span class="token punctuation">,</span> pty<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"docker-compose.yml"</span><span class="token punctuation">,</span> <span class="token string">"giligili/docker-compose.yml"</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">"cd giligili &amp;&amp; docker-compose build &amp;&amp; docker-compose rm -fsv &amp;&amp; docker-compose up --build -d"</span><span class="token punctuation">,</span> pty<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">"sleep 15 &amp;&amp; docker logs -f gili-api"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># doc http://docs.fabfile.org/en/2.5/getting-started.html</span><span class="token comment" spellcheck="true"># apt install python-pip</span><span class="token comment" spellcheck="true"># pip install fabric -i http://mirrors.aliyun.com/pypi/simple/</span><span class="token comment" spellcheck="true"># fab deploy</span></code></pre><p>以上定义了pack和deploy两个任务，如果我们用Fabric部署，只需简单地输入两条命令：</p><pre><code>$ fab pack$ fab deploy</code></pre><p>Fabric提供几个简单的API来完成所有的部署，最常用的是local()和run()，分别在本地和远程执行命令，put()可以把本地文件上传到远程，当需要在远程指定当前目录时，只需用with cd(‘/path/to/dir/‘):即可。</p><p>默认情况下，当命令执行失败时，Fabric会停止执行后续命令。有时，我们允许忽略失败的命令继续执行，比如run(‘rm /tmp/abc’)在文件不存在的时候有可能失败，这时可以用with settings(warn_only=True):执行命令，这样Fabric只会打出警告信息而不会中断执行。</p><p>Fabric是如何在远程执行命令的呢？其实Fabric所有操作都是基于SSH执行的，必要时它会提示输入口令，所以非常安全。更好的办法是在指定的部署服务器上用证书配置无密码的ssh连接。</p><p>如果是基于团队开发，可以让Fabric利用版本库自动检出代码，自动执行测试、打包、部署的任务。由于Fabric运行的命令都是基本的Linux命令，所以根本不需要用Fabric本身来扩展，会敲Linux命令就能用Fabric部署。</p><p>利用Fabric部署Python、Ruby、PHP这样的非编译型网站应用非常方便，而对于编译型的Java、C#等就麻烦了，编译本身就是一个极其复杂的大工程，需要依赖特定工具或者IDE，很难做到自动化。</p><h4 id="fab命令常用参数"><a href="#fab命令常用参数" class="headerlink" title="fab命令常用参数"></a><strong>fab命令常用参数</strong></h4><pre class=" language-shell"><code class="language-shell"># fab --help   查看帮助## 常用参数-l 显示定义好的任务函数名-f 指定fab入口文件，默认入口文件名为fabfile.py.. 即指定fabfile文件-g 指定网关（中转）设备，即HOST逗号分隔要操作的主机, 比如堡垒机环境，填写堡垒机IP即可.-H 指定目标主机，多台主机用‘,’号分隔-p 远程账号的密码，fab执行时默认使用root账户-P 以异步并行方式运行多主机任务，默认为串行运行-R 指定role（角色），以角色名区分不同业务组设备-t 设置设备连接超时时间（秒）-T 设置远程主机命令执行超时时间（秒）-w 当命令执行失败，发出警告，而非默认中止任务。</code></pre><pre class=" language-shell"><code class="language-shell">其他参数:--set=KEY=VALUE,...   逗号分隔，设置环境变量--shortlist       简短打印可用命令-c PATH         指定本地配置文件-D           不加载用户known_hosts文件-i PATH         指定私钥文件-k           不加载来自~/.``ssh``下的私钥文件--port=PORT       指定SSH连接端口-R ROLES        根据角色操作，逗号分隔-s SHELL        指定新shell，默认是``'/bin/bash -l -c'--show=LEVELS      以逗号分隔的输出--ssh-config-path=PATH SSH配置文件路径-T N          设置远程命令超时时间，单位秒-u USER         连接远程主机用户名-x HOSTS        以逗号分隔排除主机-z INT         并发进程数</code></pre><h4 id="fabfile全局属性-env对象"><a href="#fabfile全局属性-env对象" class="headerlink" title="fabfile全局属性 (env对象)"></a>fabfile全局属性 (env对象)</h4><p><img src="https://s1.ax1x.com/2020/05/31/t1Gv3F.png" alt="t1Gv3F.png"></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计划任务及日志管理</title>
      <link href="2020/05/30/linux/ji-hua-ren-wu-ji-ri-zhi-guan-li/"/>
      <url>2020/05/30/linux/ji-hua-ren-wu-ji-ri-zhi-guan-li/</url>
      
        <content type="html"><![CDATA[<h4 id="循环调度执行cron"><a href="#循环调度执行cron" class="headerlink" title="循环调度执行cron"></a>循环调度执行cron</h4><h5 id="1-1简介cron"><a href="#1-1简介cron" class="headerlink" title="1.1简介cron"></a>1.1简介cron</h5><pre class=" language-reStructuredText"><code class="language-reStructuredText">    crond的概念和crontab是不可分割的。crontab是一个命令，常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行</code></pre><h5 id="1-2认识crond进程"><a href="#1-2认识crond进程" class="headerlink" title="1.2认识crond进程"></a>1.2认识crond进程</h5><pre class=" language-shell"><code class="language-shell">[root@JX01 ~]# systemctl status crond● crond.service - Command Scheduler   Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled)   Active: active (running) since 三 2018-08-01 07:03:23 CST; 17min ago Main PID: 671 (crond)   CGroup: /system.slice/crond.service           └─671 /usr/sbin/crond -n8月 01 07:03:23 JX01 systemd[1]: Started Command Scheduler.8月 01 07:03:23 JX01 systemd[1]: Starting Command Scheduler...8月 01 07:03:23 JX01 crond[671]: (CRON) INFO (RANDOM_DELAY will be scaled with factor 2% if used.)8月 01 07:03:23 JX01 crond[671]: (CRON) INFO (running with inotify support)[root@JX01 ~]#[root@JX01 ~]# ps aux | grep crondroot        671  0.0  0.0 126280  1668 ?        Ss   07:03   0:00 /usr/sbin/crond -nroot       1440  0.0  0.0 112720   980 pts/0    R+   07:21   0:00 grep --color=auto crond[root@JX01 ~]#</code></pre><h5 id="1-3创建计划任务"><a href="#1-3创建计划任务" class="headerlink" title="1.3创建计划任务"></a>1.3创建计划任务</h5><pre class=" language-shell"><code class="language-shell">#计划任务存储的位置[root@JX01 ~]# ls /var/spool/cron/root jack alice#管理计划任务的命令crontab:  -l     Displays the current crontab on standard output.  -r     Removes the current crontab.  -e     Edits  the current crontab using the editor specified.#计划任务书写的格式.---------------- minute (0 - 59)| .-------------- hour (0 - 23)| | .------------ day of month (1 - 31)| | | .---------- month (1 - 12) OR jan,feb,mar,apr ...| | | | .-------- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat| | | | |* * * * * command#计划任务案例00 02 * * *    ls        //每天2:00整00 02 1 * *    ls        //每月1号2:00整00 02 14 2 * ls        //每年2月14号2:00整00 02 * * 7 ls        //每周日2:00整00 02 * 6 5 ls        //每年6月的周五2:00整（特殊）00 02 14 * 7 ls        //每月14号2:00整 或者 每周日2:00整，这两个时间都执行00 02 14 2 7 ls        //每年2月14号2:00整 或者 每周日2:00整，这两个时间都执行00 02 * * * ls        //每天2:00整* 02 * * * ls        //每天2:00中的每一分钟* * * * * ls        //每分钟执行ls* * 14 2 * ls        //2月14号的每分钟 1440分钟*/5 * * * * ls        //每隔5分钟00 02 1,5,8 * * ls    //每月1,5,8号的2:00整00 02 1-8 * * ls    //每月1到8号的2:00整00 02 * 1-10 * ls#测试计划任务的执行效果1 编写执行脚本.vim /crontab.sh touch /root/`date +%F-%X`.txt2 编排任务计划[root@localhost ~]# crontab -e* * 1 1 * bash /crontab.sh3 修改日期时间为1月2日3点4分date 01020304修改时间为1点2分3秒date -s 01:02:034 监控当前目录watch -n 0.5 'ls /root/*.txt'5 测试目标* * * * 1    //每周1            每分钟会执行* * * 1 *    //1月每日          每分钟会执行* * * 1 1    //1月的周1         每分钟会执行* * 1 * *    //每月1日          每分钟会执行* * 1 * 1    //每月1日和每月周1 每分钟会执行* * 1 1 *    //1月1日           每分钟会执行* * 1 1 1    //1月1日和1月的周1 每分钟都会执行</code></pre><h4 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h4><pre><code>    日志：在现代社会里,为了维护自身系统资源的运行状况,计算机系统一般都会有相应的日志记录系统有关日常事件或者误操作警报的日期及时间戳信息。这些日志信息对计算机犯罪调查人员非常有用,但计算机日记是按正常工作状态记录的,所以冗余量很大,对查找与分析有用信息造成很大困难。#Linux系统中存在的日志都在哪里？/var/log/    # tail /var/log/messages             //系统主日志文件    # tail -20 /var/log/messages    # tail -f /var/log/messages         //动态查看日志文件的尾部    # tailf /var/log/secure                 //认证、安全    # tail /var/log/maillog                 //跟邮件postfix相关 prefix    # tail /var/log/cron                //crond、at进程产生的日志    # tail /var/log/dmesg                 //和系统启动相关    # tail /var/log/audit/audit.log        //系统审计日志    # tail /var/log/yum.log                 //yum    # tail /var/log/mysqld.log             //MySQL    # tail /var/log/xferlog             //和访问FTP服务器相关    # tail  /var/log/wtmp                 //当前登录的用户（命令：w）    # tail  /var/log/btmp                 //最近登录的用户（命令last）    # tail  /var/log/lastlog            //所有用户的登录情况（命令lastlog）#Linux系统是什么进程程序在管理日志？rsyslog</code></pre><pre class=" language-shell"><code class="language-shell">##rsyslogrsyslog：linux系统中管理日志的服务所产生的进程是: rsyslogd -nlinux中的配置文件:    linux中所有的服务或者工具,都是由配置文件驱动工作的;    Linux中的工具或服务都是遵循配置文件中的规则工作的;/etc/rsyslog.conf:    这个文件定义了系统中所有的服务或者工具,它们所产生的日志,根据特定的级别需要存储在特定的位置日志等级:    等级由低到高：debug<info<warn<Error<Fatal系统或服务的排错:    根据配置文件的对错有一下两种方案供给选择:        1. 查看rsyslog的 journalctl -xe 找出服务或系统的报错信息        2. 根据服务自身的检测机制,去检查配置文件的语法        3. 系统常用排错指令 journalctl -xe\\ systemctl status service.name\\ 服务自带检测工具bash -nx    检测shell脚本的语法问题httpd -t    检测apache web服务的配置文件语法问题nginx -t    检测nginx web服务的配置文件语法问题[root@JX02 ~]# vim /etc/rsyslog.conf#### RULES ##### Log all kernel messages to the console.# Logging much else clutters up the screen.#kern.*                                                 /dev/console# Log anything (except mail) of level info or higher.# Don't log private authentication messages!*.info;mail.none;authpriv.none;cron.none                /var/log/messages# The authpriv file has restricted access.authpriv.*                                              /var/log/secure# Log all the mail messages in one place.mail.*                                                  -/var/log/maillog# Log cron stuffcron.*                                                  /var/log/cron# Everybody gets emergency messages*.emerg                                                 :omusrmsg:*# Save news errors of level crit and higher in a special file.uucp,news.crit                                          /var/log/spooler# Save boot messages also to boot.loglocal7.*                                                /var/log/boot.log</code></pre><pre class=" language-shell"><code class="language-shell">##logrotate#认识一下logrotate为了节省空间和整理方便，日志文件经常需要按！时间或！大小等维度分成多份，删除时间久远的日志文件。这就是通常说的日志滚动(log rotation)logrotate本身不是系统守护进程，它是通过计划任务crond每天执行#logrotate配置文件：主文件：/etc/logrotate.conf (决定每个日志文件如何轮转)子文件夹：/etc/logrotate.d/*#认识logrotate的选项含义==================全局设置==================weekly                              //轮转周期，一周轮转rotate 4                            //保留4份create                              //轮转后创建新文件dateext                             //使用日期作为后缀compress                            //是否压缩include /etc/logrotate.d            //包含该目录下的文件/var/log/wtmp {                     //对该日志文件设置轮转的方法    monthly                         //一个月轮转一次    create 0664 root utmp           //轮转后创建新文件，并设置权限    minsize 1M                      //最小达到1M才轮转    rotate 1                        //保留一份}/var/log/btmp {    missingok                       //丢失不提示    monthly    create 0600 root utmp    rotate 1}=========================================参数========================================compress             通过gzip 压缩转储以后的日志nocompress           不做gzip压缩处理copytruncate         用于还在打开中的日志文件，把当前日志备份并截断；是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据。nocopytruncate              备份日志文件不过不截断create mode owner group    轮转时指定创建新文件的属性，如create 0777 nobody nobodynocreate                   不建立新的日志文件delaycompress              和compress 一起使用时，转储的日志文件到下一次转储时才压缩nodelaycompress            覆盖 delaycompress 选项，转储同时压缩missingok                  如果日志丢失，不报错继续滚动下一个日志errors address             专储时的错误信息发送到指定的Email 地址ifempty                    即使日志文件为空文件也做轮转，这个是logrotate的缺省选项notifempty                 当日志文件为空时，不进行轮转mail address               把转储的日志文件发送到指定的E-mail 地址nomail                     转储时不发送日志文件olddir directory           转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统noolddir                   转储后的日志文件和当前日志文件放在同一个目录下sharedscripts运行postrotate脚本，作用是在所有日志都轮转后统一执行一次脚本。如果没有配置这个，那么每个日志轮转后都会执行一次脚本prerotate        在logrotate转储之前需要执行的指令，例如修改文件的属性等动作；必须独立成行postrotate       在logrotate转储之后需要执行的指令，例如重新启动 (kill -HUP) 某个服务！必须独立成行daily                      指定转储周期为每天weekly                     指定转储周期为每周monthly                    指定转储周期为每月rotate count               指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份dateext                    使用当期日期作为命名格式dateformat .%s配合dateext使用，紧跟在下一行出现，定义文件切割后的文件名，必须配合dateext使用，只支持 %Y %m %d %s 这四个参数size(或minsize) log-size当日志文件到达指定的大小时才轮转，log-size能指定bytes(缺省)及KB (sizek)或MB(sizem).当日志文件 >= log-size 的时候就转储。 以下为合法格式：（其他格式的单位大小写没有试过）size = 5 或 size 5 （>= 5 个字节就转储）size = 100k 或 size 100ksize = 100M 或 size 100M=================================================================================#案例一:普通切割[root@JX02 ~]# vim  /etc/logrotate.d/yum/var/log/yum.log {missingok            //丢失不执行# notifempty        //空文件不轮转# size 30k            //达到30k轮转, daily or size# yearly            //或者一年一轮转daily                //缩小周期到1天rotate 3            //轮转保留3次create 0777 root root}[root@JX02 ~]# /usr/sbin/logrotate -f /etc/logrotate.conf        //强制轮转日志[root@JX02 ~]# ll /var/log/yum*                                    //发现日志已经被切割了#案例二:切割前后执行动作[root@JX02 ~]# vim /etc/logrotate.d/httpd/var/log/httpd/* {prerotatechattr -a /var/log/httpdendscript#notifemptydailycreate 0600 root rootmissingokrotate 5postrotatechattr +a /var/log/httpdendscript}[root@JX02 logrotate.d]# /usr/sbin/logrotate -f /etc/logrotate.conf#案例三:切割多个日志文件[root@JX02 ~]# vim /etc/logrotate.d/web/var/log/httpd_test.log/var/log/nginx_test.log/var/log/tomcat_test.log{dailycreate 0600 root rootmissingokrotate 5}[root@JX02 ~]# /usr/sbin/logrotate -f /etc/logrotate.conf#案例四:切割一个文件夹下的所有日志[root@JX02 ~]# vim /etc/logrotate.d/apache/var/log/apache/*log {dailycreate 0600 root rootmissingokrotate 5}[root@JX02 logrotate.d]# /usr/sbin/logrotate -f /etc/logrotate.conf</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins_流水线语法_002</title>
      <link href="2020/05/30/devops/jenkins-liu-shui-xian-yu-fa-002/"/>
      <url>2020/05/30/devops/jenkins-liu-shui-xian-yu-fa-002/</url>
      
        <content type="html"><![CDATA[<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><code>parameters</code> 指令提供了一个用户在触发流水线时应该提供的参数列表。这些用户指定参数的值可通过 <code>params</code> 对象提供给流水线步骤, 了解更多请参考<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#parameters-example" target="_blank" rel="noopener">示例</a>。</p><table><thead><tr><th align="left">Required</th><th>No</th></tr></thead><tbody><tr><td align="left">Parameters</td><td><em>None</em></td></tr><tr><td align="left">Allowed</td><td>Only once, inside the <code>pipeline</code> block.</td></tr></tbody></table><h5 id="可用参数"><a href="#可用参数" class="headerlink" title="可用参数"></a>可用参数</h5><ul><li><p>string</p><p>字符串类型的参数, 例如: <code>parameters { string(name: &#39;DEPLOY_ENV&#39;, defaultValue: &#39;staging&#39;, description: &#39;&#39;) }</code></p></li><li><p>booleanParam</p><p>布尔参数, 例如: <code>parameters { booleanParam(name: &#39;DEBUG_BUILD&#39;, defaultValue: true, description: &#39;&#39;) }</code></p></li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    parameters <span class="token punctuation">{</span>        <span class="token function">string</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">'PERSON'</span><span class="token punctuation">,</span> defaultValue<span class="token punctuation">:</span> <span class="token string">'Mr Jenkins'</span><span class="token punctuation">,</span> description<span class="token punctuation">:</span> <span class="token string">'Who should I say hello to?'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">"Hello ${params.PERSON}"</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><table><thead><tr><th></th><th>一份完整的可用参数列表正在等待 <a href="https://issues.jenkins-ci.org/browse/INFRA-1053" target="_blank" rel="noopener">INFRA-1503</a>的完成。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p><code>triggers</code> 指令定义了流水线被重新触发的自动化方法。对于集成了源（ 比如 GitHub 或 BitBucket）的流水线, 可能不需要 <code>triggers</code> ，因为基于 web 的集成很肯能已经存在。 当前可用的触发器是 <code>cron</code>, <code>pollSCM</code> 和 <code>upstream</code>。</p><table><thead><tr><th align="left">Required</th><th>No</th></tr></thead><tbody><tr><td align="left">Parameters</td><td><em>None</em></td></tr><tr><td align="left">Allowed</td><td>Only once, inside the <code>pipeline</code> block.</td></tr></tbody></table><ul><li><p>cron</p><p>接收 cron 样式的字符串来定义要重新触发流水线的常规间隔 ,比如: <code>triggers { cron(&#39;H */4 * * 1-5&#39;) }</code></p></li><li><p>pollSCM</p><p>接收 cron 样式的字符串来定义一个固定的间隔，在这个间隔中，Jenkins 会检查新的源代码更新。如果存在更改, 流水线就会被重新触发。例如: <code>triggers { pollSCM(&#39;H */4 * * 1-5&#39;) }</code></p></li><li><p>upstream</p><p>接受逗号分隔的工作字符串和阈值。 当字符串中的任何作业以最小阈值结束时，流水线被重新触发。例如: <code>triggers { upstream(upstreamProjects: &#39;job1,job2&#39;, threshold: hudson.model.Result.SUCCESS) }</code></p></li></ul><table><thead><tr><th></th><th><code>pollSCM</code> 只在Jenkins 2.22 及以上版本中可用。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    triggers <span class="token punctuation">{</span>        <span class="token function">cron</span><span class="token punctuation">(</span><span class="token string">'H */4 * * 1-5'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="stage"><a href="#stage" class="headerlink" title="stage"></a>stage</h4><p><code>stage</code> 指令在 <code>stages</code> 部分进行，应该包含一个 实际上, 流水巷所做的所有实际工作都将封装进一个或多个 <code>stage</code> 指令中。</p><table><thead><tr><th align="left">Required</th><th>At least one</th></tr></thead><tbody><tr><td align="left">Parameters</td><td>One mandatory parameter, a string for the name of the stage.</td></tr><tr><td align="left">Allowed</td><td>Inside the <code>stages</code> section.</td></tr></tbody></table><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>定义自动安装和放置 <code>PATH</code> 的工具的一部分。如果 <code>agent none</code> 指定，则忽略该操作。</p><table><thead><tr><th align="left">Required</th><th>No</th></tr></thead><tbody><tr><td align="left">Parameters</td><td><em>None</em></td></tr><tr><td align="left">Allowed</td><td>Inside the <code>pipeline</code> block or a <code>stage</code> block.</td></tr></tbody></table><h5 id="支持工具"><a href="#支持工具" class="headerlink" title="支持工具"></a>支持工具</h5><ul><li>maven</li><li>jdk</li><li>gradle</li></ul><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    tools <span class="token punctuation">{</span>        maven <span class="token string">'apache-maven-3.0.1'</span>     <span class="token punctuation">}</span>    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                sh <span class="token string">'mvn --version'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><table><thead><tr><th></th><th>The tool name must be pre-configured in Jenkins under <strong>Manage Jenkins</strong> → <strong>Global Tool Configuration</strong>.</th></tr></thead><tbody><tr><td></td><td>工具名称必须在Jenkins中的Manage Jenkins→全局工具配置下预先配置。</td></tr></tbody></table><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p><code>stage</code> 的 <code>input</code> 指令允许你使用 <a href="https://jenkins.io/doc/pipeline/steps/pipeline-input-step/#input-wait-for-interactive-input" target="_blank" rel="noopener"><code>input</code> step</a>提示输入。 在应用了 <code>options</code> 后，进入 <code>stage</code> 的 <code>agent</code> 或评估 <code>when</code> 条件前， <code>stage</code> 将暂停。 如果 <code>input</code> 被批准, <code>stage</code> 将会继续。 作为 <code>input</code> 提交的一部分的任何参数都将在环境中用于其他 <code>stage</code>。</p><h5 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h5><ul><li><p>message</p><p>必需的。 这将在用户提交 <code>input</code> 时呈现给用户。</p></li><li><p>id</p><p><code>input</code> 的可选标识符， 默认为 <code>stage</code> 名称。</p></li><li><p>ok</p><p><code>input</code>表单上的”ok” 按钮的可选文本。</p></li><li><p>submitter</p><p>可选的以逗号分隔的用户列表或允许提交 <code>input</code> 的外部组名。默认允许任何用户。</p></li><li><p>submitterParameter</p><p>环境变量的可选名称。如果存在，用 <code>submitter</code> 名称设置。</p></li><li><p>parameters</p><p>提示提交者提供的一个可选的参数列表。 更多信息参见 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#parameters" target="_blank" rel="noopener">[parameters]</a>。</p></li></ul><h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            input <span class="token punctuation">{</span>                message <span class="token string">"Should we continue?"</span>                ok <span class="token string">"Yes, we should."</span>                submitter <span class="token string">"alice,bob"</span>                parameters <span class="token punctuation">{</span>                    <span class="token function">string</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">'PERSON'</span><span class="token punctuation">,</span> defaultValue<span class="token punctuation">:</span> <span class="token string">'Mr Jenkins'</span><span class="token punctuation">,</span> description<span class="token punctuation">:</span> <span class="token string">'Who should I say hello to?'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">"Hello, ${PERSON}, nice to meet you."</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><p><code>when</code> 指令允许流水线根据给定的条件决定是否应该执行阶段。 <code>when</code> 指令必须包含至少一个条件。 如果 <code>when</code> 指令包含多个条件, 所有的子条件必须返回True，阶段才能执行。 这与子条件在 <code>allOf</code> 条件下嵌套的情况相同 (参见下面的<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#when-example" target="_blank" rel="noopener">示例</a>)。</p><p>使用诸如 <code>not</code>, <code>allOf</code>, 或 <code>anyOf</code> 的嵌套条件可以构建更复杂的条件结构 can be built 嵌套条件刻意潜逃到任意深度。</p><table><thead><tr><th align="left">Required</th><th>No</th></tr></thead><tbody><tr><td align="left">Parameters</td><td><em>None</em></td></tr><tr><td align="left">Allowed</td><td>Inside a <code>stage</code> directive</td></tr></tbody></table><h5 id="内置条件"><a href="#内置条件" class="headerlink" title="内置条件"></a>内置条件</h5><ul><li><p>branch</p><p>当正在构建的分支与模式给定的分支匹配时，执行这个阶段, 例如: <code>when { branch &#39;master&#39; }</code>。注意，这只适用于多分支流水线。</p></li><li><p>environment</p><p>当指定的环境变量是给定的值时，执行这个步骤, 例如: <code>when { environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; }</code></p></li><li><p>expression</p><p>当指定的Groovy表达式评估为true时，执行这个阶段, 例如: <code>when { expression { return params.DEBUG_BUILD } }</code></p></li><li><p>not</p><p>当嵌套条件是错误时，执行这个阶段,必须包含一个条件，例如: <code>when { not { branch &#39;master&#39; } }</code></p></li><li><p>allOf</p><p>当所有的嵌套条件都正确时，执行这个阶段,必须包含至少一个条件，例如: <code>when { allOf { branch &#39;master&#39;; environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; } }</code></p></li><li><p>anyOf</p><p>当至少有一个嵌套条件为真时，执行这个阶段,必须包含至少一个条件，例如: <code>when { anyOf { branch &#39;master&#39;; branch &#39;staging&#39; } }</code></p></li></ul><h5 id="在进入-stage-的-agent-前评估-when"><a href="#在进入-stage-的-agent-前评估-when" class="headerlink" title="在进入 stage 的 agent 前评估 when"></a>在进入 <code>stage</code> 的 <code>agent</code> 前评估 <code>when</code></h5><p>默认情况下, 如果定义了某个阶段的代理，在进入该<code>stage</code> 的 <code>agent</code> 后该 <code>stage</code> 的 <code>when</code> 条件将会被评估。但是, 可以通过在 <code>when</code> 块中指定 <code>beforeAgent</code> 选项来更改此选项。 如果 <code>beforeAgent</code> 被设置为 <code>true</code>, 那么就会首先对 <code>when</code> 条件进行评估 , 并且只有在 <code>when</code> 条件验证为真时才会进入 <code>agent</code> 。</p><h5 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Build'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Deploy'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            when <span class="token punctuation">{</span>                branch <span class="token string">'production'</span>            <span class="token punctuation">}</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Deploying'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Build'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Deploy'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            when <span class="token punctuation">{</span>                branch <span class="token string">'production'</span>                environment name<span class="token punctuation">:</span> <span class="token string">'DEPLOY_TO'</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">'production'</span>            <span class="token punctuation">}</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Deploying'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Build'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Deploy'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            when <span class="token punctuation">{</span>                allOf <span class="token punctuation">{</span>                    branch <span class="token string">'production'</span>                    environment name<span class="token punctuation">:</span> <span class="token string">'DEPLOY_TO'</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">'production'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Deploying'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Build'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Deploy'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            when <span class="token punctuation">{</span>                branch <span class="token string">'production'</span>                anyOf <span class="token punctuation">{</span>                    environment name<span class="token punctuation">:</span> <span class="token string">'DEPLOY_TO'</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">'production'</span>                    environment name<span class="token punctuation">:</span> <span class="token string">'DEPLOY_TO'</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">'staging'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Deploying'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Build'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Deploy'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            when <span class="token punctuation">{</span>                expression <span class="token punctuation">{</span> BRANCH_NAME <span class="token operator">==~</span> <span class="token string">/(production|staging)/</span> <span class="token punctuation">}</span>                anyOf <span class="token punctuation">{</span>                    environment name<span class="token punctuation">:</span> <span class="token string">'DEPLOY_TO'</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">'production'</span>                    environment name<span class="token punctuation">:</span> <span class="token string">'DEPLOY_TO'</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">'staging'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Deploying'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent none    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Build'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Deploy'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            agent <span class="token punctuation">{</span>                label <span class="token string">"some-label"</span>            <span class="token punctuation">}</span>            when <span class="token punctuation">{</span>                beforeAgent <span class="token boolean">true</span>                branch <span class="token string">'production'</span>            <span class="token punctuation">}</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Deploying'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>声明式流水线的阶段可以在他们内部声明多隔嵌套阶段, 它们将并行执行。 注意，一个阶段必须只有一个 <code>steps</code> 或 <code>parallel</code> 的阶段。 嵌套阶段本身不能包含进一步的 <code>parallel</code> 阶段, 但是其他的阶段的行为与任何其他 <code>stage</code> 相同。任何包含 <code>parallel</code> 的阶段不能包含 <code>agent</code> 或 <code>tools</code> 阶段, 因为他们没有相关 <code>steps</code>。</p><p>另外, 通过添加 <code>failFast true</code> 到包含 <code>parallel</code>的 <code>stage</code> 中， 当其中一个进程失败时，你可以强制所有的 <code>parallel</code> 阶段都被终止。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Non-Parallel Stage'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'This stage will be executed first.'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Parallel Stage'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            when <span class="token punctuation">{</span>                branch <span class="token string">'master'</span>            <span class="token punctuation">}</span>            failFast <span class="token boolean">true</span>            parallel <span class="token punctuation">{</span>                <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Branch A'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    agent <span class="token punctuation">{</span>                        label <span class="token string">"for-branch-a"</span>                    <span class="token punctuation">}</span>                    steps <span class="token punctuation">{</span>                        echo <span class="token string">"On Branch A"</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Branch B'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    agent <span class="token punctuation">{</span>                        label <span class="token string">"for-branch-b"</span>                    <span class="token punctuation">}</span>                    steps <span class="token punctuation">{</span>                        echo <span class="token string">"On Branch B"</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>声明式流水线可能使用在 <a href="https://www.jenkins.io/doc/pipeline/steps" target="_blank" rel="noopener">流水线步骤引用</a>中记录的所有可用的步骤, 它包含一个完整的步骤列表, 其中添加了下面列出的步骤，这些步骤只在声明式流水线中 <strong>only supported</strong> 。</p><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p><code>script</code> 步骤需要 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#scripted-pipeline" target="_blank" rel="noopener">[scripted-pipeline]</a>块并在声明式流水线中执行。 对于大多数用例来说,应该声明式流水线中的“脚本”步骤是不必要的， 但是它可以提供一个有用的”逃生出口”。 非平凡的规模和/或复杂性的 <code>script</code> 块应该被转移到 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#shared-libraries#" target="_blank" rel="noopener">共享库</a> 。</p><h5 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>                script <span class="token punctuation">{</span>                    <span class="token keyword">def</span> browsers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'chrome'</span><span class="token punctuation">,</span> <span class="token string">'firefox'</span><span class="token punctuation">]</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> browsers<span class="token operator">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        echo <span class="token string">"Testing the ${browsers[i]} browser"</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="脚本化流水线"><a href="#脚本化流水线" class="headerlink" title="脚本化流水线"></a>脚本化流水线</h2><p>脚本化流水线, 与<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#declarative-pipeline" target="_blank" rel="noopener">[declarative-pipeline]</a>一样的是, 是建立在底层流水线的子系统上的。与声明式不同的是, 脚本化流水线实际上是由 <a href="http://groovy-lang.org/syntax.html" target="_blank" rel="noopener">Groovy</a>构建的通用 DSL [<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#_footnotedef_2" target="_blank" rel="noopener">2</a>]。 Groovy 语言提供的大部分功能都可以用于脚本化流水线的用户。这意味着它是一个非常有表现力和灵活的工具，可以通过它编写持续交付流水线。</p><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p>脚本化流水线从 <code>Jenkinsfile</code> 的顶部开始向下串行执行, 就像 Groovy 或其他语言中的大多数传统脚本一样。 因此，提供流控制取决于 Groovy 表达式, 比如 <code>if/else</code> 条件, 例如:</p><p>Jenkinsfile (Scripted Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">node <span class="token punctuation">{</span>    <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>env<span class="token operator">.</span>BRANCH_NAME <span class="token operator">==</span> <span class="token string">'master'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            echo <span class="token string">'I only execute on the master branch'</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            echo <span class="token string">'I execute elsewhere'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>另一种方法是使用Groovy的异常处理支持来管理脚本化流水线流控制。当 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#scripted-steps" target="_blank" rel="noopener">步骤</a> 失败 ，无论什么原因，它们都会抛出一个异常。处理错误的行为必须使用Groovy中的 <code>try/catch/finally</code> 块 , 例如:</p><p>Jenkinsfile (Scripted Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">node <span class="token punctuation">{</span>    <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            sh <span class="token string">'exit 1'</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">exc</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            echo <span class="token string">'Something failed, I should sound the klaxons!'</span>            <span class="token keyword">throw</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><p>正如 <a href="https://www.jenkins.io/zh/doc/book/pipeline/" target="_blank" rel="noopener">本章开始</a>所讨论的, 流水线最基础的部分是”步骤”。从根本上说, 步骤告诉 Jenkins要做 <em>what</em> ，并作为声明式和脚本化流水线已发的基本构建块。</p><p>脚本化流水线 <strong>not</strong> 不引入任何特定于其语法的步骤; <a href="https://www.jenkins.io/doc/pipeline/steps" target="_blank" rel="noopener">流水线步骤引用</a> 包括流水线和插件提供的步骤的完整列表。</p><h3 id="区别普通-Groovy"><a href="#区别普通-Groovy" class="headerlink" title="区别普通 Groovy"></a>区别普通 Groovy</h3><p>为了提供 <em>durability</em>, 这意味着运行流水线可以在Jenkins <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#../glossary#master" target="_blank" rel="noopener">master</a> 重启后继续运行，脚本化的流水线序列化数据到主服务器。由于这个设计需求, 一些Groovy 习惯用语，比如 <code>collection.each { item -&gt; /* perform operation */ }</code> 都不完全支持。详情参见 <a href="https://issues.jenkins-ci.org/browse/JENKINS-27421" target="_blank" rel="noopener">JENKINS-27421</a> 和 <a href="https://issues.jenkins-ci.org/browse/JENKINS-26481" target="_blank" rel="noopener">JENKINS-26481</a>。</p><h2 id="语法比较"><a href="#语法比较" class="headerlink" title="语法比较"></a>语法比较</h2><p>当Jenkins 流水线第一次构建时, Groovy 被选为基础。 Jenkins长期使用嵌入式 Groovy引擎来为管理员和用户提供 高级脚本功能。另外, Jenkins流水线的实现者发现 Groovy是 构建现在成为 “脚本化流水线” DSL的坚实基础 [<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#_footnotedef_2" target="_blank" rel="noopener">2</a>]。</p><p>由于它是一个功能齐全的编程环境, 脚本化流水线为Jenkins用户提供了 大量的灵活性性和可扩展性。 Groovy学习曲线通常不适合给定团队的所有成员, 因此创造了声明式流水线来为编写Jenkins流水线提供一种更简单、更有主见的语法。</p><p>两者本质上是相同的流水线子系统。 underneath. 他们都是 “流水线即代码” 的持久实现。它们都能够使用构建到流水线中或插件提供的步骤。它们都能够使用 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#shared-libraries#" target="_blank" rel="noopener">共享库</a></p><p>但是它们的区别在于语法和灵活性。 声明式限制了用户使用更严格和预定义的结构， 使其成为更简单的持续交付流水线的理想选择。 脚本化提供了很少的限制, 以至于对脚本和语法的唯一限制往往是由Groovy子集本身定义的，而不是任何特定于流水线的系统, 这使他成为权利用户和那些有更复杂需求的人的理想选择。 顾名思义, 声明式流水线鼓励 声明式编程模型。 [<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#_footnotedef_3" target="_blank" rel="noopener">3</a>] 而脚本化流水线遵循一个更命令式的编程模型 [<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#_footnotedef_4" target="_blank" rel="noopener">4</a>]</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins_流水线语法_001</title>
      <link href="2020/05/28/devops/jenkins-liu-shui-xian-yu-fa-001/"/>
      <url>2020/05/28/devops/jenkins-liu-shui-xian-yu-fa-001/</url>
      
        <content type="html"><![CDATA[<h4 id="流水线语法"><a href="#流水线语法" class="headerlink" title="流水线语法"></a>流水线语法</h4><p>本节是建立在 <a href="https://www.jenkins.io/zh/doc/book/pipeline/getting-started" target="_blank" rel="noopener">流水线入门</a>内容的基础上，而且，应当被当作一个参考。 对于在实际示例中如何使用流水线语法的更多信息, 请参阅本章在流水线插件的2.5版本中的 <a href="https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile" target="_blank" rel="noopener">使用 Jenkinsfile</a>部分, 流水线支持两种离散的语法，具体如下对于每种的优缺点, 参见<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#compare" target="_blank" rel="noopener">语法比较</a>。</p><p>正如 <a href="https://www.jenkins.io/zh/doc/book/pipeline/" target="_blank" rel="noopener">本章开始</a>讨论的, 流水线最基础的部分是 “步骤”。基本上, 步骤告诉 Jenkins 要做什么，以及作为声明式和脚本化流水线语法的基本构建块。</p><p>对于可用步骤的概述, 请参考 <a href="https://www.jenkins.io/doc/pipeline/steps" target="_blank" rel="noopener">流水线步骤引用</a>，它包含了一个构建到流水线的步骤和 插件提供的步骤的全面的列表。</p><h4 id="声明式流水线"><a href="#声明式流水线" class="headerlink" title="声明式流水线"></a>声明式流水线</h4><p>声明式流水线是最近添加到 Jenkins 流水线的 [<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#_footnotedef_1" target="_blank" rel="noopener">1</a>]，它在流水线子系统之上提供了一种更简单，更有主见的语法。</p><p>所有有效的声明式流水线必须包含在一个 <code>pipeline</code> 块中, 比如:</p><pre><code>pipeline {    /* insert Declarative Pipeline here */}</code></pre><p>在声明式流水线中有效的基本语句和表达式遵循与 <a href="http://groovy-lang.org/syntax.html" target="_blank" rel="noopener">Groovy的语法</a>同样的规则， 有以下例外:</p><ul><li>流水线顶层必须是一个 <em>block</em>, 特别地: <code>pipeline { }</code></li><li>没有分号作为语句分隔符，，每条语句都必须在自己的行上。</li><li>块只能由 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#declarative-sections" target="_blank" rel="noopener">节段</a>, <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#declarative-directives" target="_blank" rel="noopener">指令</a>, <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">步骤</a>, 或赋值语句组成。 *属性引用语句被视为无参方法调用。 例如, input被视为 input()</li></ul><h3 id="节段"><a href="#节段" class="headerlink" title="节段"></a>节段</h3><p>声明式流水线中的节段通常包含一个或多个 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#declarative-directives" target="_blank" rel="noopener">指令</a> 或 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">步骤</a>。</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p><code>agent</code> 部分指定了整个流水线或特定的部分, 将会在Jenkins环境中执行的位置，这取决于 <code>agent</code> 区域的位置。该部分必须在 <code>pipeline</code> 块的顶层被定义, 但是 stage 级别的使用是可选的。</p><table><thead><tr><th align="left">Required</th><th>Yes</th></tr></thead><tbody><tr><td align="left">Parameters</td><td><a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#agent-parameters" target="_blank" rel="noopener">Described below</a></td></tr><tr><td align="left">Allowed</td><td>In the top-level <code>pipeline</code> block and each <code>stage</code> block.</td></tr></tbody></table><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>为了支持作者可能有的各种各样的用例流水线, <code>agent</code> 部分支持一些不同类型的参数。这些参数应用在<code>pipeline</code>块的顶层, 或 <code>stage</code> 指令内部。</p><ul><li><p>any</p><p>在任何可用的代理上执行流水线或阶段。例如: <code>agent any</code></p></li><li><p>none</p><p>当在 <code>pipeline</code> 块的顶部没有全局代理， 该参数将会被分配到整个流水线的运行中并且每个 <code>stage</code> 部分都需要包含他自己的 <code>agent</code> 部分。比如: <code>agent none</code></p></li><li><p>label</p><p>在提供了标签的 Jenkins 环境中可用的代理上执行流水线或阶段。 例如: <code>agent { label &#39;my-defined-label&#39; }</code></p></li><li><p>node</p><p><code>agent { node { label &#39;labelName&#39; } }</code> 和 <code>agent { label &#39;labelName&#39; }</code> 一样, 但是 <code>node</code> 允许额外的选项 (比如 <code>customWorkspace</code> )。</p></li><li><p>docker</p><p>使用给定的容器执行流水线或阶段。该容器将在预置的 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#../glossary#node" target="_blank" rel="noopener">node</a>上，或在匹配可选定义的<code>label</code> 参数上，动态的供应来接受基于Docker的流水线。 <code>docker</code> 也可以选择的接受 <code>args</code> 参数，该参数可能包含直接传递到 <code>docker run</code> 调用的参数, 以及 <code>alwaysPull</code> 选项, 该选项强制 <code>docker pull</code> ，即使镜像名称已经存在。 比如: </p><pre><code>agent {    docker {        image &#39;maven:3-alpine&#39;        label &#39;my-defined-label&#39;        args  &#39;-v /tmp:/tmp&#39;    }}</code></pre></li><li><p>dockerfile</p><p>执行流水线或阶段, 使用从源代码库包含的 <code>Dockerfile</code> 构建的容器。为了使用该选项， <code>Jenkinsfile</code> 必须从多个分支流水线中加载, 或者加载 “Pipeline from SCM.” 通常，这是源代码仓库的根目录下的 <code>Dockerfile</code> : <code>agent { dockerfile true }</code>. 如果在另一个目录下构建 <code>Dockerfile</code> , 使用 <code>dir</code> 选项: <code>agent { dockerfile {dir &#39;someSubDir&#39; } }</code>。如果 <code>Dockerfile</code> 有另一个名称, 你可以使用 <code>filename</code> 选项指定该文件名。你可以传递额外的参数到 <code>docker build ...</code> 使用 <code>additionalBuildArgs</code> 选项提交, 比如 <code>agent { dockerfile {additionalBuildArgs &#39;--build-arg foo=bar&#39; } }</code>。 例如, 一个带有 <code>build/Dockerfile.build</code> 的仓库,期望一个构建参数 <code>version</code>:</p><pre><code>agent {    // Equivalent to &quot;docker build -f Dockerfile.build --build-arg version=1.0.2 ./build/    dockerfile {        filename &#39;Dockerfile.build&#39;        dir &#39;build&#39;        label &#39;my-defined-label&#39;        additionalBuildArgs  &#39;--build-arg version=1.0.2&#39;    }}</code></pre></li></ul><h5 id="常见选项"><a href="#常见选项" class="headerlink" title="常见选项"></a>常见选项</h5><p>有一些应用于两个或更多 <code>agent</code> 的实现的选项。他们不被要求，除非特别规定。</p><ul><li><p>label</p><p>一个字符串。该标签用于运行流水线或个别的 <code>stage</code>。该选项对 <code>node</code>, <code>docker</code> 和 <code>dockerfile</code> 可用, <code>node</code>要求必须选择该选项。</p></li><li><p>customWorkspace</p><p>一个字符串。在自定义工作区运行应用了 <code>agent</code> 的流水线或个别的 <code>stage</code>, 而不是默认值。 它既可以是一个相对路径, 在这种情况下，自定义工作区会存在于节点工作区根目录下, 或者一个绝对路径。比如:</p><pre><code>agent {    node {        label &#39;my-defined-label&#39;        customWorkspace &#39;/some/other/path&#39;    }}</code></pre><p>该选项对 <code>node</code>, <code>docker</code> 和 <code>dockerfile</code> 有用 。</p></li><li><p>reuseNode</p><p>一个布尔值, 默认为false。 如果是true, 则在流水线的顶层指定的节点上运行该容器, 在同样的工作区, 而不是在一个全新的节点上。这个选项对 <code>docker</code> 和 <code>dockerfile</code> 有用, 并且只有当 使用在个别的 <code>stage</code> 的 <code>agent</code> 上才会有效。</p></li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent <span class="token punctuation">{</span> docker <span class="token string">'maven:3-alpine'</span> <span class="token punctuation">}</span>     stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Build'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                sh <span class="token string">'mvn -B clean verify'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><table><thead><tr><th></th><th>在一个给定名称和标签(<code>maven:3-alpine</code>)的新建的容器上执行定义在流水线中的所有步骤 。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h6 id="阶段级别的-agent-部分"><a href="#阶段级别的-agent-部分" class="headerlink" title="阶段级别的 agent 部分"></a>阶段级别的 <code>agent</code> 部分</h6><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent none     stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Build'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            agent <span class="token punctuation">{</span> docker <span class="token string">'maven:3-alpine'</span> <span class="token punctuation">}</span>             steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello, Maven'</span>                sh <span class="token string">'mvn --version'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example Test'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            agent <span class="token punctuation">{</span> docker <span class="token string">'openjdk:8-jre'</span> <span class="token punctuation">}</span>             steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello, JDK'</span>                sh <span class="token string">'java -version'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><table><thead><tr><th></th><th>在流水线顶层定义 <code>agent none</code> 确保 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#../glossary#executor" target="_blank" rel="noopener">an Executor</a> 没有被分配。 使用 <code>agent none</code> 也会强制 <code>stage</code> 部分包含他自己的 <code>agent</code> 部分。</th></tr></thead><tbody><tr><td></td><td>使用镜像在一个新建的容器中执行该阶段的该步骤。</td></tr><tr><td></td><td>使用一个与之前阶段不同的镜像在一个新建的容器中执行该阶段的该步骤。</td></tr></tbody></table><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p><code>post</code> 部分定义一个或多个<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">steps</a> ，这些阶段根据流水线或阶段的完成情况而 运行(取决于流水线中 <code>post</code> 部分的位置). <code>post</code> 支持以下 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#post-conditions" target="_blank" rel="noopener">post-condition</a> 块中的其中之一: <code>always</code>, <code>changed</code>, <code>failure</code>, <code>success</code>, <code>unstable</code>, 和 <code>aborted</code>。这些条件块允许在 <code>post</code> 部分的步骤的执行取决于流水线或阶段的完成状态。</p><table><thead><tr><th align="left">Required</th><th>No</th></tr></thead><tbody><tr><td align="left">Parameters</td><td><em>None</em></td></tr><tr><td align="left">Allowed</td><td>In the top-level <code>pipeline</code> block and each <code>stage</code> block.</td></tr></tbody></table><h5 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h5><ul><li><p><code>always</code></p><p>无论流水线或阶段的完成状态如何，都允许在 <code>post</code> 部分运行该步骤。</p></li><li><p><code>changed</code></p><p>只有当前流水线或阶段的完成状态与它之前的运行不同时，才允许在 <code>post</code> 部分运行该步骤。</p></li><li><p><code>failure</code></p><p>只有当前流水线或阶段的完成状态为”failure”，才允许在 <code>post</code> 部分运行该步骤, 通常web UI是红色。</p></li><li><p><code>success</code></p><p>只有当前流水线或阶段的完成状态为”success”，才允许在 <code>post</code> 部分运行该步骤, 通常web UI是蓝色或绿色。</p></li><li><p><code>unstable</code></p><p>只有当前流水线或阶段的完成状态为”unstable”，才允许在 <code>post</code> 部分运行该步骤, 通常由于测试失败,代码违规等造成。通常web UI是黄色。</p></li><li><p><code>aborted</code></p><p>只有当前流水线或阶段的完成状态为”aborted”，才允许在 <code>post</code> 部分运行该步骤, 通常由于流水线被手动的aborted。通常web UI是灰色。</p></li></ul><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    post <span class="token punctuation">{</span>         always <span class="token punctuation">{</span>             echo <span class="token string">'I will always say Hello again!'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><table><thead><tr><th></th><th>按照惯例, <code>post</code> 部分应该放在流水线的底部。</th></tr></thead><tbody><tr><td></td><td><a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#post-conditions" target="_blank" rel="noopener">Post-condition</a> 块包含与 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#steps" target="_blank" rel="noopener">steps</a> 部分相同的<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">steps</a>。</td></tr></tbody></table><h4 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h4><p>包含一系列一个或多个 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#stage" target="_blank" rel="noopener">stage</a> 指令, <code>stages</code> 部分是流水线描述的大部分”work” 的位置。 建议 <code>stages</code> 至少包含一个 <a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#stage" target="_blank" rel="noopener">stage</a> 指令用于连续交付过程的每个离散部分,比如构建, 测试, 和部署。</p><table><thead><tr><th align="left">Required</th><th>Yes</th></tr></thead><tbody><tr><td align="left">Parameters</td><td><em>None</em></td></tr><tr><td align="left">Allowed</td><td>Only once, inside the <code>pipeline</code> block.</td></tr></tbody></table><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>         <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><table><thead><tr><th></th><th><code>stages</code> 部分通常会遵循诸如 <code>agent</code>, <code>options</code> 等的指令。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h4><p><code>steps</code> 部分在给定的 <code>stage</code> 指令中执行的定义了一系列的一个或多个<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">steps</a>。</p><table><thead><tr><th align="left">Required</th><th>Yes</th></tr></thead><tbody><tr><td align="left">Parameters</td><td><em>None</em></td></tr><tr><td align="left">Allowed</td><td>Inside each <code>stage</code> block.</td></tr></tbody></table><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                 echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>steps</code> 部分必须包含一个或多个步骤。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p><code>environment</code> 指令制定一个 键-值对序列，该序列将被定义为所有步骤的环境变量，或者是特定于阶段的步骤， 这取决于 <code>environment</code> 指令在流水线内的位置。</p><p>该指令支持一个特殊的助手方法 <code>credentials()</code> ，该方法可用于在Jenkins环境中通过标识符访问预定义的凭证。对于类型为 “Secret Text”的凭证, <code>credentials()</code> 将确保指定的环境变量包含秘密文本内容。对于类型为 “SStandard username and password”的凭证, 指定的环境变量指定为 <code>username:password</code> ，并且两个额外的环境变量将被自动定义 :分别为 <code>MYVARNAME_USR</code> 和 <code>MYVARNAME_PSW</code> 。</p><table><thead><tr><th align="left">Required</th><th>No</th></tr></thead><tbody><tr><td align="left">Parameters</td><td><em>None</em></td></tr><tr><td align="left">Allowed</td><td>Inside the <code>pipeline</code> block, or within <code>stage</code> directives.</td></tr></tbody></table><h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    environment <span class="token punctuation">{</span>         CC <span class="token operator">=</span> <span class="token string">'clang'</span>    <span class="token punctuation">}</span>    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            environment <span class="token punctuation">{</span>                 AN_ACCESS_KEY <span class="token operator">=</span> <span class="token function">credentials</span><span class="token punctuation">(</span><span class="token string">'my-prefined-secret-text'</span><span class="token punctuation">)</span>             <span class="token punctuation">}</span>            steps <span class="token punctuation">{</span>                sh <span class="token string">'printenv'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><table><thead><tr><th></th><th>顶层流水线块中使用的 <code>environment</code> 指令将适用于流水线中的所有步骤。</th></tr></thead><tbody><tr><td></td><td>在一个 <code>stage</code> 中定义的 <code>environment</code> 指令只会将给定的环境变量应用于 <code>stage</code> 中的步骤。</td></tr><tr><td></td><td><code>environment</code> 块有一个 助手方法 <code>credentials()</code> 定义，该方法可以在 Jenkins 环境中用于通过标识符访问预定义的凭证。</td></tr></tbody></table><h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p><code>options</code> 指令允许从流水线内部配置特定于流水线的选项。 流水线提供了许多这样的选项, 比如 <code>buildDiscarder</code>,但也可以由插件提供, 比如 <code>timestamps</code>.</p><table><thead><tr><th align="left">Required</th><th>No</th></tr></thead><tbody><tr><td align="left">Parameters</td><td><em>None</em></td></tr><tr><td align="left">Allowed</td><td>Only once, inside the <code>pipeline</code> block.</td></tr></tbody></table><h5 id="可用选项"><a href="#可用选项" class="headerlink" title="可用选项"></a>可用选项</h5><ul><li><p>buildDiscarder</p><p>为最近的流水线运行的特定数量保存组件和控制台输出。例如: <code>options { buildDiscarder(logRotator(numToKeepStr: &#39;1&#39;)) }</code></p></li><li><p>disableConcurrentBuilds</p><p>不允许同时执行流水线。 可被用来防止同时访问共享资源等。 例如: <code>options { disableConcurrentBuilds() }</code></p></li><li><p>overrideIndexTriggers</p><p>允许覆盖分支索引触发器的默认处理。 如果分支索引触发器在多分支或组织标签中禁用, <code>options { overrideIndexTriggers(true) }</code> 将只允许它们用于促工作。否则, <code>options { overrideIndexTriggers(false) }</code> 只会禁用改作业的分支索引触发器。</p></li><li><p>skipDefaultCheckout</p><p>在<code>agent</code> 指令中，跳过从源代码控制中检出代码的默认情况。例如: <code>options { skipDefaultCheckout() }</code></p></li><li><p>skipStagesAfterUnstable</p><p>一旦构建状态变得UNSTABLE，跳过该阶段。例如: <code>options { skipStagesAfterUnstable() }</code></p></li><li><p>checkoutToSubdirectory</p><p>在工作空间的子目录中自动地执行源代码控制检出。例如: <code>options { checkoutToSubdirectory(&#39;foo&#39;) }</code></p></li><li><p>timeout</p><p>设置流水线运行的超时时间, 在此之后，Jenkins将中止流水线。例如: <code>options { timeout(time: 1, unit: &#39;HOURS&#39;) }</code></p></li><li><p>retry</p><p>在失败时, 重新尝试整个流水线的指定次数。 For example: <code>options { retry(3) }</code></p></li><li><p>timestamps</p><p>预谋所有由流水线生成的控制台输出，与该流水线发出的时间一致。 例如: <code>options { timestamps() }</code></p></li></ul><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    options <span class="token punctuation">{</span>        <span class="token function">timeout</span><span class="token punctuation">(</span>time<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">:</span> <span class="token string">'HOURS'</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><table><thead><tr><th></th><th>指定一个小时的全局执行超时, 在此之后，Jenkins 将中止流水线运行。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th>一个完整的可用选项列表正在等待完成第 <a href="https://issues.jenkins-ci.org/browse/INFRA-1053" target="_blank" rel="noopener">INFRA-1503</a>次。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h5 id="阶段选项"><a href="#阶段选项" class="headerlink" title="阶段选项"></a>阶段选项</h5><p><code>stage</code> 的 <code>options</code> 指令类似于流水线根目录上的 <code>options</code> 指令。然而， <code>stage</code> -级别 <code>options</code> 只能包括 <code>retry</code>, <code>timeout</code>, 或 <code>timestamps</code> 等步骤, 或与 <code>stage</code> 相关的声明式选项，如 <code>skipDefaultCheckout</code>。</p><p>在<code>stage</code>, <code>options</code> 指令中的步骤在进入 <code>agent</code> 之前被调用或在 <code>when</code> 条件出现时进行检查。</p><h6 id="可选的阶段选项"><a href="#可选的阶段选项" class="headerlink" title="可选的阶段选项"></a>可选的阶段选项</h6><ul><li><p>skipDefaultCheckout</p><p>在 <code>agent</code> 指令中跳过默认的从源代码控制中检出代码。例如: <code>options { skipDefaultCheckout() }</code></p></li><li><p>timeout</p><p>设置此阶段的超时时间, 在此之后， Jenkins 会终止该阶段。 例如: <code>options { timeout(time: 1, unit: &#39;HOURS&#39;) }</code></p></li><li><p>retry</p><p>在失败时, 重试此阶段指定次数。 例如: <code>options { retry(3) }</code></p></li><li><p>timestamps</p><p>预谋此阶段生成的所有控制台输出以及该行发出的时间一致。例如: <code>options { timestamps() }</code></p></li></ul><h6 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h6><p>Jenkinsfile (Declarative Pipeline)</p><pre class=" language-groovy"><code class="language-groovy">pipeline <span class="token punctuation">{</span>    agent any    stages <span class="token punctuation">{</span>        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Example'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            options <span class="token punctuation">{</span>                <span class="token function">timeout</span><span class="token punctuation">(</span>time<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">:</span> <span class="token string">'HOURS'</span><span class="token punctuation">)</span>             <span class="token punctuation">}</span>            steps <span class="token punctuation">{</span>                echo <span class="token string">'Hello World'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>指定 <code>Example</code> 阶段的执行超时时间, 在此之后，Jenkins 将中止流水线运行。</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络解析与抓包工具</title>
      <link href="2020/05/21/wang-luo-jie-xi-yu-zhua-bao-gong-ju/"/>
      <url>2020/05/21/wang-luo-jie-xi-yu-zhua-bao-gong-ju/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="网络解析与抓包–简介"><a href="#网络解析与抓包–简介" class="headerlink" title="网络解析与抓包–简介"></a>网络解析与抓包–简介</h3><p>本文简述一下内容：</p><p>TCP三次握手和四次挥手</p><p>网络分析工具tcpdump抓包</p><h5 id="No-1-tcp三次握手和四次挥手"><a href="#No-1-tcp三次握手和四次挥手" class="headerlink" title="No.1 tcp三次握手和四次挥手"></a><strong>No.1 tcp三次握手和四次挥手</strong></h5><p>—确认ACK, 仅当ACK=1时, 确认号字段才有效. TCP规定在连接建立后所有报文的传输都必须把ACK置1</p><p>—同步SYN, 在连接建立时用来同步序号. 当SYN=1 ACK=0 表明是连接请求报文, 若同意连接则响应报文中应该使SYN=1 ACK=1</p><p>—终止FIN, 用来释放连接. 当FIN=1表明此报文的发送方的数据已经发送完毕并且要求释放</p><h6 id="三次握手-建立连接"><a href="#三次握手-建立连接" class="headerlink" title="三次握手_建立连接"></a>三次握手_建立连接</h6><ul><li>第一次握手:Client将标志位SYN置为1, 随机产生一个值seq=x, 并将该数据包发送给Server, Client进入SYN_SENT状态, 等待Server确认</li><li>第二次握手:Server收到数据包后由标志位SYN=1知道Client请求建立连接, Server将标志位SYN和ACK都置为1, ack=x+1, 随机产生一个值seq=y, 并将该数据包发送给Client以确认连接请求, Server进入SYN_RCVD状态</li><li>第三次握手: Client收到确认后, 检查ack是否为x+1, ACK是否为1, 如果正确则将标志位ACK置为1, ack=y+1并将该数据包发送给Server, Server检查ack是否为y+1, ACK是否为1, 如果正确则连接建立成功, Client和Server进入ESTABLISHED状态, 完成三次握手, 随后Client与Server之间可以开始传输数据了</li></ul><p><img src="http://pb3.pstatp.com/large/pgc-image/b58d300a5a7c45e7ae396651edf473a7" alt="img"></p><h6 id="四次挥手-断开连接"><a href="#四次挥手-断开连接" class="headerlink" title="四次挥手_断开连接"></a>四次挥手_断开连接</h6><ul><li>第一次挥手：Client发送一个FIN, 用来关闭Client到Server的数据传送, Client进入FIN_WAIT_1状态</li><li>第二次挥手：Server收到FIN后, 发送一个ACK给Client, 确认序号为收到序号+1, Server进入CLOSE_WAIT状</li><li>第三次挥手：Server发送一个FIN, 用来关闭Server到Client的数据传送, Server进入LAST_ACK状态</li><li>第四次挥手：Client收到FIN后, Client进入TIME_WAIT状态, 接着发送一个ACK给Server, 确认序号为收到序号+1, Server进入CLOSED状态, 完成四次挥手</li></ul><p><img src="http://pb3.pstatp.com/large/pgc-image/5ab36dab139a42e6be52ff4976cc84ea" alt="img"></p><h5 id="No-2-网络分析工具tcpdump抓包"><a href="#No-2-网络分析工具tcpdump抓包" class="headerlink" title="No.2 网络分析工具tcpdump抓包"></a><strong>No.2 网络分析工具tcpdump抓包</strong></h5><p>抓取tcp的三次握手</p><p>tcpdump -S host 192.168.0.108 and 151.101.100.133</p><p><img src="http://pb3.pstatp.com/large/pgc-image/cde15b7285c641cd9ce597ecebf0599e" alt="img"></p><h6 id="抓取tcp的四次挥手"><a href="#抓取tcp的四次挥手" class="headerlink" title="抓取tcp的四次挥手"></a>抓取tcp的四次挥手</h6><p>（算了，懒得写了）在上方的基础上断开连接即可</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview Go_001--undone</title>
      <link href="2020/04/22/interview/interview-go-001/"/>
      <url>2020/04/22/interview/interview-go-001/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="go："><a href="#go：" class="headerlink" title="go："></a>go：</h4><ol><li>超时退出</li><li>context的初始形态？怎么使用contenxt？</li><li>wait group的使用？不加add直接wait是否会panic？</li><li>new和make有什么区别？哪个可以初始化内存为0？</li><li>runtime是什么？runtime属于线程还是协程</li></ol><h4 id="项目："><a href="#项目：" class="headerlink" title="项目："></a>项目：</h4><ol><li><p>什么是JWT？JWT有几部分组成？用什么签名算法？如何实现把一个用户从登陆状态踢出？JWT和session什么区别？</p></li><li><p>什么是前缀树？</p></li></ol><ol start="3"><li>gin中间件原理？中间件用到了什么设计模式？</li></ol><ol start="4"><li>跨域</li></ol><ol start="5"><li>gin文件传送的时候怎么接收？http头部的content-type写什么</li></ol>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview MySQL_001--undone</title>
      <link href="2020/04/22/interview/interview-mysql-001/"/>
      <url>2020/04/22/interview/interview-mysql-001/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>mysql：</p><ol><li>mysql事务的隔离级别</li></ol><ol start="2"><li>什么是乐观锁和悲观锁？乐观锁的一致性怎么保证</li></ol>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview Network_001--undone</title>
      <link href="2020/04/22/interview/interview-network-001/"/>
      <url>2020/04/22/interview/interview-network-001/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>网络</p><ol><li>http的3次握手</li></ol><ol start="2"><li>https的连接过程？双方使用的加密套件是由客户端决定的，还是服务端决定的？</li></ol>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview System_001--undone</title>
      <link href="2020/04/22/interview/interview-system-001/"/>
      <url>2020/04/22/interview/interview-system-001/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>操作系统：</p><ol><li>进程、线程、协程有什么区别？4个线程执行3个文件句柄是共享这3个文件么？</li></ol>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式-undone</title>
      <link href="2020/04/22/interview/fen-bu-shi-jian-jie/"/>
      <url>2020/04/22/interview/fen-bu-shi-jian-jie/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="三大-协议"><a href="#三大-协议" class="headerlink" title="三大 协议"></a>三大 协议</h4><p>raft zab gossip</p><p>raft是etcd用的.    zab是zookeepr用的   gossip是redis集群用的</p><ol><li>raft  一言以蔽之 就是 状态机+ 操作日志 +快照</li></ol><h6 id="见解："><a href="#见解：" class="headerlink" title="见解："></a>见解：</h6><ol><li><p>所谓的分布式 最关键的 就是  各个节点之间“产生关联”，所谓的分布式 最关键的 就是  各个节点之间“产生关联”</p><p>所谓的分布式 最关键的 就是  各个节点之间“产生关联”</p><p>如果 没有“关联” 那么 这只能叫做分开部署</p><p>一旦有了关联  才叫 “分布式“</p></li></ol><ol start="2"><li><p>分布式 有简单的 场景  最基础的是 主从</p><p>譬如MySQL主从  redis主从</p><p>后来逐步演化为 选主。 一旦有了选主 那么就真正叫做集群了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes组件—介绍001</title>
      <link href="2020/04/04/rong-qi/kubernetes-zu-jian-jie-shao-001/"/>
      <url>2020/04/04/rong-qi/kubernetes-zu-jian-jie-shao-001/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>本文档描述了 Kubernetes 的主要组件。</p><h3 id="Master组件"><a href="#Master组件" class="headerlink" title="Master组件"></a>Master组件</h3><p>Master组件是集群的控制平台（control plane）：</p><ul><li>master 组件负责集群中的全局决策（例如，调度）</li><li>master 组件探测并响应集群事件（例如，当 Deployment 的实际 Pod 副本数未达到 <code>replicas</code> 字段的规定时，启动一个新的 Pod）</li></ul><p>Master组件可以运行于集群中的任何机器上。但是，为了简洁性，通常在同一台机器上运行所有的 master 组件，且不在此机器上运行用户的容器。参考 <a href="https://www.kuboard.cn/install/install-kubernetes.html" target="_blank" rel="noopener">安装Kubernetes高可用</a>。</p><h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h4><p>此 master 组件提供 Kubernetes API。这是Kubernetes控制平台的前端（front-end），可以水平扩展（通过部署更多的实例以达到性能要求）。kubectl / kubernetes dashboard / kuboard 等Kubernetes管理工具就是通过 kubernetes API 实现对 Kubernetes 集群的管理。</p><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p>支持一致性和高可用的名值对存储组件，Kubernetes集群的所有配置信息都存储在 etcd 中。请确保您 <a href="https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster" target="_blank" rel="noopener">备份</a> 了 etcd 的数据。关于 etcd 的更多信息，可参考 <a href="https://etcd.io/docs/" target="_blank" rel="noopener">etcd 官方文档</a></p><h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h4><p>此 master 组件监控所有新创建尚未分配到节点上的 Pod，并且自动选择为 Pod 选择一个合适的节点去运行。</p><p>影响调度的因素有：</p><ul><li>单个或多个 Pod 的资源需求</li><li>硬件、软件、策略的限制</li><li>亲和与反亲和（affinity and anti-affinity）的约定</li><li>数据本地化要求</li><li>工作负载间的相互作用</li></ul><h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h4><p>此 master 组件运行了所有的控制器</p><p>逻辑上来说，每一个控制器是一个独立的进程，但是为了降低复杂度，这些控制器都被合并运行在一个进程里。</p><p>kube-controller-manager 中包含的控制器有：</p><ul><li>节点控制器： 负责监听节点停机的事件并作出对应响应</li><li>副本控制器： 负责为集群中每一个 副本控制器对象（Replication Controller Object）维护期望的 Pod 副本数</li><li>端点（Endpoints）控制器：负责为端点对象（Endpoints Object，连接 Service 和 Pod）赋值</li><li>Service Account &amp; Token控制器： 负责为新的名称空间创建 default Service Account 以及 API Access Token</li></ul><h4 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager</h4><p>cloud-controller-manager 中运行了与具体云基础设施供应商互动的控制器。这是 Kubernetes 1.6 版本中引入的特性，尚处在 alpha 阶段。</p><p>cloud-controller-manager 只运行特定于云基础设施供应商的控制器。如果您参考 <a href="http://www.kuboard.cn" target="_blank" rel="noopener">www.kuboard.cn</a> 上提供的文档安装 Kubernetes 集群，默认不安装 cloud-controller-manager。</p><p>cloud-controller-manager 使得云供应商的代码和 Kubernetes 的代码可以各自独立的演化。在此之前的版本中，Kubernetes的核心代码是依赖于云供应商的代码的。在后续的版本中，特定于云供应商的代码将由云供应商自行维护，并在运行Kubernetes时链接到 cloud-controller-manager。</p><p>以下控制器中包含与云供应商相关的依赖：</p><ul><li><p>节点控制器：当某一个节点停止响应时，调用云供应商的接口，以检查该节点的虚拟机是否已经被云供应商删除</p><blockquote><p>译者注：私有化部署Kubernetes时，我们不知道节点的操作系统是否删除，所以在移除节点后，要自行通过 <code>kubectl delete node</code> 将节点对象从 Kubernetes 中删除</p></blockquote></li><li><p>路由控制器：在云供应商的基础设施中设定网络路由</p><blockquote><p>译者注：私有化部署Kubernetes时，需要自行规划Kubernetes的拓扑结构，并做好路由配置，例如 <a href="https://www.kuboard.cn/install/install-k8s.html" target="_blank" rel="noopener">安装Kubernetes单Master节点</a> 中所作的</p></blockquote></li><li><p>服务（Service）控制器：创建、更新、删除云供应商提供的负载均衡器</p><blockquote><p>译者注：私有化部署Kubernetes时，不支持 LoadBalancer 类型的 Service，如需要此特性，需要创建 NodePort 类型的 Service，并自行配置负载均衡器</p></blockquote></li><li><p>数据卷（Volume）控制器：创建、绑定、挂载数据卷，并协调云供应商编排数据卷</p><blockquote><p>译者注：私有化部署Kubernetes时，需要自行创建和管理存储资源，并通过Kubernetes的<a href="https://www.kuboard.cn/learning/k8s-intermediate/persistent/storage-class.html" target="_blank" rel="noopener">存储类</a>、<a href="https://www.kuboard.cn/learning/k8s-intermediate/persistent/pv.html" target="_blank" rel="noopener">存储卷</a>、<a href="https://www.kuboard.cn/learning/k8s-intermediate/persistent/volume.html" target="_blank" rel="noopener">数据卷</a>等与之关联</p></blockquote></li></ul><blockquote><p>译者注：通过 cloud-controller-manager，Kubernetes可以更好地与云供应商结合，例如，在阿里云的 Kubernetes 服务里，您可以在云控制台界面上轻松点击鼠标，即可完成 Kubernetes 集群的创建和管理。在私有化部署环境时，您必须自行处理更多的内容。幸运的是，通过合适的教程指引，这些任务的达成并不困难。</p></blockquote><h3 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件</h3><p>Node 组件运行在每一个节点上（包括 master 节点和 worker 节点），负责维护运行中的 Pod 并提供 Kubernetes 运行时环境。</p><h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h4><p>此组件是运行在每一个集群节点上的代理程序。它确保 Pod 中的容器处于运行状态。Kubelet 通过多种途径获得 PodSpec 定义，并确保 PodSpec 定义中所描述的容器处于运行和健康的状态。Kubelet不管理不是通过 Kubernetes 创建的容器。</p><h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h4><p><a href="https://www.kuboard.cn/learning/k8s-intermediate/service/service-details.html#虚拟-ip-和服务代理" target="_blank" rel="noopener">kube-proxy</a> 是一个网络代理程序，运行在集群中的每一个节点上，是实现 Kubernetes Service 概念的重要部分。</p><p>kube-proxy 在节点上维护网络规则。这些网络规则使得您可以在集群内、集群外正确地与 Pod 进行网络通信。如果操作系统中存在 packet filtering layer，kube-proxy 将使用这一特性（<a href="https://www.kuboard.cn/learning/k8s-intermediate/service/service-details.html#iptables-代理模式" target="_blank" rel="noopener">iptables代理模式</a>），否则，kube-proxy将自行转发网络请求（<a href="https://www.kuboard.cn/learning/k8s-intermediate/service/service-details.html#user-space-代理模式" target="_blank" rel="noopener">User space代理模式</a>）</p><h4 id="容器引擎"><a href="#容器引擎" class="headerlink" title="容器引擎"></a>容器引擎</h4><p>容器引擎负责运行容器。Kubernetes支持多种容器引擎：<a href="http://www.docker.com/" target="_blank" rel="noopener">Docker</a>、<a href="https://containerd.io/" target="_blank" rel="noopener">containerd</a>、<a href="https://cri-o.io/" target="_blank" rel="noopener">cri-o</a>、<a href="https://github.com/kubernetes-incubator/rktlet" target="_blank" rel="noopener">rktlet</a> 以及任何实现了 <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md" target="_blank" rel="noopener">Kubernetes容器引擎接口</a> 的容器引擎</p><h3 id="Addons"><a href="#Addons" class="headerlink" title="Addons"></a>Addons</h3><p>Addons 使用 Kubernetes 资源（DaemonSet、Deployment等）实现集群的功能特性。由于他们提供集群级别的功能特性，addons使用到的Kubernetes资源都放置在 <code>kube-system</code> 名称空间下。</p><p>下面描述了一些经常用到的 addons，参考 <a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">Addons</a> 查看更多列表。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>除了 DNS Addon 以外，其他的 addon 都不是必须的，所有 Kubernetes 集群都应该有 <a href="https://www.kuboard.cn/learning/k8s-intermediate/service/dns.html" target="_blank" rel="noopener">Cluster DNS</a></p><p>Cluster DNS 是一个 DNS 服务器，是对您已有环境中其他 DNS 服务器的一个补充，存放了 Kubernetes Service 的 DNS 记录。</p><p>Kubernetes 启动容器时，自动将该 DNS 服务器加入到容器的 DNS 搜索列表中。</p><blockquote><p>如果您参考 <a href="http://www.kuboard.cn" target="_blank" rel="noopener">www.kuboard.cn</a> 上提供的文档安装 Kubernetes，默认已经安装了 <a href="https://coredns.io/" target="_blank" rel="noopener">Core DNS</a></p></blockquote><h4 id="Web-UI（Dashboard）"><a href="#Web-UI（Dashboard）" class="headerlink" title="Web UI（Dashboard）"></a>Web UI（Dashboard）</h4><p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener">Dashboard</a> 是一个Kubernetes集群的 Web 管理界面。用户可以通过该界面管理集群。</p><h4 id="Kuboard"><a href="#Kuboard" class="headerlink" title="Kuboard"></a>Kuboard</h4><p><a href="https://www.kuboard.cn/install/install-dashboard.html" target="_blank" rel="noopener">Kuboard</a> 是一款基于Kubernetes的微服务管理界面，相较于 Dashboard，Kuboard 强调：</p><ul><li>无需手工编写 YAML 文件</li><li>微服务参考架构</li><li>上下文相关的监控</li><li>场景化的设计<ul><li>导出配置</li><li>导入配置</li></ul></li></ul><h4 id="ContainerResource-Monitoring"><a href="#ContainerResource-Monitoring" class="headerlink" title="ContainerResource Monitoring"></a>ContainerResource Monitoring</h4><p><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/" target="_blank" rel="noopener">Container Resource Monitoring</a> 将容器的度量指标（metrics）记录在时间序列数据库中，并提供了 UI 界面查看这些数据</p><h4 id="Cluster-level-Logging"><a href="#Cluster-level-Logging" class="headerlink" title="Cluster-level Logging"></a>Cluster-level Logging</h4><p><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/" target="_blank" rel="noopener">Cluster-level logging</a> 机制负责将容器的日志存储到一个统一存储中，并提供搜索浏览的界面</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat__05_JVM_排障工具</title>
      <link href="2020/04/02/linux/tomcat/tomcat-05/"/>
      <url>2020/04/02/linux/tomcat/tomcat-05/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="JVM-运维实用排障工具"><a href="#JVM-运维实用排障工具" class="headerlink" title="JVM 运维实用排障工具"></a>JVM 运维实用排障工具</h3><h4 id="1、jps"><a href="#1、jps" class="headerlink" title="1、jps"></a>1、jps</h4><pre><code>用来查看Java进程的具体状态, 包括进程ID，进程启动的路径及启动参数等等，与unix上的ps类似，只不过jps是用来显示java进程，可以把jps理解为ps的一个子集。常用参数如下:-q：忽略输出的类名、Jar名以及传递给main方法的参数，只输出pid-m：输出传递给main方法的参数，如果是内嵌的JVM则输出为null-l：输出完全的包名，应用主类名，jar的完全路径名-v：输出传给jvm的参数注意: 使用jps 时的运行账户要和JVM 虚拟机启动的账户一致。若启动JVM虚拟机是运行的账户为www，那使用jps指令时，也要使用www 用户去指定。 sudo -u www jps</code></pre><p>Example</p><pre class=" language-shell"><code class="language-shell">// 查看已经运行的JVM 进程的实际启动参数[root@mouse03 bin]# jps  -v38372 Jps -Dapplication.home=/usr/local/jdk -Xms8m38360 Bootstrap -Djava.util.logging.config.file=/data0/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Xms4096m -Xmx4096m -XX:PermSize=1024m -XX:MaxPermSize=2048m -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dignore.endorsed.dirs= -Dcatalina.base=/data0/tomcat -Dcatalina.home=/data0/tomcat -Djava.io.tmpdir=/data0/tomcat/temp</code></pre><h4 id="2、jstack"><a href="#2、jstack" class="headerlink" title="2、jstack"></a>2、jstack</h4><pre><code>jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。如果现在运行的java程序呈现hung的状态，jstack是非常有用的。此信息通常在运维的过程中被保存起来(保存故障现场)，以供RD们去分析故障。常用参数如下:jstack &lt;pid&gt;jstack [-l] &lt;pid&gt; //长列表. 打印关于锁的附加信息jstack [-F] &lt;pid&gt; //当’jstack [-l] pid’没有响应的时候强制打印栈信息</code></pre><p>Example</p><pre class=" language-shell"><code class="language-shell">// 打印JVM 的堆栈信息，以供问题排查[root@mouse03 ~]# jstack -F 38360 > /tmp/jstack.log</code></pre><h4 id="3、jinfo"><a href="#3、jinfo" class="headerlink" title="3、jinfo"></a>3、jinfo</h4><pre><code>可以查看或修改运行时的JVM进程的参数。常用参数:jinfo [option] pidwhere &lt;option&gt; is one of:    -flag &lt;name&gt;         to print the value of the named VM flag    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value    -flags               to print VM flags</code></pre><p>Example</p><pre class=" language-shell"><code class="language-shell">// 根据 PID 查看目前分配的最大堆栈[root@mouse03 ~]# jinfo -flag MaxHeapSize 38360-XX:MaxHeapSize=4294967296// 动态更改 JVM 的最大堆栈值[root@mouse03 ~]# jinfo -flag MaxHeapSize=4294967296  38360Exception in thread "main" com.sun.tools.attach.AttachOperationFailedException: flag 'MaxHeapSize' cannot be changed    at sun.tools.attach.LinuxVirtualMachine.execute(LinuxVirtualMachine.java:229)    at sun.tools.attach.HotSpotVirtualMachine.executeCommand(HotSpotVirtualMachine.java:261)    at sun.tools.attach.HotSpotVirtualMachine.setFlag(HotSpotVirtualMachine.java:234)    at sun.tools.jinfo.JInfo.flag(JInfo.java:134)    at sun.tools.jinfo.JInfo.main(JInfo.java:81)// jinfo 并不能动态的改变所有的JVM 参数。 那到底有哪些参数能够被动态的改变呢?// java -XX:+PrintFlagsFinal -version 答应JVM 的所有参数// java -XX:+PrintFlagsFinal -version | grep manageable[root@mouse03 ~]# java -XX:+PrintFlagsFinal -version | grep manageable     intx CMSAbortablePrecleanWaitMillis            = 100                                 {manageable}     intx CMSTriggerInterval                        = -1                                  {manageable}     intx CMSWaitDuration                           = 2000                                {manageable}     bool HeapDumpAfterFullGC                       = false                               {manageable}     bool HeapDumpBeforeFullGC                      = false                               {manageable}     bool HeapDumpOnOutOfMemoryError                = false                               {manageable}    ccstr HeapDumpPath                              =                                     {manageable}    uintx MaxHeapFreeRatio                          = 70                                  {manageable}    uintx MinHeapFreeRatio                          = 40                                  {manageable}     bool PrintClassHistogram                       = false                               {manageable}     bool PrintClassHistogramAfterFullGC            = false                               {manageable}     bool PrintClassHistogramBeforeFullGC           = false                               {manageable}     bool PrintConcurrentLocks                      = false                               {manageable}     bool PrintGC                                   = false                               {manageable}     bool PrintGCDateStamps                         = false                               {manageable}     bool PrintGCDetails                            = false                               {manageable}     bool PrintGCID                                 = false                               {manageable}     bool PrintGCTimeStamps                         = false                               {manageable}// 也只有以上这些值才能够动态的被改变[root@mouse03 ~]# jinfo -flag CMSWaitDuration=1900  38360# 查看， jinfo -flags 查看 JVM 的 flags [root@mouse03 ~]# jinfo -flags 38360Attaching to process ID 38360, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.91-b14Non-default VM flags: -XX:CICompilerCount=2 -XX:CMSWaitDuration=1900 -XX:InitialHeapSize=4294967296 -XX:MaxHeapSize=4294967296 -XX:MaxNewSize=1431633920 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=1431633920 -XX:OldSize=2863333376 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStampsCommand line:  -Djava.util.logging.config.file=/data0/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Xms4096m -Xmx4096m -XX:PermSize=1024m -XX:MaxPermSize=2048m -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dignore.endorsed.dirs= -Dcatalina.base=/data0/tomcat -Dcatalina.home=/data0/tomcat -Djava.io.tmpdir=/data0/tomcat/temp</code></pre><h4 id="4、jstat"><a href="#4、jstat" class="headerlink" title="4、jstat"></a>4、jstat</h4><pre class=" language-shell"><code class="language-shell">// 监控JVM 的状态，常用指令:# jstat -gc 113059 1000 10 // 打印PID 为 113059 JVM 状态，一共打印10次，每次间隔时间为1s(1000ms)// 注 jstat 的用法超级强大， 我们这里只是列举出列其中一个简单的应用。</code></pre><p>Example</p><pre class=" language-shell"><code class="language-shell"># jstat -gc 113059 1000 10 S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT195904.0 195904.0  0.0   21610.3 1567680.0 1516721.9 8526272.0  3557507.8  1048576.0 163148.4   2577   92.033   0      0.000   92.033195904.0 195904.0 23600.9  0.0   1567680.0 142541.6 8526272.0  3558435.8  1048576.0 163148.4   2578   92.060   0      0.000   92.060195904.0 195904.0 23600.9  0.0   1567680.0 266338.1 8526272.0  3558435.8  1048576.0 163148.4   2578   92.060   0      0.000   92.060195904.0 195904.0 23600.9  0.0   1567680.0 413941.8 8526272.0  3558435.8  1048576.0 163148.4   2578   92.060   0      0.000   92.060195904.0 195904.0 23600.9  0.0   1567680.0 642390.6 8526272.0  3558435.8  1048576.0 163148.4   2578   92.060   0      0.000   92.060195904.0 195904.0 23600.9  0.0   1567680.0 813957.3 8526272.0  3558435.8  1048576.0 163148.4   2578   92.060   0      0.000   92.060195904.0 195904.0 23600.9  0.0   1567680.0 984223.2 8526272.0  3558435.8  1048576.0 163148.4   2578   92.060   0      0.000   92.060195904.0 195904.0 23600.9  0.0   1567680.0 1155472.7 8526272.0  3558435.8  1048576.0 163148.4   2578   92.060   0      0.000   92.060195904.0 195904.0 23600.9  0.0   1567680.0 1399228.5 8526272.0  3558435.8  1048576.0 163148.4   2578   92.060   0      0.000   92.060195904.0 195904.0  0.0   23866.6 1567680.0 38005.6  8526272.0  3559196.7  1048576.0 163148.4   2579   92.092   0      0.000   92.092</code></pre><p><strong>字段意义如下</strong></p><table><thead><tr><th>列名</th><th>说明</th></tr></thead><tbody><tr><td>S0C</td><td>新生代中Survivor space中S0当前容量的大小（KB）</td></tr><tr><td>S1C</td><td>新生代中Survivor space中S1当前容量的大小（KB）</td></tr><tr><td>S0U</td><td>新生代中Survivor space中S0容量使用的大小（KB）</td></tr><tr><td>S1U</td><td>新生代中Survivor space中S1容量使用的大小（KB）</td></tr><tr><td>EC</td><td>Eden space当前容量的大小（KB）</td></tr><tr><td>EU</td><td>Eden space容量使用的大小（KB）</td></tr><tr><td>OC</td><td>Old space当前容量的大小（KB）</td></tr><tr><td>OU</td><td>Old space使用容量的大小（KB）</td></tr><tr><td>PC</td><td>Permanent space当前容量的大小（KB）</td></tr><tr><td>PU</td><td>Permanent space使用容量的大小（KB）</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时 Young GC 所用的时间(秒)</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(秒)</td></tr><tr><td>GCT</td><td>T从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr></tbody></table><h4 id="5、jvmtop"><a href="#5、jvmtop" class="headerlink" title="5、jvmtop"></a>5、jvmtop</h4><pre><code>以上介绍的jps、jstack、jinfo等都是安装JDK 时自带的系统分析工具，而jvmtop是一款开源的JVM工具。它的下载地址如下: https://github.com/patric-r/jvmtop顾名思义，它是一个只针对JVM的工具，展示的方式和unix的top命令相似.jvmtop 提供了两个视图，一个是概览视图，可以展示出当前机器的所有的 JVM 的情况. 还有一个视图是详情视图，展示一个 JVM 的详细情况.</code></pre><p><strong>概览视图</strong></p><pre><code>jvmtop.sh</code></pre><p><img src="https://s1.ax1x.com/2020/05/21/YHC9BV.png" alt="YHC9BV.png"></p><pre><code>其中，各个字段的意义分别如下：PID：进程 IDMAIN-CLASS：main 类的名字HPCUR：当前被使用的 heap 的大小HPMAX：最大可用的 heap 的大小NHCUR：当前被使用的非 heap 大小（比如：perm gen）NHMAX：最大可用的非 heap 大小CPU：CPU 的使用情况GC：消耗在 GC 上的时间比例VM：JVM 的提供者，大版本号，小版本号，图中的意思是 Apple 提供的 JDK 6U51 版本。USERNAME：当前的用户名#T：线程数量DL：是否有现成发生死锁</code></pre><p><strong>详情视图</strong></p><pre><code>jvmtop.sh &lt;pid&gt;</code></pre><p><img src="https://s1.ax1x.com/2020/05/21/YHCiAU.png" alt="YHCiAU.png"></p><pre><code>其中，各个字段的意义如下：TID：线程 IDNAME：线程名STATE：线程状态CPU：线程当前的 CPU 占用情况TOTALCPU：从线程被创建开始总体的 CPU 占用情况BLOCKBY：阻塞这个线程的线程 ID</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat_04_安全优化</title>
      <link href="2020/03/30/linux/tomcat/tomcat-04/"/>
      <url>2020/03/30/linux/tomcat/tomcat-04/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="10、Tomcat安全优化"><a href="#10、Tomcat安全优化" class="headerlink" title="10、Tomcat安全优化"></a>10、Tomcat安全优化</h4><h5 id="1、telnet管理端口保护（强制）"><a href="#1、telnet管理端口保护（强制）" class="headerlink" title="1、telnet管理端口保护（强制）"></a>1、telnet管理端口保护（强制）</h5><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>telnet管理端口保护</td><td>1.修改默认的8005管理端口为不易猜测的端口（大于1024）；2.修改SHUTDOWN指令为其他字符串；</td><td><Server port="**8527**" shutdown="**dangerous**"></td><td>1.以上配置项的配置内容只是建议配置，可以按照服务实际情况进行合理配置，但要求端口配置在<strong>8000~8999</strong>之间；</td></tr></tbody></table><h5 id="2、-ajp连接端口保护（推荐）"><a href="#2、-ajp连接端口保护（推荐）" class="headerlink" title="2、 ajp连接端口保护（推荐）"></a>2、 ajp连接端口保护（推荐）</h5><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>Ajp 连接端口保护</td><td>1.修改默认的ajp 8009端口为不易冲突的大于1024端口；2.通过iptables规则限制ajp端口访问的权限仅为线上机器；</td><td>&lt;Connector port=”<strong>8528</strong>“protocol=”AJP/1.3” /&gt;</td><td>以上配置项的配置内容仅为建议配置，请按照服务实际情况进行合理配置，但要求端口配置在<strong>8000~8999</strong>之间；；保护此端口的目的在于防止线下的测试流量被mod_jk转发至线上tomcat服务器；</td></tr></tbody></table><h5 id="3、禁用管理端（强制）"><a href="#3、禁用管理端（强制）" class="headerlink" title="3、禁用管理端（强制）"></a>3、禁用管理端（强制）</h5><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>禁用管理端</td><td>1. 删除默认的{Tomcat安装目录}/conf/tomcat-users.xml文件，重启tomcat后将会自动生成新的文件；2. 删除{Tomcat安装目录}/webapps下默认的所有目录和文件；3.将tomcat 应用根目录配置为tomcat安装目录以外的目录；</td><td>&lt;Context path=”” docBase=”<strong>/home/work/local/tomcat**</strong>_webapps**”debug=”0”reloadable=”false”crossContext=”true”/&gt;</td><td>对于前段web模块，Tomcat管理端属于tomcat的高危安全隐患，一旦被攻破，黑客通过上传web shell的方式将会直接取得服务器的控制权，后果极其严重；</td></tr></tbody></table><h5 id="4、降权启动（强制）"><a href="#4、降权启动（强制）" class="headerlink" title="4、降权启动（强制）"></a>4、降权启动（强制）</h5><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>降权启动</td><td>1.tomcat启动用户权限必须为非root权限，尽量降低tomcat启动用户的目录访问权限；2.如需直接对外使用80端口，可通过普通账号启动后，配置iptables规则进行转发；</td><td></td><td>避免一旦tomcat 服务被入侵，黑客直接获取高级用户权限危害整个server的安全；</td></tr></tbody></table><pre><code>[root@web03 ~]# useradd tomcat[root@web03 ~]# cp -a /application/tools/tomcat8_1 /home/tomcat/[root@web03 ~]# chown -R tomcat.tomcat /home/tomcat/tomcat8_1/[root@web03 ~]# su -c &#39;/home/tomcat/tomcat8_1/bin/startup.sh&#39; tomcatUsing CATALINA_BASE:   /home/tomcat/tomcat8_1Using CATALINA_HOME:   /home/tomcat/tomcat8_1Using CATALINA_TMPDIR: /home/tomcat/tomcat8_1/tempUsing JRE_HOME:        /application/jdkUsing CLASSPATH:       /home/tomcat/tomcat8_1/bin/bootstrap.jar:/home/tomcat/tomcat8_1/bin/tomcat-juli.jarTomcat started.[root@web03 ~]# ps -ef|grep tomcat</code></pre><h5 id="5、文件列表访问控制（强制）"><a href="#5、文件列表访问控制（强制）" class="headerlink" title="5、文件列表访问控制（强制）"></a>5、文件列表访问控制（强制）</h5><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>文件列表访问控制</td><td>1.conf/web.xml文件中default部分listings的配置必须为false；</td><td><init-param><param-name><strong>listings</strong></param-name><param-value><strong>false</strong></param-value></init-param></td><td>false为不列出目录文件，true为允许列出，默认为false；</td></tr></tbody></table><h5 id="6、版本信息隐藏（强制）"><a href="#6、版本信息隐藏（强制）" class="headerlink" title="6、版本信息隐藏（强制）"></a>6、版本信息隐藏（强制）</h5><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>版本信息隐藏</td><td>1.修改conf/web.xml，重定向403、404以及500等错误到指定的错误页面；2.也可以通过修改应用程序目录下的WEB-INF/web.xml下的配置进行错误页面的重定向；</td><td><error-page><error-code><strong>403</strong></error-code><location><strong>/forbidden.jsp</strong></location></error-page><error-page><error-code><strong>404</strong></error-code><location><strong>/notfound.jsp</strong></location></error-page><error-page><error-code><strong>500</strong></error-code><location><strong>/systembusy.jsp</strong></location></error-page></td><td>在配置中对一些常见错误进行重定向，避免当出现错误时tomcat默认显示的错误页面暴露服务器和版本信息；必须确保程序根目录下的错误页面已经存在；</td></tr></tbody></table><h5 id="7、Server-header重写（推荐）"><a href="#7、Server-header重写（推荐）" class="headerlink" title="7、Server header重写（推荐）"></a>7、Server header重写（推荐）</h5><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>Server header重写</td><td>在HTTP Connector配置中加入server的配置；</td><td>server=”<strong>webserver</strong>“</td><td>当tomcat HTTP端口直接提供web服务时此配置生效，加入此配置，将会替换http 响应Server header部分的默认配置，默认是<code>Apache-Coyote/1.1</code></td></tr></tbody></table><h5 id="8、访问限制（可选）"><a href="#8、访问限制（可选）" class="headerlink" title="8、访问限制（可选）"></a>8、访问限制（可选）</h5><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置或操作</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>访问限制</td><td>通过配置，限定访问的ip来源</td><td><Context path="" docBase="/home/work/tomcat" debug="0" reloadable="false" crossContext="true">&lt;Valve className=”org.apache.catalina.valves.RemoteAddrValve” <strong>allow=”61.148.18.138,61.135.165.*“ deny=”*.*.*.*“</strong>/&gt;</Context></td><td>通过配置信任ip的白名单，拒绝非白名单ip的访问，此配置主要是针对高保密级别的系统，一般产品线不需要；</td></tr></tbody></table><h5 id="9、起停脚本权限回收（推荐）"><a href="#9、起停脚本权限回收（推荐）" class="headerlink" title="9、起停脚本权限回收（推荐）"></a>9、起停脚本权限回收（推荐）</h5><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置或操作</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>起停脚本权限回收</td><td>去除其他用户对Tomcat的bin目录下shutdown.sh、startup.sh、catalina.sh的可执行权限；</td><td>chmod -R 744 tomcat/bin/*</td><td>防止其他用户有起停线上Tomcat的权限；</td></tr></tbody></table><h5 id="10、-访问日志格式规范（推荐）"><a href="#10、-访问日志格式规范（推荐）" class="headerlink" title="10、 访问日志格式规范（推荐）"></a>10、 访问日志格式规范（推荐）</h5><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置或操作</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>访问日志格式规范</td><td>开启Tomcat默认访问日志中的Referer和User-Agent记录</td><td><Valve className="org.apache.catalina.valves.AccessLogValve"                 directory="logs"  prefix="localhost_access_log." suffix=".txt"                 pattern="%h %l %u %t %r %s %b %{Referer}i %{User-Agent}i %D" resolveHosts="false"/></td><td>开启Referer和User-Agent是为了一旦出现安全问题能够更好的根据日志进行问题排查；</td></tr></tbody></table><h5 id="11、-附录：建议配置及标准执行方案"><a href="#11、-附录：建议配置及标准执行方案" class="headerlink" title="11、 附录：建议配置及标准执行方案"></a>11、 附录：建议配置及标准执行方案</h5><p><strong>1.</strong>       <strong>配置部分（**</strong>${ CATALINA_HOME }conf/server.xml<strong>**）</strong></p><pre><code>&lt;Server port=&quot;8527&quot; shutdown=&quot; dangerous&quot;&gt;&lt;!-- Define a non-SSL HTTP/1.1 Connector on port 8080 --&gt;&lt;Connector port=&quot;8080&quot; server=&quot;webserver&quot;/&gt; &lt;!-- Define an AJP 1.3 Connector on port 8528 --&gt;&lt;!--Define an accesslog --&gt; &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot;                 directory=&quot;logs&quot;  prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot;                 pattern=&quot;%h %l %u %t %r %s %b %{Referer}i %{User-Agent}i %D&quot; resolveHosts=&quot;false&quot;/&gt;    &lt;Connector port=&quot;8528&quot; protocol=&quot;AJP/1.3&quot; /&gt;&lt;Context path=&quot;&quot; docBase=&quot;/home/work/local/tomcat_webapps&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; crossContext=&quot;true&quot;/&gt;</code></pre><p><strong>2.</strong>       <strong>配置部分（**</strong>${ CATALINA_HOME }conf/web.xml<strong><strong>或者</strong></strong>WEB-INF/web.xml<strong>**）</strong></p><pre><code>&lt;init-param&gt;    &lt;param-name&gt;listings&lt;/param-name&gt;    &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;&lt;error-page&gt;    &lt;error-code&gt;403&lt;/error-code&gt;    &lt;location&gt;/forbidden.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;    &lt;error-code&gt;404&lt;/error-code&gt;    &lt;location&gt;/notfound.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;    &lt;error-code&gt;500&lt;/error-code&gt;    &lt;location&gt;/systembusy.jsp&lt;/location&gt;&lt;/error-page&gt;</code></pre><p><strong>3.</strong>       <strong>删除如下**</strong>tomcat<strong>**的默认目录和默认文件</strong></p><pre><code>tomcat/webapps/*tomcat/conf/tomcat-user.xml</code></pre><p><strong>4.</strong>       <strong>去除其他用户对**</strong>tomcat** <strong>起停脚本的执行权限</strong></p><pre><code>chmod 744 –R tomcat/bin/*</code></pre><h4 id="11、Tomcat性能优化"><a href="#11、Tomcat性能优化" class="headerlink" title="11、Tomcat性能优化"></a>11、Tomcat性能优化</h4><p>tomcat性能取决于 内存大小</p><p><strong>上策：优化代码</strong></p><p>   该项需要开发经验足够丰富，对开发人员要求较高</p><p><strong>中策：jvm**</strong>优化机制** <strong>垃圾回收机制</strong> <strong>把不需要的内存回收</strong></p><p>​                  优化jvm–优化垃圾回收策略</p><p>优化catalina.sh配置文件。在catalina.sh配置文件中添加以下代码</p><pre><code># tomcat分配1G内存模板JAVA_OPTS=&quot;-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=512m -XX:PermSize=512m -XX:MaxPermSize=512m&quot;        JAVA_OPTS=&quot;-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms800m -Xmx800m -XX:NewSize=400m -XX:MaxNewSize=400m -XX:PermSize=400m -XX:MaxPermSize=400m&quot;    # 重启服务su -c &#39;/home/tomcat/tomcat8_1/bin/shutdown.sh&#39; tomcatsu -c &#39;/home/tomcat/tomcat8_1/bin/startup.sh&#39; tomcat</code></pre><p>​         <strong>修改之前</strong></p><p><img src="https://s1.ax1x.com/2020/05/21/YHitTf.png" alt="YHitTf.png"></p><p>​         <strong>修改之后</strong></p><p><img src="https://s1.ax1x.com/2020/05/21/YHiUk8.png" alt="YHiUk8.png"></p><p><strong>下策：加足够大的内存</strong></p><p>该项的资金投入较大</p><p><strong>下下策：每天0**</strong>点定时重启tomcat**</p><p>使用较为广泛</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes常用命令</title>
      <link href="2020/03/29/rong-qi/kubernetes-chang-yong-ming-ling/"/>
      <url>2020/03/29/rong-qi/kubernetes-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="Kubernetes-Cheat-Sheet"><a href="#Kubernetes-Cheat-Sheet" class="headerlink" title="Kubernetes Cheat Sheet"></a>Kubernetes Cheat Sheet</h5><p>Viewing Resource Information     //查看资源信息</p><h5 id="Nodes"><a href="#Nodes" class="headerlink" title="Nodes"></a>Nodes</h5><pre><code>$ kubectl get no$ kubectl get no -o wide$ kubectl describe no$ kubectl get no - o yaml$ kubectl get node - - sel ect or =[ l abel _name]$ kubectl get nodes -o jsonpath=&#39; {.items[*].status.addresses [?(@.type==&quot;ExternalIP&quot;)].address}&#39;$ kubectl top node [node_name]</code></pre><h5 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h5><pre><code>$ kubectl get po -o wide$ kubectl describe po$ kubectl get po$ kubectl get po --show-labels$ kubectl get po -l app=nginx$ kubectl get po -o yaml$ kubectl get pod [pod_name] - o yaml --export$ kubect l get pod [ pod_name] - o yaml --export &gt; nameoffile.yaml$ kubectl get pods -- field-selector status.phase=Running</code></pre><h5 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h5><pre><code>$ kubectl get ns$ kubectl get ns - o yaml$ kubectl describe ns</code></pre><h5 id="Deployments"><a href="#Deployments" class="headerlink" title="Deployments"></a>Deployments</h5><pre><code>$ kubectl get deploy$ kubectl describe deploy$ kubectl get deploy - o wide$ kubectl get deploy - o yaml</code></pre><h5 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h5><pre><code>$ kubectl get svc$ kubectl describe svc$ kubectl get svc - o wide$ kubectl get svc - o yaml$ kubectl get svc --show-labels</code></pre><h5 id="DaemonSets"><a href="#DaemonSets" class="headerlink" title="DaemonSets"></a>DaemonSets</h5><pre><code>$ kubectl get ds$ kubectl get ds --all-namespaces$ kubectl describe ds [daemonset_name] - n [namespce_name]$ kubectl get ds [ds_name] -n [ns_name] -o yaml</code></pre><h5 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h5><pre><code>$ kubectl get events$ kubectl get events -n kube-system$ kubectl get events -w</code></pre><h5 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h5><pre><code>$ kubectl logs [pod_name]$ kubectl logs --since=1h [pod_name]$ kubectl logs --tail =20 [pod_name]$ kubectl logs -f -c [container_name] [pod_name]$ kubectl logs [pod_name] &gt; pod.log</code></pre><h5 id="Service-Accounts"><a href="#Service-Accounts" class="headerlink" title="Service Accounts"></a>Service Accounts</h5><pre><code>$ kubectl get sa$ kubectl get sa -o yaml$ kubectl get serviceaccounts default -o yaml &gt;./sa.yaml$ kubectl replace serviceaccount default -f ./sa.yaml</code></pre><h5 id="ReplicaSets"><a href="#ReplicaSets" class="headerlink" title="ReplicaSets"></a>ReplicaSets</h5><pre><code>$ kubectl get rs$ kubectl describe rs$ kubectl get rs -o wide$ kubectl get rs -o yaml</code></pre><h5 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h5><pre><code>$ kubectl get roles --all -namespaces$ kubectl get roles --all -namespaces -o yaml</code></pre><h5 id="Secrets"><a href="#Secrets" class="headerlink" title="Secrets"></a>Secrets</h5><pre><code>$ kubectl get secrets$ kubectl get secrets --all -namespaces$ kubectl get secrets -o yaml</code></pre><h5 id="ConfigMaps"><a href="#ConfigMaps" class="headerlink" title="ConfigMaps"></a>ConfigMaps</h5><pre><code>$ kubectl get cm$ kubectl get cm --all-namespaces$ kubectl get cm --all-namespaces -o yaml</code></pre><h5 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h5><pre><code>$ kubectl get ing$ kubectl get ing --all-namespaces</code></pre><h5 id="PersistentVolume"><a href="#PersistentVolume" class="headerlink" title="PersistentVolume"></a>PersistentVolume</h5><pre><code>$ kubectl get pv$ kubectl describe pv</code></pre><h5 id="PersistentVolumeClaim"><a href="#PersistentVolumeClaim" class="headerlink" title="PersistentVolumeClaim"></a>PersistentVolumeClaim</h5><pre><code>$ kubectl get pvc$ kubectl describe pvc</code></pre><h5 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h5><pre><code>$ kubectl get sc$ kubectl get sc -o yaml</code></pre><h5 id="Multiple-Resources"><a href="#Multiple-Resources" class="headerlink" title="Multiple Resources"></a>Multiple Resources</h5><pre><code>$ kubectl get svc,po$ kubectl get deploy,no$ kubectl get all$ kubectl get all --all -namespaces</code></pre><p>Changing Resource Attributes  //改变资源属性</p><h5 id="Taint"><a href="#Taint" class="headerlink" title="Taint"></a>Taint</h5><pre><code>$ kubectl taint [node_name] [taint_name] </code></pre><h5 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h5><pre><code>$ kubectl label [node_name] disktype=ssd$ kubectl label [pod_name] env=prod</code></pre><h5 id="Cordon-Uncordon"><a href="#Cordon-Uncordon" class="headerlink" title="Cordon/Uncordon"></a>Cordon/Uncordon</h5><pre><code>$ kubectl cordon [node_name]$ kunectl uncordon [node_name]</code></pre><h5 id="Drain"><a href="#Drain" class="headerlink" title="Drain"></a>Drain</h5><pre><code>$ kubectl drain [node_name]</code></pre><h5 id="Nodes-Pods"><a href="#Nodes-Pods" class="headerlink" title="Nodes/Pods"></a>Nodes/Pods</h5><pre><code>$ kubectl delet enode [node_name]$ kubectl delet epod [pod_name]$ kubectl edit node [node_name]$ kubectl edit pod [pod_name] </code></pre><h5 id="Deployments-Namespaces"><a href="#Deployments-Namespaces" class="headerlink" title="Deployments/Namespaces"></a>Deployments/Namespaces</h5><pre><code>$ kubectl edit deploy [deploy_name]$ kubectl delete deploy [deploy_name]$ kubectl expse deploy [deploy_name] --por=80  -type=NodePort$ kubectl scale deploy [deploy_name] --repicas=5$ kubectl delete ns $ kubectl edit ns [ns_name]</code></pre><h5 id="Services-1"><a href="#Services-1" class="headerlink" title="Services"></a>Services</h5><pre><code>$ kubectl edit svc [svc_name]$ kubectl delete svc [svc_name]</code></pre><h5 id="DaemonSets-1"><a href="#DaemonSets-1" class="headerlink" title="DaemonSets"></a>DaemonSets</h5><pre><code>$ kubectl edit ds [ds_name] -n kube-system$ kubectl delete ds [ds_name]</code></pre><h5 id="Service-Accounts-1"><a href="#Service-Accounts-1" class="headerlink" title="Service Accounts"></a>Service Accounts</h5><pre><code>$ kubectl edit sa [sa_name]$ kubectl delete sa [sa_name]</code></pre><h5 id="Annotate"><a href="#Annotate" class="headerlink" title="Annotate"></a>Annotate</h5><pre><code>$ kubectl annotate po [pod_name] [annotation]$ kubectl annotate no [node_name]</code></pre><p>Adding Resources    //添加资源</p><h5 id="Creating-a-Pod"><a href="#Creating-a-Pod" class="headerlink" title="Creating a Pod"></a>Creating a Pod</h5><pre><code>$ kubectl create -f [name_of_file]$ kubectl apply -f [name_of_file]$ kubectl run [pod_name] --image=nginx --resart=Never$ kubectl run [pod_name] --geneator=run-pod/v1 --image=nginx$ kubectl run [pod_name] --image=nginx --restart=Never</code></pre><h5 id="Creating-a-Service"><a href="#Creating-a-Service" class="headerlink" title="Creating a Service"></a>Creating a Service</h5><pre><code>$ kubectl create svc nodeport [svc_name] --tcp=8080: 80</code></pre><h5 id="Creating-a-Deployment"><a href="#Creating-a-Deployment" class="headerlink" title="Creating a Deployment"></a>Creating a Deployment</h5><pre><code>$ kubectl create -f [name_of_file]$ kubectl apply -f [name_of_file]$ kubectl create deploy [deploy_name] --image=ngi nx</code></pre><h5 id="Interactive-Pod"><a href="#Interactive-Pod" class="headerlink" title="Interactive Pod"></a>Interactive Pod</h5><pre><code>$ kubectl run [pod_name] --image=busybox --rm -it --restart=Never -- sh</code></pre><h5 id="Output-YAML-to-a-File"><a href="#Output-YAML-to-a-File" class="headerlink" title="Output YAML to a File"></a>Output YAML to a File</h5><pre><code>$ kubectl create deploy [deploy_name] --image=nginx --dry-run -o yaml &gt; depl oy. yaml$ kubectl get po [pod_name] -o yaml --export &gt; pod. yaml</code></pre><h5 id="Getting-Help"><a href="#Getting-Help" class="headerlink" title="Getting Help"></a>Getting Help</h5><pre><code>$ kubectl -h $ kubectl create -h$ kubectl run -h$ kubectl explain deploy.spec</code></pre><p>Requests    //请求</p><h5 id="API-Call"><a href="#API-Call" class="headerlink" title="API Call"></a>API Call</h5><pre><code>$ kubectl get --raw /apis/metrics.k8s.io/</code></pre><h5 id="Cluster-Info"><a href="#Cluster-Info" class="headerlink" title="Cluster Info"></a>Cluster Info</h5><pre><code>$ kubectl config $ kubectl cluster-info$ kubectl get componentstatuses</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat_03_监控</title>
      <link href="2020/03/27/linux/tomcat/tomcat-03/"/>
      <url>2020/03/27/linux/tomcat/tomcat-03/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="9、监控tomcat集群状态"><a href="#9、监控tomcat集群状态" class="headerlink" title="9、监控tomcat集群状态"></a>9、监控tomcat集群状态</h4><h5 id="1、方法一：开发java监控页面"><a href="#1、方法一：开发java监控页面" class="headerlink" title="1、方法一：开发java监控页面"></a>1、方法一：开发java监控页面</h5><pre><code>[root@web03 tomcat8_1]# cat /application/tomcat/webapps/memtest/meminfo.jsp &lt;%Runtime rtm = Runtime.getRuntime();long mm = rtm.maxMemory()/1024/1024;long tm = rtm.totalMemory()/1024/1024;long fm = rtm.freeMemory()/1024/1024;out.println(&quot;JVM memory detail info :&lt;br&gt;&quot;);out.println(&quot;Max memory:&quot;+mm+&quot;MB&quot;+&quot;&lt;br&gt;&quot;);out.println(&quot;Total memory:&quot;+tm+&quot;MB&quot;+&quot;&lt;br&gt;&quot;);out.println(&quot;Free memory:&quot;+fm+&quot;MB&quot;+&quot;&lt;br&gt;&quot;);out.println(&quot;Available memory can be used is :&quot;+(mm+fm-tm)+&quot;MB&quot;+&quot;&lt;br&gt;&quot;);%&gt;</code></pre><h5 id="2、方法二：使用jps命令进行监控"><a href="#2、方法二：使用jps命令进行监控" class="headerlink" title="2、方法二：使用jps命令进行监控"></a>2、方法二：使用jps命令进行监控</h5><pre><code>[root@web03 ~]# jps -lvm31906 org.apache.catalina.startup.Bootstrap start -Djava.util.logging.config.file=/application/tomcat8_1/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.endorsed.dirs=/application/tomcat8_1/endorsed -Dcatalina.base=/application/tomcat8_1 -Dcatalina.home=/application/tomcat8_1 -Djava.io.tmpdir=/application/tomcat8_1/temp31812 org.apache.catalina.startup.Bootstrap start -Djava.util.logging.config.file=/application/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.endorsed.dirs=/application/tomcat/endorsed -Dcatalina.base=/application/tomcat -Dcatalina.home=/application/tomcat -Djava.io.tmpdir=/application/tomcat/temp31932 org.apache.catalina.startup.Bootstrap start -Djava.util.logging.config.file=/application/tomcat8_2/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.endorsed.dirs=/application/tomcat8_2/endorsed -Dcatalina.base=/application/tomcat8_2 -Dcatalina.home=/application/tomcat8_2 -Djava.io.tmpdir=/application/tomcat8_2/temp32079 sun.tools.jps.Jps -lvm -Denv.class.path=.:/application/jdk/lib:/application/jdk/jre/lib:/application/jdk/lib/tools.jar -Dapplication.home=/application/jdk1.8.0_60 -Xms8m</code></pre><h5 id="3、Tomcat远程监控功能"><a href="#3、Tomcat远程监控功能" class="headerlink" title="3、Tomcat远程监控功能"></a>3、Tomcat远程监控功能</h5><p>修改配置文件，开启远程监控</p><pre><code>vim /application/tomcat8_1/bin/catalina.sh +97CATALINA_OPTS=&quot;$CATALINA_OPTS-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=12345  -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=10.0.0.17&quot;</code></pre><p>​         重启服务，检查12345端口是否开启</p><pre><code>/application/tomcat8_1/bin/shutdown.sh /application/tomcat8_1/bin/startup.sh netstat -tunlp|grep 12345</code></pre><p>​         检查端口</p><pre><code>[root@web03 ~]# netstat -tunlp|grep 12345tcp6       0      0 :::12345           :::*          LISTEN      33158/java  </code></pre><p><strong>在windows**</strong>上监控tomcat**</p><p><strong>注意：windwos**</strong>需要安装jdk<strong>**环境！</strong></p><p>查考：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><h5 id="4、zabbix监控tomcat程序"><a href="#4、zabbix监控tomcat程序" class="headerlink" title="4、zabbix监控tomcat程序"></a>4、zabbix监控tomcat程序</h5><p>zabbix搭建详情参考：<em><a href="https://www.toutiao.com/i6808897883299906059/" target="_blank" rel="noopener">https://www.toutiao.com/i6808897883299906059/</a></em></p><p>若是有问题，请移步官网 ： <em><a href="https://www.zabbix.com/documentation/4.0/zh/manual/installation" target="_blank" rel="noopener">https://www.zabbix.com/documentation/4.0/zh/manual/installation</a></em></p><p><strong>服务端安装配置java**</strong>监控服务**</p><pre><code>[root@m01 ~]# yum install zabbix-java-gateway -y</code></pre><p><strong>查看配置文件</strong></p><pre><code>配置文件路径：/etc/zabbix/zabbix_java_gateway.confsed -i -e &#39;220a JavaGateway=127.0.0.1&#39; -e &#39;236a StartJavaPollers=5&#39;  /etc/zabbix/zabbix_server.conf</code></pre><p>启动zabbix-java-gateway服务，与zabbix服务</p><pre><code>systemctl start zabbix-java-gateway.servicesystemctl restart zabbix-server.service</code></pre><p>检查java端口是否开启</p><pre><code>[root@m01 ~]# netstat -lntup |grep javatcp6       0      0 :::10052   :::*    LISTEN      72971/java  </code></pre><p>​         检查java进程是否存在</p><pre><code>[root@m01 ~]# ps -ef |grep [j]avazabbix    72971      1  0 11:29 ?        00:00:00 java -server -Dlogback.configurationFile=/etc/zabbix/zabbix_java_gateway_logback.xml -classpath lib:lib/android-json-4.3_r3.1.jar:lib/logback-classic-0.9.27.jar:lib/logback-core-0.9.27.jar:lib/slf4j-api-1.6.1.jar:bin/zabbix-java-gateway-3.0.13.jar -Dzabbix.pidFile=/var/run/zabbix/zabbix_java.pid -Dzabbix.timeout=3 -Dsun.rmi.transport.tcp.responseTimeout=3000 com.zabbix.gateway.JavaGatewayzabbix    73255  73226  0 11:35 ?        00:00:00 /usr/sbin/zabbix_server: java poller #1 [got 0 values in 0.000002 sec, idle 5 sec]zabbix    73256  73226  0 11:35 ?        00:00:00 /usr/sbin/zabbix_server: java poller #2 [got 0 values in 0.000002 sec, idle 5 sec]zabbix    73257  73226  0 11:35 ?        00:00:00 /usr/sbin/zabbix_server: java poller #3 [got 0 values in 0.000002 sec, idle 5 sec]zabbix    73258  73226  0 11:35 ?        00:00:00 /usr/sbin/zabbix_server: java poller #4 [got 0 values in 0.000002 sec, idle 5 sec]zabbix    73259  73226  0 11:35 ?        00:00:00 /usr/sbin/zabbix_server: java poller #5 [got 0 values in 0.000004 sec, idle 5 sec]</code></pre><p><strong>web**</strong>界面添加**</p><p>​         添加主机</p><p><img src="https://s1.ax1x.com/2020/05/21/YHilSH.png" alt="YHilSH.png"> </p><p>​         主机管理模板，注意是JMX模板</p><p><img src="https://s1.ax1x.com/2020/05/21/YHi36A.png" alt="YHi36A.png">         监控完成</p><p><img src="https://s1.ax1x.com/2020/05/21/YHi8OI.png" alt="YHi8OI.png"> </p><h5 id="5、排除tomcat故障步骤"><a href="#5、排除tomcat故障步骤" class="headerlink" title="5、排除tomcat故障步骤"></a>5、排除tomcat故障步骤</h5><p>a. 查看catalina.out</p><p>b. 使用sh show-busy-java-threads.sh脚本进行检测</p><p>脚本下载地址</p><p><em><a href="https://files.cnblogs.com/files/clsn/show-busy-java-threads.sh" target="_blank" rel="noopener">https://files.cnblogs.com/files/clsn/show-busy-java-threads.sh</a></em></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat_02_应用部署</title>
      <link href="2020/03/25/linux/tomcat/tomcat-02/"/>
      <url>2020/03/25/linux/tomcat/tomcat-02/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="6、WEB站点部署"><a href="#6、WEB站点部署" class="headerlink" title="6、WEB站点部署"></a>6、WEB站点部署</h4><p>上线的代码有两种方式：</p><p>第一种方式是直接将程序目录放在webapps目录下面，这种方式大家已经明白了，就不多说了。</p><p>第二种方式是使用开发工具将程序打包成war包，然后上传到webapps目录下面。</p><h5 id="1、使用war包部署web站点"><a href="#1、使用war包部署web站点" class="headerlink" title="1、使用war包部署web站点"></a>1、使用war包部署web站点</h5><pre><code>[root@web03 webapps]# pwd/application/tomcat/webapps[root@web03 webapps]# wget http://10.0.0.1/apache/tomcat/memtest.war</code></pre><p>站点主动解压部署</p><pre><code>[root@web03 webapps]# lsdocs  examples  host-manager  logs  manager  memtest  memtest.war  ROOT</code></pre><p>浏览器访问：</p><p><em><a href="http://10.0.0.17:8080//memtest/meminfo.jsp" target="_blank" rel="noopener">http://10.0.0.17:8080//memtest/meminfo.jsp</a></em></p><p><img src="https://s1.ax1x.com/2020/05/21/YHPrdK.png" alt="YHPrdK.png"></p><h5 id="2、自定义默认网站目录"><a href="#2、自定义默认网站目录" class="headerlink" title="2、自定义默认网站目录"></a>2、自定义默认网站目录</h5><p>上面访问的网址为 <em><a href="http://10.0.0.3:8080/memtest/meminfo.jsp" target="_blank" rel="noopener">http://10.0.0.3:8080/memtest/meminfo.jsp</a></em></p><p>现在想访问格式为<em><a href="http://10.0.0.3:8080/meminfo.jsp" target="_blank" rel="noopener">http://10.0.0.3:8080/meminfo.jsp</a></em></p><p><strong>方法一</strong></p><p>将meminfo.jsp或其他程序放在tomcat/webapps/ROOT目录下即可。因为默认网站根目录为tomcat/webapps/ROOT</p><p><strong>方法二</strong></p><pre><code>[root@web03 ~]# vim /application/tomcat/conf/server.xml +125…… #添加上这两行        &lt;Context path=&quot;&quot; docBase=&quot;/application/tomcat/webapps/memtest&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; crossContext=&quot;true&quot;/&gt;        &lt;Context path=&quot;/40team&quot; docBase=&quot;/application/tomcat/webapps/memtest&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; crossContext=&quot;true&quot;/&gt;……</code></pre><p>修改配置文件后，要重启服务</p><pre><code>[root@web03 ~]# /application/tomcat/bin/shutdown.sh [root@web03 ~]# /application/tomcat/bin/startup.sh  </code></pre><h5 id="3、部署开源站点（jpress）"><a href="#3、部署开源站点（jpress）" class="headerlink" title="3、部署开源站点（jpress）"></a>3、部署开源站点（jpress）</h5><p>jpress官网：<a href="http://jpress.io" target="_blank" rel="noopener">http://jpress.io</a></p><p>下载地址：<a href="https://github.com/JpressProjects/jpress" target="_blank" rel="noopener">https://github.com/JpressProjects/jpress</a></p><p>​         第一个里程碑：安装配置数据库</p><pre><code>yum -y install mariadb-serversystemctl start mariadb.service</code></pre><p>​         #配置数据库</p><pre><code>mysqlcreate database jpress DEFAULT CHARACTER SET utf8;grant all on jpress.* to jpress@&#39;localhost&#39; identified by &#39;123456&#39;;exit</code></pre><p>​         第二个里程碑：jpress站点上线</p><pre><code>[root@web03 webapps]# pwd/application/tomcat/webapps[root@web03 webapps]# wget http://10.0.0.1/apache/tomcat/jpress-web-newest.war</code></pre><p>​         第三个里程碑：浏览器访问</p><p>浏览器访问： <a href="http://10.0.0.17:8080/jpress-web-newest/install" target="_blank" rel="noopener">http://10.0.0.17:8080/jpress-web-newest/install</a></p><p><img src="https://s1.ax1x.com/2020/05/21/YHPsIO.png" alt="YHPsIO.png"></p><p>填写数据库信息</p><p><img src="https://s1.ax1x.com/2020/05/21/YHPWQA.png" alt="YHPWQA.png"></p><p>设置站点名称等</p><p><img src="https://s1.ax1x.com/2020/05/21/YHPIdf.png" alt="YHPIdf.png"></p><p>安装完成</p><p><img src="https://s1.ax1x.com/2020/05/21/YHP7FS.png" alt="YHP7FS.png"></p><p>重启tomcat服务</p><pre><code>[root@web03 ~]# /application/tomcat/bin/shutdown.sh [root@web03 ~]# /application/tomcat/bin/startup.sh  </code></pre><h4 id="7、Tomcat多实例配置"><a href="#7、Tomcat多实例配置" class="headerlink" title="7、Tomcat多实例配置"></a>7、Tomcat多实例配置</h4><p><strong>多虚拟主机</strong>：nginx 多个Server标签（域名，ip，端口） 进程数量固定 master+worker</p><p><strong>多实例（多进程）</strong>：同一个程序启动多次，分为两种情况:</p><p>第一种：一台机器跑多个站点； </p><p>第二种：一个机器跑一个站点多个实例，配合负载均衡</p><h5 id="1、复制程序文件"><a href="#1、复制程序文件" class="headerlink" title="1、复制程序文件"></a>1、复制程序文件</h5><pre><code>    cd /application/tools/    tar xf apache-tomcat-8.0.27.tar.gz    cp -a apache-tomqcat-8.0.27 tomcat8_1    cp -a apache-tomcat-8.0.27 tomcat8_2</code></pre><p>修改端口，以启动多实例。多实例之间端口不能一致</p><pre><code>sed -i &#39;s#8005#8011#;s#8080#8081#&#39; tomcat8_1/conf/server.xmlsed -i &#39;s#8005#8012#;s#8080#8082#&#39; tomcat8_2/conf/server.xml[root@web03 application]# diff tomcat8_1/conf/server.xml tomcat8_2/conf/server.xml22c22&lt; &lt;Server port=&quot;8011&quot; shutdown=&quot;SHUTDOWN&quot;&gt;---&gt; &lt;Server port=&quot;8012&quot; shutdown=&quot;SHUTDOWN&quot;&gt;67c67&lt;          Define a non-SSL/TLS HTTP/1.1 Connector on port 8081---&gt;          Define a non-SSL/TLS HTTP/1.1 Connector on port 808269c69&lt;     &lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;---&gt;     &lt;Connector port=&quot;8082&quot; protocol=&quot;HTTP/1.1&quot;75c75&lt;                port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;---&gt;                port=&quot;8082&quot; protocol=&quot;HTTP/1.1&quot;</code></pre><p>　　 将配置好的tomcat程序打包，以备之后使用</p><pre><code>tar zcf muti_tomcat8.tar.gz ./tomcat8_1 ./tomcat8_2</code></pre><p>启动tomcat多实例</p><pre><code> /application/tomcat8_1/bin/startup.sh  /application/tomcat8_2/bin/startup.sh</code></pre><p>检查端口是否启动</p><pre><code>[root@web03 tomcat8_1]# netstat -lntup |grep javatcp6   0   0 127.0.0.1:8011    :::*    LISTEN   31906/javatcp6   0   0 127.0.0.1:8012    :::*    LISTEN   31932/javatcp6   0   0 :::8080           :::*    LISTEN   31812/javatcp6   0   0 :::8081           :::*    LISTEN   31906/javatcp6   0   0 :::8082           :::*    LISTEN   31932/javatcp6   0   0 127.0.0.1:8005    :::*    LISTEN   31812/javatcp6   0   0 :::8009           :::*    LISTEN   31812/java</code></pre><p>将每个实例的网页进行区分</p><pre><code>echo 8081 &gt;&gt;/application/tomcat8_1/webapps/ROOT/index.jsp echo 8082 &gt;&gt;/application/tomcat8_2/webapps/ROOT/index.jsp</code></pre><h5 id="2、在浏览器访问，进行测试"><a href="#2、在浏览器访问，进行测试" class="headerlink" title="2、在浏览器访问，进行测试"></a>2、在浏览器访问，进行测试</h5><p>检查多实例的启动</p><p>​                  <a href="http://10.0.0.17:8082" target="_blank" rel="noopener">http://10.0.0.17:8082</a></p><p><img src="https://s1.ax1x.com/2020/05/21/YHPbWQ.png" alt="YHPbWQ.png"></p><p><a href="http://10.0.0.17:8081" target="_blank" rel="noopener">http://10.0.0.17:8081</a></p><p><img src="https://s1.ax1x.com/2020/05/21/YHPXyn.png" alt="YHPXyn.png"></p><h4 id="8、tomcat反向代理集群"><a href="#8、tomcat反向代理集群" class="headerlink" title="8、tomcat反向代理集群"></a>8、tomcat反向代理集群</h4><h5 id="1、负载均衡器说明"><a href="#1、负载均衡器说明" class="headerlink" title="1、负载均衡器说明"></a>1、负载均衡器说明</h5><pre><code>[root@lb01 ~]# cat /etc/redhat-release CentOS release 6.9 (Final)[root@lb01 ~]# uname -aLinux lb01 2.6.32-696.el6.x86_64 #1 SMP Tue Mar 21 19:29:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux[root@lb01 ~]# getenforce Disabled[root@lb01 ~]# /etc/init.d/iptables statusiptables: Firewall is not running.</code></pre><p>负载均衡软件使用nginx，详情参照</p><p><a href="http://www.cnblogs.com/clsn/p/7750615.html" target="_blank" rel="noopener">http://www.cnblogs.com/clsn/p/7750615.html</a></p><h5 id="2、配置负载均衡器"><a href="#2、配置负载均衡器" class="headerlink" title="2、配置负载均衡器"></a>2、配置负载均衡器</h5><p>备份原配置文件</p><pre><code>mv  /application/nginx/conf/nginx.conf{,.20171127}    egrep -v &#39;#|^$&#39; /application/nginx/conf/nginx.conf.default  &gt; /application/nginx/conf/nginx.conf</code></pre><p>​         配置文件内容</p><pre><code>[root@lb01 ~]# cat /application/nginx/conf/nginx.confworker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    upstream web_pools {        server 10.0.0.17:8081;        server 10.0.0.17:8082;    }    server {        listen       80;        server_name  localhost;        location / {            root   html;            index  index.jsp index.htm;        proxy_pass http://web_pools;        }        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }}</code></pre><p>​         配置完成后重启nginx服务</p><pre><code>/application/nginx/sbin/nginx  -s stop /application/nginx/sbin/nginx</code></pre><h5 id="3、使用命令进行访问测试"><a href="#3、使用命令进行访问测试" class="headerlink" title="3、使用命令进行访问测试"></a>3、使用命令进行访问测试</h5><p>使用curl 命令进行测试，tail进行关键字提取</p><pre><code>[root@lb01 ~]# curl -s 10.0.0.5|tail -18081[root@lb01 ~]# curl -s 10.0.0.5|tail -18082</code></pre><p>使用curl 命令进行测试，awk进行关键字提取</p><pre><code>[root@lb01 ~]# curl -s 10.0.0.5|awk &#39;END{print}&#39;8082[root@lb01 ~]# curl -s 10.0.0.5|awk &#39;END{print}&#39;8081</code></pre><p> 使用curl 命令进行测试，sed进行关键字提取</p><pre><code>[root@lb01 ~]# curl -s 10.0.0.5|sed -n &#39;$p&#39;8082[root@lb01 ~]# curl -s 10.0.0.5|sed -n &#39;$p&#39;8081</code></pre><h5 id="4、在浏览器上进行访问测试"><a href="#4、在浏览器上进行访问测试" class="headerlink" title="4、在浏览器上进行访问测试"></a>4、在浏览器上进行访问测试</h5><p><img src="https://s1.ax1x.com/2020/05/21/YHPjLq.png" alt="YHPjLq.png"></p><p><img src="https://s1.ax1x.com/2020/05/21/YHPxe0.png" alt="YHPxe0.png"></p><p>​         建议使用google浏览器chrome 的隐身模式进行访问，使用ctrl+f5 进行强制刷新</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat_01_简介</title>
      <link href="2020/03/21/linux/tomcat/tomcat-01/"/>
      <url>2020/03/21/linux/tomcat/tomcat-01/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="1、Tomcat-简介"><a href="#1、Tomcat-简介" class="headerlink" title="1、Tomcat 简介"></a><strong>1、Tomcat 简介</strong></h4><p>Tomcat是Apache软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成。</p><p>Tomcat服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。</p><p>Tomcat和Nginx、Apache(httpd)、lighttpd等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态HTML的能力不如Nginx/Apache服务器。</p><p>目前Tomcat最新版本为9.0。Java容器还有resin、weblogic等。</p><p><strong>Tomcat**</strong>官网：** <a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org</a></p><h5 id="1、Tomcat好帮手—JDK"><a href="#1、Tomcat好帮手—JDK" class="headerlink" title="1、Tomcat好帮手—JDK"></a>1、Tomcat好帮手—JDK</h5><p>JDK是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的java应用程序。JDK是整个java开发的核心，它包含了JAVA的运行环境（JVM+Java系统类库）和JAVA工具。</p><p><strong>JDK**</strong>包含了一批用于Java<strong>**开发的组件，其中包括：</strong></p><pre><code>javac：编译器，将后缀名为.java的源代码编译成后缀名为“.class”的字节码java：运行工具，运行.class的字节码jar：打包工具，将相关的类文件打包成一个文件javadoc：文档生成器，从源码注释中提取文档，注释需匹配规范jdb debugger：调试工具jps：显示当前java程序运行的进程状态javap：反编译程序appletviewer：运行和调试applet程序的工具，不需要使用浏览器javah：从Java类生成C头文件和C源文件。这些文件提供了连接胶合，使Java和C代码可进行交互。javaws：运行JNLP程序extcheck：一个检测jar包冲突的工具apt：注释处理工具 jhat：java堆分析工具jstack：栈跟踪程序jstat：JVM检测统计工具jstatd：jstat守护进程jinfo：获取正在运行或崩溃的java程序配置信息jmap：获取java进程内存映射信息idlj：IDL-to-Java编译器。将IDL语言转化为java文件 policytool：一个GUI的策略文件创建和管理工具jrunscript：命令行脚本运行</code></pre><p>JDK中还包括完整的JRE（Java Runtime Environment），Java运行环境，也被称为private runtime。包括了用于产品环境的各种库类，如基础类库rt.jar，以及给开发人员使用的补充库，如国际化与本地化的类库、IDL库等等。</p><p>JDK中还包括各种样例程序，用以展示Java API中的各部分。</p><p><strong>JDK**</strong>下载面页：</p><p>**<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a> **</p><h5 id="2、安装Tomcat-amp-JDK"><a href="#2、安装Tomcat-amp-JDK" class="headerlink" title="2、安装Tomcat &amp; JDK"></a>2、安装Tomcat &amp; JDK</h5><p>安装时候选择tomcat软件版本要与程序开发使用的版本一致。jdk版本要进行与tomcat保持一致。</p><h6 id="1、系统环境说明"><a href="#1、系统环境说明" class="headerlink" title="1、系统环境说明"></a>1、系统环境说明</h6><pre><code>[root@web03 ~]# cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [root@web03 ~]# uname -a Linux web03 3.10.0-693.el7.x86_64 #1 SMP Tue Aug 22 21:09:27 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux[root@web03 ~]# getenforce Disabled[root@web03 ~]# systemctl status firewalld.service● firewalld.service - firewalld - dynamic firewall daemon   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)   Active: inactive (dead)     Docs: man:firewalld(1)</code></pre><h6 id="2-、安装JDK"><a href="#2-、安装JDK" class="headerlink" title="2 、安装JDK"></a>2 、安装JDK</h6><p>命令集：</p><pre><code>tar xf jdk-8u60-linux-x64.tar.gz -C /application/ln -s /application/jdk1.8.0_60 /application/jdk# 设置环境变量sed -i.ori &#39;$a export JAVA_HOME=/application/jdk\nexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar&#39; /etc/profilesource /etc/profile</code></pre><p>测试jdk是否安装成功↓</p><pre><code>[root@web03 ~]# java -versionjava version &quot;1.8.0_60&quot;Java(TM) SE Runtime Environment (build 1.8.0_60-b27)Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)</code></pre><h6 id="3、安装Tomcat"><a href="#3、安装Tomcat" class="headerlink" title="3、安装Tomcat"></a>3、安装Tomcat</h6><p>命令集：</p><pre><code>tar xf apache-tomcat-8.0.27.tar.gz -C /application/ln -s /application/apache-tomcat-8.0.27 /application/tomcat# 设置环境变量echo &#39;export TOMCAT_HOME=/application/tomcat&#39;&gt;&gt;/etc/profilesource /etc/profile# 注意授权，统一权限chown -R root.root /application/jdk/ /application/tomcat/</code></pre><p>检查tomcat是否安装成功</p><pre><code>[root@web03 ~]# /application/tomcat/bin/version.shUsing CATALINA_BASE:   /application/tomcatUsing CATALINA_HOME:   /application/tomcatUsing CATALINA_TMPDIR: /application/tomcat/tempUsing JRE_HOME:        /application/jdkUsing CLASSPATH:       /application/tomcat/bin/bootstrap.jar:/application/tomcat/bin/tomcat-juli.jarServer version: Apache Tomcat/8.0.27Server built:   Sep 28 2015 08:17:25 UTCServer number:  8.0.27.0OS Name:        LinuxOS Version:     3.10.0-693.el7.x86_64Architecture:   amd64JVM Version:    1.8.0_60-b27JVM Vendor:     Oracle Corporation</code></pre><h4 id="2、Tomcat目录介绍"><a href="#2、Tomcat目录介绍" class="headerlink" title="2、Tomcat目录介绍"></a>2、Tomcat目录介绍</h4><h5 id="1、tomcat主目录介绍"><a href="#1、tomcat主目录介绍" class="headerlink" title="1、tomcat主目录介绍"></a>1、tomcat主目录介绍</h5><pre><code>[root@web03 ~]# cd /application/tomcat/[root@web03 tomcat]# tree -L 1.├── bin              #存放tomcat管理脚本├── conf             # tomcat 配置文件存放目录├── lib              # web应用调用的jar包存放路径├── LICENSE├── logs             # tomcat 日志存放目录，catalina.out 为主要输出日志├── NOTICE├── RELEASE-NOTES├── RUNNING.txt├── temp             # 存放临时文件├── webapps         # web程序存放目录└── work             # 存放编译产生的.java 与 .class文件7 directories, 4 files</code></pre><h5 id="2、webapps目录介绍"><a href="#2、webapps目录介绍" class="headerlink" title="2、webapps目录介绍"></a>2、webapps目录介绍</h5><pre><code>[root@web03 tomcat]# cd webapps/[root@web03 webapps]# tree -L 1.├── docs            # tomcat 帮助文档├── examples       # web应用实例├── host-manager  # 主机管理├── manager         # 管理└── ROOT             # 默认站点根目录5 directories, 0 files</code></pre><h5 id="3、Tomcat配置文件目录介绍（conf）"><a href="#3、Tomcat配置文件目录介绍（conf）" class="headerlink" title="3、Tomcat配置文件目录介绍（conf）"></a>3、Tomcat配置文件目录介绍（conf）</h5><pre><code>[root@web03 conf]# tree -L 1.├── Catalina├── catalina.policy├── catalina.properties├── context.xml├── logging.properties├── logs├── server.xml           # tomcat 主配置文件├── server.xml.bak├── server.xml.bak2├── tomcat-users.xml    # tomcat 管理用户配置文件├── tomcat-users.xsd└── web.xml2 directories, 10 files</code></pre><h5 id="4、Tomcat的管理"><a href="#4、Tomcat的管理" class="headerlink" title="4、Tomcat的管理"></a>4、Tomcat的管理</h5><pre><code>#  启动程序/application/tomcat/bin/startup.sh#  关闭程序/application/tomcat/bin/shutdown.sh</code></pre><p>启动停止</p><pre><code>[root@web03 ~]# /application/tomcat/bin/shutdown.sh Using CATALINA_BASE:   /application/tomcatUsing CATALINA_HOME:   /application/tomcatUsing CATALINA_TMPDIR: /application/tomcat/tempUsing JRE_HOME:        /application/jdkUsing CLASSPATH:       /application/tomcat/bin/bootstrap.jar:/application/tomcat/bin/tomcat-juli.jar[root@web03 ~]# /application/tomcat/bin/startup.sh Using CATALINA_BASE:   /application/tomcatUsing CATALINA_HOME:   /application/tomcatUsing CATALINA_TMPDIR: /application/tomcat/tempUsing JRE_HOME:        /application/jdkUsing CLASSPATH:       /application/tomcat/bin/bootstrap.jar:/application/tomcat/bin/tomcat-juli.jarTomcat started.</code></pre><p>​         注意：tomcat未启动的情况下使用shutdown脚本，会有大量的输出信息。</p><p>检查tomcat是否启动正常</p><pre><code>[root@web03 ~]# netstat -lntup  |grep javatcp6       0      0 :::8080         :::*                   LISTEN      30560/java          tcp6       0      0 127.0.0.1:8005          :::*          LISTEN      30560/java          tcp6       0      0 :::8009                 :::*           LISTEN      30560/java      </code></pre><p><strong>说明：</strong>所有与java相关的，服务启动都是java命名的进程</p><p>启动完成浏览器进行访问</p><p><a href="http://10.0.0.17:8080/" target="_blank" rel="noopener">http://10.0.0.17:8080/</a></p><p><img src="https://s1.ax1x.com/2020/05/21/YHPn2j.png" alt="YHPn2j.png"></p><h4 id="3、Tomcat日志说明"><a href="#3、Tomcat日志说明" class="headerlink" title="3、Tomcat日志说明"></a>3、Tomcat日志说明</h4><h5 id="1、查看日志"><a href="#1、查看日志" class="headerlink" title="1、查看日志"></a>1、查看日志</h5><pre><code>[root@web03 ~]# tailf /application/tomcat/logs/catalina.out24-Nov-2017 15:09:51.654 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-nio-8080&quot;]24-Nov-2017 15:09:51.665 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-nio-8009&quot;]24-Nov-2017 15:09:51.670 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in 60037 ms</code></pre><p>​         发现启动时间较长，其中有一项的启动时间占据了绝大多数</p><pre><code>24-Nov-2017 15:09:50.629 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployWAR Deployment of web application archive /application/apache-tomcat-8.0.27/webapps/memtest.war has finished in 58,892 ms</code></pre><p>​         发现耗时在这里：是session引起的随机数问题导致的。Tocmat的Session ID是通过SHA1算法计算得到的，计算Session ID的时候必须有一个密钥。为了提高安全性Tomcat在启动的时候会通过随机生成一个密钥。</p><h5 id="2、解决Tomcat启动慢的方法"><a href="#2、解决Tomcat启动慢的方法" class="headerlink" title="2、解决Tomcat启动慢的方法"></a>2、解决Tomcat启动慢的方法</h5><p>Tomcat启动慢主要原因是生成随机数的时候卡住了,导致tomcat启动不了。</p><p>是否有足够的熵来用于产生随机数，可以通过如下命令来查看</p><pre><code>[root@web03 ~]# cat /proc/sys/kernel/random/entropy_avail6</code></pre><p>为了加速/dev/random提供随机数的速度，你可以通过操作设备的外设，让其产生大量的中断，网络传输数据，按键，移动鼠标，在命令行敲几个不同的命令，俗称聚气。</p><p>cat /dev/random 会消耗能量</p><p><strong>方法1**</strong>：**</p><pre><code>vim $JAVA_HOME/jre/lib/security/java.securitysecurerandom.source=file:/dev/random</code></pre><p>改为</p><pre><code>securerandom.source=file:/dev/urandom</code></pre><p><strong>方法2**</strong>：**</p><pre><code>vim $TOMCAT_HOME/bin/catalina.shif [[ &quot;$JAVA_OPTS&quot; != *-Djava.security.egd=* ]]; then    JAVA_OPTS=&quot;$JAVA_OPTS -Djava.security.egd=file:/dev/urandom&quot;fi</code></pre><p>这个系统属性egd表示熵收集守护进程(entropy gathering daemon)</p><p><strong>方法3**</strong>：（推荐）**</p><pre><code>yum install rng-tools # 安装rngd服务（熵服务，增大熵池）systemctl start rngd  # 启动服务</code></pre><h4 id="4、Tomcat管理功能使用"><a href="#4、Tomcat管理功能使用" class="headerlink" title="4、Tomcat管理功能使用"></a>4、Tomcat管理功能使用</h4><p><strong>注意：测试功能，生产环境不要用</strong></p><p>Tomcat管理功能用于对Tomcat自身以及部署在Tomcat上的应用进行管理的web应用。在默认情况下是处于禁用状态的。如果需要开启这个功能，就需要配置管理用户，即配置tomcat-users.xml 文件。</p><pre><code>[root@web03 ~]# vim /application/tomcat/conf/tomcat-users.xml……39 &lt;role rolename=&quot;manager-gui&quot;/&gt; 40 &lt;role rolename=&quot;admin-gui&quot;/&gt; 41 &lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,admin-gui&quot;/&gt; 42 &lt;/tomcat-users&gt;   # 在此行前加入上面三行</code></pre><p><strong>未修改文件前进行访问</strong></p><p><img src="https://s1.ax1x.com/2020/05/21/YHPuxs.png" alt="YHPuxs.png"></p><pre><code>&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;s3cret&quot; roles=&quot;manager-gui&quot;/&gt;</code></pre><p><img src="https://s1.ax1x.com/2020/05/21/YHPMMn.png" alt="YHPMMn.png"></p><pre><code>&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;s3cret&quot; roles=&quot;admin-gui&quot;/&gt;</code></pre><p>​         从而得出上面的配置文件信息。</p><h5 id="1、在web界面访问管理界面"><a href="#1、在web界面访问管理界面" class="headerlink" title="1、在web界面访问管理界面"></a>1、在web界面访问管理界面</h5><p><img src="https://s1.ax1x.com/2020/05/21/YHP3ZV.png" alt="YHP3ZV.png"></p><p>​         输入之前配置的账户与密码即可</p><p><img src="https://s1.ax1x.com/2020/05/21/YHPGIU.png" alt="YHPGIU.png"></p><p><img src="https://s1.ax1x.com/2020/05/21/YHPtG4.png" alt="YHPtG4.png"></p><h4 id="5、Tomcat主配置文件详解"><a href="#5、Tomcat主配置文件详解" class="headerlink" title="5、Tomcat主配置文件详解"></a>5、Tomcat主配置文件详解</h4><h5 id="1、server-xml组件类别"><a href="#1、server-xml组件类别" class="headerlink" title="1、server.xml组件类别"></a>1、server.xml组件类别</h5><p>顶级组件：位于整个配置的顶层，如server。</p><p>容器类组件：可以包含其它组件的组件，如service、engine、host、context。</p><p>连接器组件：连接用户请求至tomcat，如connector。</p><p>被嵌套类组件：位于一个容器当中，不能包含其他组件，如Valve、logger。</p><pre><code>&lt;server&gt;     &lt;service&gt;     &lt;connector /&gt;     &lt;engine&gt;     &lt;host&gt;     &lt;context&gt;&lt;/context&gt;     &lt;/host&gt;     &lt;host&gt;     &lt;context&gt;&lt;/context&gt;     &lt;/host&gt;     &lt;/engine&gt;     &lt;/service&gt;&lt;/server&gt;</code></pre><h5 id="2、组件介绍"><a href="#2、组件介绍" class="headerlink" title="2、组件介绍"></a>2、组件介绍</h5><table><thead><tr><th><strong>组件名称</strong></th><th><strong>功能介绍</strong></th></tr></thead><tbody><tr><td><strong>engine</strong></td><td>核心容器组件，catalina引擎，负责通过connector接收用户请求，并处理请求，将请求转至对应的虚拟主机host。</td></tr><tr><td><strong>host</strong></td><td>类似于httpd中的虚拟主机，一般而言支持基于FQDN的虚拟主机。</td></tr><tr><td><strong>context</strong></td><td>定义一个应用程序，是一个最内层的容器类组件（不能再嵌套）。配置context的主要目的指定对应对的webapp的根目录，类似于httpd的alias，其还能为webapp指定额外的属性，如部署方式等。</td></tr><tr><td><strong>connector</strong></td><td>接收用户请求，类似于httpd的listen配置监听端口的。</td></tr><tr><td><strong>service**</strong>（服务）**</td><td>将connector关联至engine，因此一个service内部可以有多个connector，但只能有一个引擎engine。service内部有两个connector，一个engine。因此，一般情况下一个server内部只有一个service，一个service内部只有一个engine，但一个service内部可以有多个connector。</td></tr><tr><td><strong>server</strong></td><td>表示一个运行于JVM中的tomcat实例。</td></tr><tr><td><strong>Valve</strong></td><td>阀门，拦截请求并在将其转至对应的webapp前进行某种处理操作，可以用于任何容器中，比如记录日志(access log valve)、基于IP做访问控制(remote address filter valve)。</td></tr><tr><td><strong>logger</strong></td><td>日志记录器，用于记录组件内部的状态信息，可以用于除context外的任何容器中。</td></tr><tr><td><strong>realm</strong></td><td>可以用于任意容器类的组件中，关联一个用户认证库，实现认证和授权。可以关联的认证库有两种：UserDatabaseRealm、MemoryRealm和JDBCRealm。</td></tr><tr><td><strong>UserDatabaseRealm</strong></td><td>使用JNDI自定义的用户认证库。</td></tr><tr><td><strong>MemoryRealm</strong></td><td>认证信息定义在tomcat-users.xml中。</td></tr><tr><td><strong>JDBCRealm</strong></td><td>认证信息定义在数据库中，并通过JDBC连接至数据库中查找认证用户。</td></tr></tbody></table><h5 id="3、server-xml配置文件注释"><a href="#3、server-xml配置文件注释" class="headerlink" title="3、server.xml配置文件注释"></a>3、server.xml配置文件注释</h5><pre><code>&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;&lt;!--&lt;Server&gt;元素代表整个容器,是Tomcat实例的顶层元素.由org.apache.catalina.Server接口来定义.它包含一个&lt;Service&gt;元素.并且它不能做为任何元素的子元素.    port指定Tomcat监听shutdown命令端口.终止服务器运行时,必须在Tomcat服务器所在的机器上发出shutdown命令.该属性是必须的.    shutdown指定终止Tomcat服务器运行时,发给Tomcat服务器的shutdown监听端口的字符串.该属性必须设置--&gt;&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;  &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;  &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;  &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;  &lt;GlobalNamingResources&gt;    &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;              type=&quot;org.apache.catalina.UserDatabase&quot;              description=&quot;User database that can be updated and saved&quot;              factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;              pathname=&quot;conf/tomcat-users.xml&quot; /&gt;  &lt;/GlobalNamingResources&gt;  &lt;!--service服务组件--&gt;  &lt;Service name=&quot;Catalina&quot;&gt;    &lt;!-- Connector主要参数说明（见下表） --&gt;    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; /&gt;    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;    &lt;!--engine,核心容器组件,catalina引擎,负责通过connector接收用户请求,并处理请求,将请求转至对应的虚拟主机host        defaultHost指定缺省的处理请求的主机名，它至少与其中的一个host元素的name属性值是一样的    --&gt;    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;      &lt;!--Realm表示存放用户名，密码及role的数据库--&gt;      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;               resourceName=&quot;UserDatabase&quot;/&gt;      &lt;/Realm&gt;      &lt;!-- 详情常见下表（host参数详解）--&gt;      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;        &lt;!-- 详情常见下表（Context参数说明 ）--&gt;        &lt;Context path=&quot;&quot; docBase=&quot;&quot; debug=&quot;&quot;/&gt;        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;      &lt;/Host&gt;    &lt;/Engine&gt;  &lt;/Service&gt;&lt;/Server&gt;</code></pre><h5 id="4、Connector主要参数说明"><a href="#4、Connector主要参数说明" class="headerlink" title="4、Connector主要参数说明"></a>4、Connector主要参数说明</h5><table><thead><tr><th><strong>参数</strong></th><th><strong>参数说明</strong></th></tr></thead><tbody><tr><td><strong>connector</strong></td><td>接收用户请求，类似于httpd的listen配置监听端口.</td></tr><tr><td><strong>port</strong></td><td>指定服务器端要创建的端口号，并在这个端口监听来自客户端的请求。</td></tr><tr><td><strong>address</strong></td><td>指定连接器监听的地址，默认为所有地址（即0.0.0.0）</td></tr><tr><td><strong>protocol</strong></td><td>连接器使用的协议，支持HTTP和AJP。AJP（Apache Jserv Protocol）专用于tomcat与apache建立通信的， 在httpd反向代理用户请求至tomcat时使用（可见Nginx反向代理时不可用AJP协议）。</td></tr><tr><td><strong>minProcessors</strong></td><td>服务器启动时创建的处理请求的线程数</td></tr><tr><td><strong>maxProcessors</strong></td><td>最大可以创建的处理请求的线程数</td></tr><tr><td><strong>enableLookups</strong></td><td>如果为true，则可以通过调用request.getRemoteHost()进行DNS查询来得到远程客户端的实际主机名，若为false则不进行DNS查询，而是返回其ip地址</td></tr><tr><td><strong>redirectPort</strong></td><td>指定服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号</td></tr><tr><td><strong>acceptCount</strong></td><td>指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理</td></tr><tr><td><strong>connectionTimeout</strong></td><td>指定超时的时间数(以毫秒为单位)</td></tr></tbody></table><h5 id="5、host参数详解"><a href="#5、host参数详解" class="headerlink" title="5、host参数详解"></a>5、host参数详解</h5><table><thead><tr><th><strong>参数</strong></th><th><strong>参数说明</strong></th></tr></thead><tbody><tr><td><strong>host</strong></td><td>表示一个虚拟主机</td></tr><tr><td><strong>name</strong></td><td>指定主机名</td></tr><tr><td><strong>appBase</strong></td><td>应用程序基本目录，即存放应用程序的目录.一般为appBase=”webapps”，相对于CATALINA_HOME而言的，也可以写绝对路径。</td></tr><tr><td><strong>unpackWARs</strong></td><td>如果为true，则tomcat会自动将WAR文件解压，否则不解压，直接从WAR文件中运行应用程序</td></tr><tr><td><strong>autoDeploy</strong></td><td>在tomcat启动时，是否自动部署。</td></tr><tr><td><strong>xmlValidation</strong></td><td>是否启动xml的校验功能，一般xmlValidation=”false”。</td></tr><tr><td><strong>xmlNamespaceAware</strong></td><td>检测名称空间，一般xmlNamespaceAware=”false”。</td></tr></tbody></table><h5 id="6、Context参数说明"><a href="#6、Context参数说明" class="headerlink" title="6、Context参数说明"></a>6、Context参数说明</h5><table><thead><tr><th><strong>参数</strong></th><th><strong>参数说明</strong></th></tr></thead><tbody><tr><td><strong>Context</strong></td><td>表示一个web应用程序，通常为WAR文件</td></tr><tr><td><strong>docBase</strong></td><td>应用程序的路径或者是WAR文件存放的路径,也可以使用相对路径，起始路径为此Context所属Host中appBase定义的路径。</td></tr><tr><td><strong>path</strong></td><td>表示此web应用程序的url的前缀，这样请求的url为<a href="http://localhost:8080/path/" target="_blank" rel="noopener">http://localhost:8080/path/</a>****</td></tr><tr><td><strong>reloadable</strong></td><td>这个属性非常重要，如果为true，则tomcat会自动检测应用程序的/WEB-INF/lib和/WEB-INF/classes目录的变化，自动装载新的应用程序，可以在不重启tomcat的情况下改变应用程序</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xshell 配置</title>
      <link href="2020/03/21/xshell-tu-chu-xian-shi-ji/"/>
      <url>2020/03/21/xshell-tu-chu-xian-shi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="xshell配色方案"><a href="#xshell配色方案" class="headerlink" title="[xshell配色方案]"></a>[xshell配色方案]</h3><pre><code>[cyylog]text=00ff80cyan(bold)=00fffftext(bold)=e9e9e9magenta=c000c0green=80ff00green(bold)=3c5a38background=042028cyan=00c0c0red(bold)=ff0000yellow=c0c000magenta(bold)=ff00ffyellow(bold)=ffff00red=ff4500white=c0c0c0blue(bold)=1e90ffwhite(bold)=fdf6e3black=000000blue=00bfffblack(bold)=808080[Names]name0=cyylogcount=1</code></pre><h5 id="！！！-请自行创建-xcs-后缀的文件"><a href="#！！！-请自行创建-xcs-后缀的文件" class="headerlink" title="！！！ 请自行创建 xcs 后缀的文件"></a>！！！ 请自行创建 <code>xcs</code> 后缀的文件</h5><h3 id="xshell突出显示集"><a href="#xshell突出显示集" class="headerlink" title="[xshell突出显示集]"></a>[xshell突出显示集]</h3><h3 id="xshell突出显示集（参考mobaxterm，直接拷贝过来不行，应该是xshell对正则表达式的支持不够好）"><a href="#xshell突出显示集（参考mobaxterm，直接拷贝过来不行，应该是xshell对正则表达式的支持不够好）" class="headerlink" title="xshell突出显示集（参考mobaxterm，直接拷贝过来不行，应该是xshell对正则表达式的支持不够好）:"></a>xshell突出显示集（参考mobaxterm，直接拷贝过来不行，应该是xshell对正则表达式的支持不够好）:</h3><p>Underline:</p><pre class=" language-shell"><code class="language-shell">\b(http(s)?://[A-Za-z0-9_./&?=%~#{}()@+-]+)\b</code></pre><p>Red:</p><pre class=" language-shell"><code class="language-shell">(\b((bad|wrong|incorrect|improper|invalid|unsupported|bad)( file| memory)? (descriptor|alloc(ation)?|addr(ess)?|owner(ship)?|arg(ument)?|param(eter)?|setting|length|filename)|not properly|improperly|(operation |connection |authentication |access |permission )?(false|no|ko|denied|disallowed|not allowed|refused|problem|failed|failure|not permitted)|no [A-Za-z]+( [A-Za-z]+)? found|invalid|unsupported|not supported|seg(mentation )?fault|corruption|corrupted|corrupt|overflow|underrun|not ok|unimplemented|unsuccessfull|not implemented|permerrors?|fehlers?|errore|errors?|erreurs?|fejl|virhe|greška|erro|fel|\(ee\)|\(ni\))\b)</code></pre><p>Green:</p><pre class=" language-shell"><code class="language-shell">(\b(true|yes|ok|accepted|allowed|enabled|connected|erfolgreich|exitoso|successo|sucedido|framgångsrik|successfully|successful|succeeded|success)\b)</code></pre><p>Yellow:</p><pre><code>(\b(\[\-w[A-Za-z-]+\]|caught signal [0-9]+|cannot|(connection (to (remote host|[a-z0-9.]+) )?)?(closed|terminated|stopped|not responding)|exited|no more [A-Za-z] available|unexpected|(command |binary |file )?not found|(o)+ps|out of (space|memory)|low (memory|disk)|unknown|disabled|disconnected|deprecated|refused|disconnect(ion)?|advertencia|avvertimento|attention|warnings?|achtung|exclamation|alerts?|warnungs?|advarsel|pedwarn|aviso|varoitus|upozorenje|peringatan|uyari|varning|avertissement|\(ww\)|\(\?\?\)|could not|unable to)\b)</code></pre><p>shellMagenta:</p><pre class=" language-shell"><code class="language-shell">(\b(localhost|([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])\.[0-9]+\.[0-9]+\.[0-9]+|null|none)\b)</code></pre><p>Cyan:</p><pre class=" language-shell"><code class="language-shell">(\b(last (failed )?login:|launching|checking|loading|creating|building|important|booting|starting|notice|informational|informationen|informazioni|informação|oplysninger|informations?|info|información|informasi|note|\(ii\)|\(\!\!\))\b)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubeadm快速部署kubernetes集群</title>
      <link href="2020/03/17/rong-qi/kubeadm-kuai-su-bu-shu-kubernetes-ji-qun/"/>
      <url>2020/03/17/rong-qi/kubeadm-kuai-su-bu-shu-kubernetes-ji-qun/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。</p><p>这个工具能通过两条指令完成一个kubernetes集群的部署：</p><pre><code># 创建一个 Master 节点$ kubeadm init# 将一个 Node 节点加入到当前集群中$ kubeadm join &lt;Master节点的IP和端口 &gt;</code></pre><h2 id="1-安装要求"><a href="#1-安装要求" class="headerlink" title="1. 安装要求"></a>1. 安装要求</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件：</p><ul><li>一台或多台机器，操作系统 CentOS7.x-86_x64</li><li>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多</li><li>集群中所有机器之间网络互通</li><li>可以访问外网，需要拉取镜像</li><li>禁止swap分区</li></ul><h2 id="2-学习目标"><a href="#2-学习目标" class="headerlink" title="2. 学习目标"></a>2. 学习目标</h2><ol><li>在所有节点上安装Docker和kubeadm</li><li>部署Kubernetes Master</li><li>部署容器网络插件</li><li>部署 Kubernetes Node，将节点加入Kubernetes集群中</li><li>部署Dashboard Web页面，可视化查看Kubernetes资源</li></ol><h2 id="3-准备环境"><a href="#3-准备环境" class="headerlink" title="3. 准备环境"></a>3. 准备环境</h2><p><img src="http://p9.pstatp.com/large/pgc-image/d244ddcca380403e816a8705da3898c6" alt="kubeadm快速部署kubernetes集群"></p><p>Kubernetes 架构图</p><p><img src="http://p3.pstatp.com/large/pgc-image/8f8781176b8d4670b94214caa934d880" alt="kubeadm快速部署kubernetes集群"></p><p>Kubernetes 架构图</p><pre><code>关闭防火墙：$ systemctl stop firewalld$ systemctl disable firewalld关闭selinux：$ sed -i &#39;s/enforcing/disabled/&#39; /etc/selinux/config $ setenforce 0关闭swap：$ swapoff -a  $ 临时$ vim /etc/fstab  $ 永久添加主机名与IP对应关系（记得设置主机名）：$ cat /etc/hosts192.168.31.63 k8s-master192.168.31.65 k8s-node1192.168.31.66 k8s-node2将桥接的IPv4流量传递到iptables的链：$ cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF$ sysctl --system</code></pre><h2 id="4-所有节点安装Docker-kubeadm-kubelet"><a href="#4-所有节点安装Docker-kubeadm-kubelet" class="headerlink" title="4. 所有节点安装Docker/kubeadm/kubelet"></a>4. 所有节点安装Docker/kubeadm/kubelet</h2><p>Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker。</p><h3 id="4-1-安装Docker"><a href="#4-1-安装Docker" class="headerlink" title="4.1 安装Docker"></a>4.1 安装Docker</h3><pre><code>$ wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo$ yum -y install docker-ce-18.06.1.ce-3.el7$ systemctl enable docker &amp;&amp; systemctl start docker$ docker --versionDocker version 18.06.1-ce, build e68fc7a</code></pre><h3 id="4-2-添加阿里云YUM软件源"><a href="#4-2-添加阿里云YUM软件源" class="headerlink" title="4.2 添加阿里云YUM软件源"></a>4.2 添加阿里云YUM软件源</h3><pre><code>$ cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF</code></pre><h3 id="4-3-安装kubeadm，kubelet和kubectl"><a href="#4-3-安装kubeadm，kubelet和kubectl" class="headerlink" title="4.3 安装kubeadm，kubelet和kubectl"></a>4.3 安装kubeadm，kubelet和kubectl</h3><p>由于版本更新频繁，这里指定版本号部署：</p><pre><code>$ yum install -y kubelet-1.14.0 kubeadm-1.14.0 kubectl-1.14.0$ systemctl enable kubelet</code></pre><h2 id="5-部署Kubernetes-Master"><a href="#5-部署Kubernetes-Master" class="headerlink" title="5. 部署Kubernetes Master"></a>5. 部署Kubernetes Master</h2><p>在192.168.31.63（Master）执行。</p><pre><code>$ kubeadm init \  --apiserver-advertise-address=192.168.31.63 \  --image-repository registry.aliyuncs.com/google_containers \  --kubernetes-version v1.14.0 \  --service-cidr=10.1.0.0/16 \  --pod-network-cidr=10.244.0.0/16</code></pre><p>由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址。</p><p>使用kubectl工具：</p><pre><code>mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config$ kubectl get nodes</code></pre><h2 id="6-安装Pod网络插件（CNI）"><a href="#6-安装Pod网络插件（CNI）" class="headerlink" title="6. 安装Pod网络插件（CNI）"></a>6. 安装Pod网络插件（CNI）</h2><pre><code>$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml</code></pre><p>确保能够访问到quay.io这个registery。 master执行</p><p># kubectl get pods -n kube-system</p><h2 id="7-加入Kubernetes-Node"><a href="#7-加入Kubernetes-Node" class="headerlink" title="7. 加入Kubernetes Node"></a>7. 加入Kubernetes Node</h2><p>在192.168.31.65/66（Node）执行。</p><p>向集群添加新节点，执行在kubeadm init输出的kubeadm join命令：</p><pre><code>$  kubeadm join 192.168.31.63:6443 --token l79g5t.6ov4jkddwqki1dxe --discovery-token-ca-cert-hash sha256:4f07f9068c543130461c9db368d62b4aabc22105451057f887defa35f47fa076</code></pre><h2 id="8-测试kubernetes集群"><a href="#8-测试kubernetes集群" class="headerlink" title="8. 测试kubernetes集群"></a>8. 测试kubernetes集群</h2><p>在Kubernetes集群中创建一个pod，验证是否正常运行：</p><pre><code>$ kubectl create deployment nginx --image=nginx$ kubectl expose deployment nginx --port=80 --type=NodePort$ kubectl get pod,svc$ kubectl get pod,svc -o wide</code></pre><p>访问地址：<a href="http://NodeIP:Port">http://NodeIP:Port</a></p><h2 id="9-部署-Dashboard"><a href="#9-部署-Dashboard" class="headerlink" title="9. 部署 Dashboard"></a>9. 部署 Dashboard</h2><pre><code>$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml镜像下载因为网络的原因：镜像难以下载，需要修改以下两个地方        image: tigerfive/kubernetes-dashboard-amd64:v1.10.1spec:  type: NodePort  ports:    - port: 443      targetPort: 8443</code></pre><p>默认Dashboard只能集群内部访问，修改Service为NodePort类型，暴露到外部：</p><pre><code>kind: ServiceapiVersion: v1metadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard  namespace: kube-systemspec:  type: NodePort  ports:    - port: 443      targetPort: 8443      nodePort: 30001  selector:    k8s-app: kubernetes-dashboard$ kubectl apply -f kubernetes-dashboard.yaml</code></pre><p>访问地址：<a href="http://NodeIP:30001" target="_blank" rel="noopener">http://NodeIP:30001</a></p><p>创建service account并绑定默认cluster-admin管理员集群角色：</p><pre><code>$ kubectl create serviceaccount dashboard-admin -n kube-system$ kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin$ kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk &#39;/dashboard-admin/{print $1}&#39;)</code></pre><p>使用输出的token登录Dashboard。</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes入门</title>
      <link href="2020/03/14/rong-qi/kubernetes-ru-men/"/>
      <url>2020/03/14/rong-qi/kubernetes-ru-men/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="Kubernetes功能"><a href="#Kubernetes功能" class="headerlink" title="Kubernetes功能"></a>Kubernetes功能</h2><p>​        官方定义k8s能够对容器化软件进行部署管理，在不停机的前提下提供简单快速的发布和更新方式。换句话说，如果项目需要多机器节点的微服务架构，并且采用Docker image（镜像）进行容器化部署，那么k8s可以帮助我们屏蔽掉集群的复杂性，自动选择最优资源分配方式进行部署。在此基础上，k8s还提供简单的多实例部署及更新方案，仅需几个操作命令就可以轻松实现。</p><h2 id="k8s集群简单介绍"><a href="#k8s集群简单介绍" class="headerlink" title="k8s集群简单介绍"></a>k8s集群简单介绍</h2><p><img src="https://s1.ax1x.com/2020/05/04/YCTTYR.png" alt="YCTTYR.png"></p><p><strong>Master 负责管理集群</strong> 负责协调集群中的所有活动，例如调度应用程序，维护应用程序的状态，扩展和更新应用程序。</p><p><strong>Worker节点(即图中的Node)是VM(虚拟机)或物理计算机，充当k8s集群中的工作计算机。</strong> 每个Worker节点都有一个Kubelet，它管理该Worker节点并负责与Master节点通信。该Worker节点还应具有用于处理容器操作的工具，例如Docker。</p><h1 id="1-部署一个应用程序"><a href="#1-部署一个应用程序" class="headerlink" title="1.部署一个应用程序"></a>1.部署一个应用程序</h1><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>已经</p><ul><li>完成 Kubernetes 集群的安装，请参考文档 <a href="https://www.kuboard.cn/install/install-k8s.html" target="_blank" rel="noopener">安装 Kubernetes 单Master节点</a></li></ul><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>使用 kubectl 在 k8s 上部署第一个应用程序。</li></ul><p>TIP</p><ul><li>kubectl 是 k8s 的客户端工具，可以使用命令行管理集群。</li><li>如果参考文档 <a href="https://www.kuboard.cn/install/install-k8s.html" target="_blank" rel="noopener">安装 Kubernetes 单Master节点</a>，您可以在 master 节点的 root 用户使用 kubectl 操作您的集群</li><li>您也可以尝试 <a href="https://www.kuboard.cn/install/install-kubectl.html" target="_blank" rel="noopener">从客户端电脑远程管理 Kubernetes</a></li></ul><h3 id="Kubernetes-部署"><a href="#Kubernetes-部署" class="headerlink" title="Kubernetes 部署"></a>Kubernetes 部署</h3><p>在 k8s 上进行部署前，首先需要了解一个基本概念 <strong>Deployment</strong></p><p><strong>Deployment</strong> 译名为 <strong>部署</strong>。在k8s中，通过发布 Deployment，可以创建应用程序 (docker image) 的实例 (docker container)，这个实例会被包含在称为 <strong>Pod</strong> 的概念中，<strong>Pod</strong> 是 k8s 中最小可管理单元。</p><p>在 k8s 集群中发布 Deployment 后，Deployment 将指示 k8s 如何创建和更新应用程序的实例，master 节点将应用程序实例调度到集群中的具体的节点上。</p><p>创建应用程序实例后，Kubernetes Deployment Controller 会持续监控这些实例。如果运行实例的 worker 节点关机或被删除，则 Kubernetes Deployment Controller 将在群集中资源最优的另一个 worker 节点上重新创建一个新的实例。<strong>这提供了一种自我修复机制来解决机器故障或维护问题。</strong></p><p>在容器编排之前的时代，各种安装脚本通常用于启动应用程序，但是不能够使应用程序从机器故障中恢复。通过创建应用程序实例并确保它们在集群节点中的运行实例个数，Kubernetes Deployment 提供了一种完全不同的方式来管理应用程序。</p><h2 id="在-Kubernetes-上部署第一个应用程序"><a href="#在-Kubernetes-上部署第一个应用程序" class="headerlink" title="在 Kubernetes 上部署第一个应用程序"></a>在 Kubernetes 上部署第一个应用程序</h2><p><img src="https://s1.ax1x.com/2020/05/04/YCLxJJ.png" alt="YCLxJJ.png"></p><p>​        Deployment 处于 master 节点上，通过发布 Deployment，master 节点会选择合适的 worker 节点创建 Container（即图中的正方体），Container 会被包含在 Pod （即蓝色圆圈）里。</p><h2 id="部署-nginx-Deployment"><a href="#部署-nginx-Deployment" class="headerlink" title="部署 nginx Deployment"></a>部署 nginx Deployment</h2><p><strong>创建 YAML 文件</strong></p><p>创建文件 nginx-deployment.yaml，内容如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1    <span class="token comment" spellcheck="true">#与k8s集群版本有关，使用 kubectl api-versions 即可查看当前集群支持的版本</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment    <span class="token comment" spellcheck="true">#该配置的类型，我们使用的是 Deployment</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#译名为元数据，即 Deployment 的一些基本属性和信息</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deployment    <span class="token comment" spellcheck="true">#Deployment 的名称</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组，目前不需要理解</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token comment" spellcheck="true">#为该Deployment设置key为app，value为nginx的标签</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#这是关于该Deployment的描述，可以理解为你期待该Deployment在k8s中如何使用</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1    </span><span class="token comment" spellcheck="true">#使用该Deployment创建一个应用程序实例</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#标签选择器，与上面的标签共同作用，目前不需要理解</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#选择包含标签app:nginx的资源</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">template</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#这是选择或创建的Pod的模板</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#Pod的元数据</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#Pod的标签，上面的selector即选择包含标签app:nginx的Pod</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#期望Pod实现的功能（即在pod中部署）</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#生成container，与docker中的container是同一种</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx    <span class="token comment" spellcheck="true">#container的名称</span>        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9    <span class="token comment" spellcheck="true">#使用镜像nginx:1.7.9创建container，该container默认80端口可访问</span></code></pre><p><strong>应用 YAML 文件</strong></p><pre class=" language-shell"><code class="language-shell">kubectl apply -f nginx-deployment.yaml</code></pre><p><strong>查看部署结果</strong></p><pre><code># 查看 Deploymentkubectl get deployments# 查看 Podkubectl get pods</code></pre><p>可分别查看到一个名为 nginx-deployment 的 Deployment 和一个名为 nginx-deployment-xxxxxxx 的 Pod</p><h1 id="2-查看Pods-Nodes"><a href="#2-查看Pods-Nodes" class="headerlink" title="2.查看Pods/Nodes"></a>2.查看Pods/Nodes</h1><h2 id="Kubernetes-Pods"><a href="#Kubernetes-Pods" class="headerlink" title="Kubernetes Pods"></a>Kubernetes Pods</h2><p>在 <a href="https://www.kuboard.cn/learning/k8s-basics/deploy-app.html" target="_blank" rel="noopener">部署第一个应用程序</a> 中创建 Deployment 后，k8s创建了一个 <strong>Pod（容器组）</strong> 来放置应用程序实例（container 容器）。</p><h2 id="Pods概述"><a href="#Pods概述" class="headerlink" title="Pods概述"></a>Pods概述</h2><p><img src="https://s1.ax1x.com/2020/05/04/YCjWdK.png" alt="YCjWdK.png"></p><p><strong>Pod 容器组</strong> 是一个k8s中一个抽象的概念，用于存放一组 container（可包含一个或多个 container 容器，即图上正方体)，以及这些 container （容器）的一些共享资源。这些资源包括：</p><ul><li>共享存储，称为卷(Volumes)，即图上紫色圆柱</li><li>网络，每个 Pod（容器组）在集群中有个唯一的 IP，pod（容器组）中的 container（容器）共享该IP地址</li><li>container（容器）的基本信息，例如容器的镜像版本，对外暴露的端口等</li></ul><blockquote><p>例如，Pod可能既包含带有Node.js应用程序的 container 容器，也包含另一个非 Node.js 的 container 容器，用于提供 Node.js webserver 要发布的数据。Pod中的容器共享 IP 地址和端口空间（同一 Pod 中的不同 container 端口不能相互冲突），始终位于同一位置并共同调度，并在同一节点上的共享上下文中运行。（同一个Pod内的容器可以使用 localhost + 端口号互相访问）。</p></blockquote><p>Pod（容器组）是 k8s 集群上的最基本的单元。当我们在 k8s 上创建 Deployment 时，会在集群上创建包含容器的 Pod (而不是直接创建容器)。每个Pod都与运行它的 worker 节点（Node）绑定，并保持在那里直到终止或被删除。如果节点（Node）发生故障，则会在群集中的其他可用节点（Node）上运行相同的 Pod（从同样的镜像创建 Container，使用同样的配置，IP 地址不同，Pod 名字</p><p>TIP</p><p>重要：</p><ul><li><p>Pod 是一组容器（可包含一个或多个应用程序容器），以及共享存储（卷 Volumes）、IP 地址和有关如何运行容器的信息。</p></li><li><p>如果多个容器紧密耦合并且需要共享磁盘等资源，则他们应该被部署在同一个Pod（容器组）中。</p></li></ul><h2 id="Node（节点）"><a href="#Node（节点）" class="headerlink" title="Node（节点）"></a>Node（节点）</h2><p>下图显示一个 Node（节点）上含有4个 Pod（容器组）</p><p><img src="https://s1.ax1x.com/2020/05/04/YCxkjA.png" alt="YCxkjA.png"></p><p>Pod（容器组）总是在 <strong>Node（节点）</strong> 上运行。Node（节点）是 kubernetes 集群中的计算机，可以是虚拟机或物理机。每个 Node（节点）都由 master 管理。一个 Node（节点）可以有多个Pod（容器组），kubernetes master 会根据每个 Node（节点）上可用资源的情况，自动调度 Pod（容器组）到最佳的 Node（节点）上。</p><p>每个 Kubernetes Node（节点）至少运行：</p><ul><li><p>Kubelet，负责 master 节点和 worker 节点之间通信的进程；管理 Pod（容器组）和 Pod（容器组）内运行的 Container（容器）。</p></li><li><p>容器运行环境（如Docker）负责下载镜像、创建和运行容器等。</p></li></ul><h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><p>在<a href="https://www.kuboard.cn/learning/k8s-basics/deploy-app.html" target="_blank" rel="noopener">部署第一个应用程序</a> 中，我们使用了 kubectl 命令行界面部署了 nginx 并且查看了 Deployment 和 Pod。kubectl 还有如下四个常用命令，在我们排查问题时可以提供帮助：</p><ul><li><strong>kubectl get</strong> - 显示资源列表</li></ul><pre class=" language-shell"><code class="language-shell"># kubectl get 资源类型#获取类型为Deployment的资源列表kubectl get deployments#获取类型为Pod的资源列表kubectl get pods#获取类型为Node的资源列表kubectl get nodes</code></pre><blockquote><p>名称空间</p><p>在命令后增加 <code>-A</code> 或 <code>--all-namespaces</code> 可查看所有 <a href="https://www.kuboard.cn/learning/k8s-intermediate/obj/namespaces.html" target="_blank" rel="noopener">名称空间中</a> 的对象，使用参数 <code>-n</code> 可查看指定名称空间的对象，例如</p><pre class=" language-shell"><code class="language-shell"># 查看所有名称空间的 Deploymentkubectl get deployments -Akubectl get deployments --all-namespaces# 查看 kube-system 名称空间的 Deploymentkubectl get deployments -n kube-system</code></pre><p>并非所有对象都在名称空间里)</p></blockquote><ul><li><strong>kubectl describe</strong> - 显示有关资源的详细信息</li></ul><pre class=" language-shell"><code class="language-shell"># kubectl describe 资源类型 资源名称#查看名称为nginx-XXXXXX的Pod的信息kubectl describe pod nginx-XXXXXX    #查看名称为nginx的Deployment的信息kubectl describe deployment nginx    </code></pre><ul><li><strong>kubectl logs</strong> - 查看pod中的容器的打印日志（和命令docker logs 类似）</li></ul><pre class=" language-shell"><code class="language-shell"># kubectl logs Pod名称#查看名称为nginx-pod-XXXXXXX的Pod内的容器打印的日志#本案例中的 nginx-pod 没有输出日志，所以您看到的结果是空的kubectl logs -f nginx-pod-XXXXXXX</code></pre><p>尝试在集群中执行一下上述的几个命令，可以了解如何通过 kubectl 操作 kubernetes 集群中的 Node、Pod、Container。</p><blockquote><p>TIP</p><p>Worker节点是k8s中的工作计算机，可能是VM或物理计算机，具体取决于群集。多个Pod可以在一个节点上运行。</p></blockquote><h1 id="3-公布应用程序"><a href="#3-公布应用程序" class="headerlink" title="3.公布应用程序"></a>3.公布应用程序</h1><h2 id="Kubernetes-Service（服务）概述"><a href="#Kubernetes-Service（服务）概述" class="headerlink" title="Kubernetes Service（服务）概述"></a>Kubernetes Service（服务）概述</h2><p>事实上，Pod（容器组）有自己的 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noopener">生命周期</a>。当 worker node（节点）故障时，节点上运行的 Pod（容器组）也会消失。然后，<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployment</a> 可以通过创建新的 Pod（容器组）来动态地将群集调整回原来的状态，以使应用程序保持运行。</p><p>举个例子，假设有一个图像处理后端程序，具有 3 个运行时副本。这 3 个副本是可以替换的（无状态应用），即使 Pod（容器组）消失并被重新创建，或者副本数由 3 增加到 5，前端系统也无需关注后端副本的变化。由于 Kubernetes 集群中每个 Pod（容器组）都有一个唯一的 IP 地址（即使是同一个 Node 上的不同 Pod），我们需要一种机制，为前端系统屏蔽后端系统的 Pod（容器组）在销毁、创建过程中所带来的 IP 地址的变化。</p><p>Kubernetes 中的 <strong>Service（服务）</strong> 提供了这样的一个抽象层，它选择具备某些特征的 Pod（容器组）并为它们定义一个访问方式。Service（服务）使 Pod（容器组）之间的相互依赖解耦（原本从一个 Pod 中访问另外一个 Pod，需要知道对方的 IP 地址）。一个 Service（服务）选定哪些 <strong>Pod（容器组）</strong> 通常由 <strong>LabelSelector(标签选择器)</strong> 来决定。</p><p>在创建Service的时候，通过设置配置文件中的 spec.type 字段的值，可以以不同方式向外部暴露应用程序：</p><ul><li><p><strong>ClusterIP</strong>（默认）</p><p>在群集中的内部IP上公布服务，这种方式的 Service（服务）只在集群内部可以访问到</p></li><li><p><strong>NodePort</strong></p><p>使用 NAT 在集群中每个的同一端口上公布服务。这种方式下，可以通过访问集群中任意节点+端口号的方式访问服务 <code>:</code>。此时 ClusterIP 的访问方式仍然可用。</p></li><li><p><strong>LoadBalancer</strong></p><p>在云环境中（需要云供应商可以支持）创建一个集群外部的负载均衡器，并为使用该负载均衡器的 IP 地址作为服务的访问地址。此时 ClusterIP 和 NodePort 的访问方式仍然可用。</p></li></ul><blockquote><p>TIP</p><p>Service是一个抽象层，它通过 LabelSelector 选择了一组 Pod（容器组），把这些 Pod 的指定端口公布到到集群外部，并支持负载均衡和服务发现。</p><ul><li>公布 Pod 的端口以使其可访问</li><li>在多个 Pod 间实现负载均衡</li><li>使用 Label 和 LabelSelector</li></ul></blockquote><h2 id="服务和标签"><a href="#服务和标签" class="headerlink" title="服务和标签"></a>服务和标签</h2><p>下图中有两个服务Service A(黄色虚线)和Service B(蓝色虚线) Service A 将请求转发到 IP 为 10.10.10.1 的Pod上， Service B 将请求转发到 IP 为 10.10.10.2、10.10.10.3、10.10.10.4 的Pod上。</p><p><img src="https://s1.ax1x.com/2020/05/04/YP1c6J.png" alt="YP1c6J.png"></p><p>Service 将外部请求路由到一组 Pod 中，它提供了一个抽象层，使得 Kubernetes 可以在不影响服务调用者的情况下，动态调度容器组（在容器组失效后重新创建容器组，增加或者减少同一个 Deployment 对应容器组的数量等）。</p><p>Service使用 <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels" target="_blank" rel="noopener">Labels、LabelSelector(标签和选择器)</a> 匹配一组 Pod。Labels（标签）是附加到 Kubernetes 对象的键/值对，其用途有多种：</p><ul><li>将 Kubernetes 对象（Node、Deployment、Pod、Service等）指派用于开发环境、测试环境或生产环境</li><li>嵌入版本标签，使用标签区别不同应用软件版本</li><li>使用标签对 Kubernetes 对象进行分类</li></ul><p>下图体现了 Labels（标签）和 LabelSelector（标签选择器）之间的关联关系</p><ul><li>Deployment B 含有 LabelSelector 为 app=B 通过此方式声明含有 app=B 标签的 Pod 与之关联</li><li>通过 Deployment B 创建的 Pod 包含标签为 app=B</li><li>Service B 通过标签选择器 app=B 选择可以路由的 Pod</li></ul><p><img src="https://s1.ax1x.com/2020/05/04/YP1X7t.png" alt="YP1X7t.png"></p><p>abels（标签）可以在创建 Kubernetes 对象时附加上去，也可以在创建之后再附加上去。任何时候都可以修改一个 Kubernetes 对象的 Labels（标签）</p><h2 id="练习：为-nginx-Deployment-创建一个-Service"><a href="#练习：为-nginx-Deployment-创建一个-Service" class="headerlink" title="练习：为 nginx Deployment 创建一个 Service"></a>练习：为 nginx Deployment 创建一个 Service</h2><ul><li><strong>创建nginx的Deployment中定义了Labels，如下：</strong></li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">metadata</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#译名为元数据，即Deployment的一些基本属性和信息</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deployment    <span class="token comment" spellcheck="true">#Deployment的名称</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token comment" spellcheck="true">#为该Deployment设置key为app，value为nginx的标签</span></code></pre><ul><li><strong>创建文件 nginx-service.yaml</strong></li></ul><pre class=" language-shell"><code class="language-shell">vim nginx-service.yaml</code></pre><ul><li><strong>文件内容如下：</strong></li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>service    <span class="token comment" spellcheck="true">#Service 的名称</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>         <span class="token comment" spellcheck="true">#Service 自己的标签</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token comment" spellcheck="true">#为该 Service 设置 key 为 app，value 为 nginx 的标签</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#这是关于该 Service 的定义，描述了 Service 如何选择 Pod，如何被访问</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#标签选择器</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token comment" spellcheck="true">#选择包含标签 app:nginx 的 Pod</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>port    <span class="token comment" spellcheck="true">#端口的名字</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP        <span class="token comment" spellcheck="true">#协议类型 TCP/UDP</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80            </span><span class="token comment" spellcheck="true">#集群内的其他容器组可通过 80 端口访问 Service</span>    <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">32600   </span><span class="token comment" spellcheck="true">#通过任意节点的 32600 端口访问 Service</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80    </span><span class="token comment" spellcheck="true">#将请求转发到匹配 Pod 的 80 端口</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort    <span class="token comment" spellcheck="true">#Serive的类型，ClusterIP/NodePort/LoaderBalancer</span></code></pre><ul><li><strong>执行命令</strong></li></ul><pre><code>kubectl apply -f nginx-service.yaml</code></pre><ul><li><p><strong>检查执行结果</strong></p><pre class=" language-shell"><code class="language-shell">kubectl get services -o wide</code></pre></li><li><p><strong>访问服务</strong></p></li></ul><pre class=" language-shell"><code class="language-shell">curl <任意节点的 IP>:32600</code></pre><h1 id="4-伸缩应用程序"><a href="#4-伸缩应用程序" class="headerlink" title="4.伸缩应用程序"></a>4.伸缩应用程序</h1><h2 id="Scaling（伸缩）应用程序"><a href="#Scaling（伸缩）应用程序" class="headerlink" title="Scaling（伸缩）应用程序"></a>Scaling（伸缩）应用程序</h2><p>在前面，我们创建了一个 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployment</a>，然后通过 <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">服务</a> 提供访问 Pod 的方式。我们发布的 Deployment 只创建了一个 Pod 来运行我们的应用程序。当流量增加时，我们需要对应用程序进行伸缩操作以满足系统性能需求。</p><p><strong>伸缩</strong> 的实现可以通过更改 nginx-deployment.yaml 文件中部署的 replicas（副本数）来完成</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2    </span><span class="token comment" spellcheck="true">#使用该Deployment创建两个应用程序实例</span></code></pre><h2 id="Scaling（伸缩）概述"><a href="#Scaling（伸缩）概述" class="headerlink" title="Scaling（伸缩）概述"></a>Scaling（伸缩）概述</h2><p>下图中，Service A 只将访问流量转发到 IP 为 10.0.0.5 的Pod上</p><p><img src="https://s1.ax1x.com/2020/05/04/YP8Wi6.png" alt="YP8Wi6.png"></p><p>​        修改了 Deployment 的 replicas 为 4 后，Kubernetes 又为该 Deployment 创建了 3 新的 Pod，这 4 个 Pod 有相同的标签。因此Service A通过标签选择器与新的 Pod建立了对应关系，将访问流量通过负载均衡在 4 个 Pod 之间进行转发。</p><p><img src="https://s1.ax1x.com/2020/05/04/YP84zD.png" alt="YP84zD.png"></p><blockquote><p>TIP</p><p>通过更改部署中的 replicas（副本数）来完成扩展</p></blockquote><h2 id="练习：将-nginx-Deployment-扩容到-4-个副本"><a href="#练习：将-nginx-Deployment-扩容到-4-个副本" class="headerlink" title="练习：将 nginx Deployment 扩容到 4 个副本"></a>练习：将 nginx Deployment 扩容到 4 个副本</h2><blockquote><p><strong>修改 nginx-deployment.yaml 文件</strong></p><p>将 replicas 修改为 4</p></blockquote><p><img src="https://s1.ax1x.com/2020/05/04/YPGpLj.png" alt="YPGpLj.png"></p><ul><li><strong>执行命令</strong></li></ul><pre class=" language-shell"><code class="language-shell">kubectl apply -f nginx-deployment.yaml</code></pre><ul><li><strong>查看结果</strong></li></ul><pre class=" language-shell"><code class="language-shell">watch kubectl get pods -o wide</code></pre><h1 id="5-执行滚动更新"><a href="#5-执行滚动更新" class="headerlink" title="5.执行滚动更新"></a>5.执行滚动更新</h1><h2 id="更新应用程序"><a href="#更新应用程序" class="headerlink" title="更新应用程序"></a>更新应用程序</h2><p>户期望应用程序始终可用，为此开发者/运维者在更新应用程序时要分多次完成。在 Kubernetes 中，这是通过 Rolling Update 滚动更新完成的。<strong>Rolling Update滚动更新</strong> 通过使用新版本的 Pod 逐步替代旧版本的 Pod 来实现 Deployment 的更新，从而实现零停机。新的 Pod 将在具有可用资源的 Node（节点）上进行调度。</p><blockquote><p>Kubernetes 更新多副本的 Deployment 的版本时，会逐步的创建新版本的 Pod，逐步的停止旧版本的 Pod，以便使应用一直处于可用状态。这个过程中，Service 能够监视 Pod 的状态，将流量始终转发到可用的 Pod 上。</p></blockquote><p>在上一个模块中，我们学习了将应用程序 Scale Up（扩容）为多个实例，这是执行更新而不影响应用程序可用性的前提（如果只有 1 个实例那还玩啥）。默认情况下，<strong>Rolling Update 滚动更新</strong> 过程中，Kubernetes 逐个使用新版本 Pod 替换旧版本 Pod（最大不可用 Pod 数为 1、最大新建 Pod 数也为 1）。这两个参数可以配置为数字或百分比。在Kubernetes 中，更新是版本化的，任何部署更新都可以恢复为以前的（稳定）版本。</p><h2 id="滚动更新概述"><a href="#滚动更新概述" class="headerlink" title="滚动更新概述"></a>滚动更新概述</h2><ol><li><p>原本 Service A 将流量负载均衡到 4 个旧版本的 Pod （当中的容器为 绿色）上</p><p><img src="https://s1.ax1x.com/2020/05/04/YPGrff.png" alt="YPGrff.png"></p></li><li><p>更新完 Deployment 部署文件中的镜像版本后，master 节点选择了一个 worker 节点，并根据新的镜像版本创建 Pod（紫色容器）。新 Pod 拥有唯一的新的 IP。同时，master 节点选择一个旧版本的 Pod 将其移除。</p><p>此时，Service A 将新 Pod 纳入到负载均衡中，将旧Pod移除</p><p><img src="https://s1.ax1x.com/2020/05/04/YPGRmj.png" alt="YPGRmj.png"></p></li><li><p>同步骤2，再创建一个新的 Pod 替换一个原有的 Pod</p><p><img src="https://s1.ax1x.com/2020/05/04/YPGIhV.png" alt="YPGIhV.png"></p></li><li><p>如此 Rolling Update 滚动更新，直到所有旧版本 Pod 均移除，新版本 Pod 也达到 Deployment 部署文件中定义的副本数，则滚动更新完成</p></li></ol><p><img src="https://s1.ax1x.com/2020/05/04/YPGLnJ.png" alt="YPGLnJ.png"></p><p>滚动更新允许以下操作：</p><ul><li>将应用程序从准上线环境升级到生产环境（通过更新容器镜像）</li><li>回滚到以前的版本</li><li>持续集成和持续交付应用程序，无需停机</li></ul><h2 id="练习：更新-nginx-Deployment"><a href="#练习：更新-nginx-Deployment" class="headerlink" title="练习：更新 nginx Deployment"></a>练习：更新 nginx Deployment</h2><p><strong>修改 nginx-deployment.yaml 文件</strong></p><p>修改文件中 image 镜像的标签，如下所示</p><p><img src="https://s1.ax1x.com/2020/05/04/YPJe4P.png" alt="YPJe4P.png"></p><ul><li><p><strong>执行命令</strong></p><pre class=" language-shell"><code class="language-shell">kubectl apply -f nginx-deployment.yaml</code></pre></li><li><p><strong>查看过程及结果</strong></p></li></ul><p>执行命令，可观察到 pod 逐个被替换的过程。</p><pre class=" language-shell"><code class="language-shell">watch kubectl get pods -l app=nginx</code></pre><h1 id="Kubernetes核心概念"><a href="#Kubernetes核心概念" class="headerlink" title="Kubernetes核心概念"></a>Kubernetes核心概念</h1><h2 id="什么是Kubernetes？"><a href="#什么是Kubernetes？" class="headerlink" title="什么是Kubernetes？"></a>什么是Kubernetes？</h2><p>Kubernetes（k8s）是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展。如果你曾经用过Docker容器技术部署容器，那么可以将Docker看成Kubernetes内部使用的低级别组件。Kubernetes不仅仅支持Docker，还支持Rocket，这是另一种容器技术。 使用Kubernetes可以：</p><ul><li>自动化容器的部署和复制</li><li>随时扩展或收缩容器规模</li><li>将容器组织成组，并且提供容器间的负载均衡</li><li>很容易地升级应用程序容器的新版本</li><li>提供容器弹性，如果容器失效就替换它，等等…</li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>集群是一组节点，这些节点可以是物理服务器或者虚拟机，之上安装了Kubernetes平台。下图展示这样的集群。注意该图为了强调核心概念有所简化。这里可以看到一个典型的Kubernetes架构图。</p><p><img src="https://s1.ax1x.com/2020/05/04/YPJyU1.png" alt="YPJyU1.png"></p><p>上图可以看到如下组件，使用特别的图标表示Service和Label：</p><ul><li>PodContainer（容器）</li><li>Label(<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAhCAYAAAC4JqlRAAAKQWlDQ1BJQ0MgUHJvZmlsZQAASA2dlndUU9kWh8+9N73QEiIgJfQaegkg0jtIFQRRiUmAUAKGhCZ2RAVGFBEpVmRUwAFHhyJjRRQLg4Ji1wnyEFDGwVFEReXdjGsJ7601896a/cdZ39nnt9fZZ+9917oAUPyCBMJ0WAGANKFYFO7rwVwSE8vE9wIYEAEOWAHA4WZmBEf4RALU/L09mZmoSMaz9u4ugGS72yy/UCZz1v9/kSI3QyQGAApF1TY8fiYX5QKUU7PFGTL/BMr0lSkyhjEyFqEJoqwi48SvbPan5iu7yZiXJuShGlnOGbw0noy7UN6aJeGjjAShXJgl4GejfAdlvVRJmgDl9yjT0/icTAAwFJlfzOcmoWyJMkUUGe6J8gIACJTEObxyDov5OWieAHimZ+SKBIlJYqYR15hp5ejIZvrxs1P5YjErlMNN4Yh4TM/0tAyOMBeAr2+WRQElWW2ZaJHtrRzt7VnW5mj5v9nfHn5T/T3IevtV8Sbsz55BjJ5Z32zsrC+9FgD2JFqbHbO+lVUAtG0GQOXhrE/vIADyBQC03pzzHoZsXpLE4gwnC4vs7GxzAZ9rLivoN/ufgm/Kv4Y595nL7vtWO6YXP4EjSRUzZUXlpqemS0TMzAwOl89k/fcQ/+PAOWnNycMsnJ/AF/GF6FVR6JQJhIlou4U8gViQLmQKhH/V4X8YNicHGX6daxRodV8AfYU5ULhJB8hvPQBDIwMkbj96An3rWxAxCsi+vGitka9zjzJ6/uf6Hwtcim7hTEEiU+b2DI9kciWiLBmj34RswQISkAd0oAo0gS4wAixgDRyAM3AD3iAAhIBIEAOWAy5IAmlABLJBPtgACkEx2AF2g2pwANSBetAEToI2cAZcBFfADXALDIBHQAqGwUswAd6BaQiC8BAVokGqkBakD5lC1hAbWgh5Q0FQOBQDxUOJkBCSQPnQJqgYKoOqoUNQPfQjdBq6CF2D+qAH0CA0Bv0BfYQRmALTYQ3YALaA2bA7HAhHwsvgRHgVnAcXwNvhSrgWPg63whfhG/AALIVfwpMIQMgIA9FGWAgb8URCkFgkAREha5EipAKpRZqQDqQbuY1IkXHkAwaHoWGYGBbGGeOHWYzhYlZh1mJKMNWYY5hWTBfmNmYQM4H5gqVi1bGmWCesP3YJNhGbjS3EVmCPYFuwl7ED2GHsOxwOx8AZ4hxwfrgYXDJuNa4Etw/XjLuA68MN4SbxeLwq3hTvgg/Bc/BifCG+Cn8cfx7fjx/GvyeQCVoEa4IPIZYgJGwkVBAaCOcI/YQRwjRRgahPdCKGEHnEXGIpsY7YQbxJHCZOkxRJhiQXUiQpmbSBVElqIl0mPSa9IZPJOmRHchhZQF5PriSfIF8lD5I/UJQoJhRPShxFQtlOOUq5QHlAeUOlUg2obtRYqpi6nVpPvUR9Sn0vR5Mzl/OX48mtk6uRa5Xrl3slT5TXl3eXXy6fJ18hf0r+pvy4AlHBQMFTgaOwVqFG4bTCPYVJRZqilWKIYppiiWKD4jXFUSW8koGStxJPqUDpsNIlpSEaQtOledK4tE20Otpl2jAdRzek+9OT6cX0H+i99AllJWVb5SjlHOUa5bPKUgbCMGD4M1IZpYyTjLuMj/M05rnP48/bNq9pXv+8KZX5Km4qfJUilWaVAZWPqkxVb9UU1Z2qbapP1DBqJmphatlq+9Uuq43Pp893ns+dXzT/5PyH6rC6iXq4+mr1w+o96pMamhq+GhkaVRqXNMY1GZpumsma5ZrnNMe0aFoLtQRa5VrntV4wlZnuzFRmJbOLOaGtru2nLdE+pN2rPa1jqLNYZ6NOs84TXZIuWzdBt1y3U3dCT0svWC9fr1HvoT5Rn62fpL9Hv1t/ysDQINpgi0GbwaihiqG/YZ5ho+FjI6qRq9Eqo1qjO8Y4Y7ZxivE+41smsImdSZJJjclNU9jU3lRgus+0zwxr5mgmNKs1u8eisNxZWaxG1qA5wzzIfKN5m/krCz2LWIudFt0WXyztLFMt6ywfWSlZBVhttOqw+sPaxJprXWN9x4Zq42Ozzqbd5rWtqS3fdr/tfTuaXbDdFrtOu8/2DvYi+yb7MQc9h3iHvQ732HR2KLuEfdUR6+jhuM7xjOMHJ3snsdNJp9+dWc4pzg3OowsMF/AX1C0YctFx4bgccpEuZC6MX3hwodRV25XjWuv6zE3Xjed2xG3E3dg92f24+ysPSw+RR4vHlKeT5xrPC16Il69XkVevt5L3Yu9q76c+Oj6JPo0+E752vqt9L/hh/QL9dvrd89fw5/rX+08EOASsCegKpARGBFYHPgsyCRIFdQTDwQHBu4IfL9JfJFzUFgJC/EN2hTwJNQxdFfpzGC4sNKwm7Hm4VXh+eHcELWJFREPEu0iPyNLIR4uNFksWd0bJR8VF1UdNRXtFl0VLl1gsWbPkRoxajCCmPRYfGxV7JHZyqffS3UuH4+ziCuPuLjNclrPs2nK15anLz66QX8FZcSoeGx8d3xD/iRPCqeVMrvRfuXflBNeTu4f7kufGK+eN8V34ZfyRBJeEsoTRRJfEXYljSa5JFUnjAk9BteB1sl/ygeSplJCUoykzqdGpzWmEtPi000IlYYqwK10zPSe9L8M0ozBDuspp1e5VE6JA0ZFMKHNZZruYjv5M9UiMJJslg1kLs2qy3mdHZZ/KUcwR5vTkmuRuyx3J88n7fjVmNXd1Z752/ob8wTXuaw6thdauXNu5Tnddwbrh9b7rj20gbUjZ8MtGy41lG99uit7UUaBRsL5gaLPv5sZCuUJR4b0tzlsObMVsFWzt3WazrWrblyJe0fViy+KK4k8l3JLr31l9V/ndzPaE7b2l9qX7d+B2CHfc3em681iZYlle2dCu4F2t5czyovK3u1fsvlZhW3FgD2mPZI+0MqiyvUqvakfVp+qk6oEaj5rmvep7t+2d2sfb17/fbX/TAY0DxQc+HhQcvH/I91BrrUFtxWHc4azDz+ui6rq/Z39ff0TtSPGRz0eFR6XHwo911TvU1zeoN5Q2wo2SxrHjccdv/eD1Q3sTq+lQM6O5+AQ4ITnx4sf4H++eDDzZeYp9qukn/Z/2ttBailqh1tzWibakNml7THvf6YDTnR3OHS0/m/989Iz2mZqzymdLz5HOFZybOZ93fvJCxoXxi4kXhzpXdD66tOTSna6wrt7LgZevXvG5cqnbvfv8VZerZ645XTt9nX297Yb9jdYeu56WX+x+aem172296XCz/ZbjrY6+BX3n+l37L972un3ljv+dGwOLBvruLr57/17cPel93v3RB6kPXj/Mejj9aP1j7OOiJwpPKp6qP6391fjXZqm99Oyg12DPs4hnj4a4Qy//lfmvT8MFz6nPK0a0RupHrUfPjPmM3Xqx9MXwy4yX0+OFvyn+tveV0auffnf7vWdiycTwa9HrmT9K3qi+OfrW9m3nZOjk03dp76anit6rvj/2gf2h+2P0x5Hp7E/4T5WfjT93fAn88ngmbWbm3/eE8/syOll+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB1WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KOXS2agAAAWdJREFUWAntk91NhUAUhC8WYB92YQEWYQhWYLQKW4AnOrAA+7AGn3khAXeu+ZIJOfws8mAim9x7dmfnzAy7cLmc4zyB/34CxdwBtG172/f9+3R/HMfPsiyfhDdN8zoMw12aflVV9TLlblmHAeq6fi6K4m1NIAW59qcgI1ww1mv1JiIk84cIn2IYuynYlDu3DgM4WeL8HGeO4d4QqwEwWqq/CXFIAIXbGyJ8CZPYR9K8l3Du4CoIpH6wSOuwE0AcYzcFg+M1DNB13aOTcucYbgkRXoEMEck1dz4BXAsM3mwAEbyRhtyKoWuBSSu8AkycCJZbMXathOklv47FAGJ440/Lsf+LV+BWPIljW+Y8gPeDqX9zAJFdROu1gZH3gdGbFUBNLoZIVDFyPpjzswOo2UVdjDlGzgODQ90VQM0ujpgqRr4P5jzmuwNIwE20xshxMO1HY/UzjJrAXNzn0T7YWc8TOE/gz53AN34Bn5aWTdpfAAAAAElFTkSuQmCC" alt="label">))（标签）</li><li>Replication Controller（复制控制器）</li><li>Service（<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAoCAYAAACSN4jeAAAKQWlDQ1BJQ0MgUHJvZmlsZQAASA2dlndUU9kWh8+9N73QEiIgJfQaegkg0jtIFQRRiUmAUAKGhCZ2RAVGFBEpVmRUwAFHhyJjRRQLg4Ji1wnyEFDGwVFEReXdjGsJ7601896a/cdZ39nnt9fZZ+9917oAUPyCBMJ0WAGANKFYFO7rwVwSE8vE9wIYEAEOWAHA4WZmBEf4RALU/L09mZmoSMaz9u4ugGS72yy/UCZz1v9/kSI3QyQGAApF1TY8fiYX5QKUU7PFGTL/BMr0lSkyhjEyFqEJoqwi48SvbPan5iu7yZiXJuShGlnOGbw0noy7UN6aJeGjjAShXJgl4GejfAdlvVRJmgDl9yjT0/icTAAwFJlfzOcmoWyJMkUUGe6J8gIACJTEObxyDov5OWieAHimZ+SKBIlJYqYR15hp5ejIZvrxs1P5YjErlMNN4Yh4TM/0tAyOMBeAr2+WRQElWW2ZaJHtrRzt7VnW5mj5v9nfHn5T/T3IevtV8Sbsz55BjJ5Z32zsrC+9FgD2JFqbHbO+lVUAtG0GQOXhrE/vIADyBQC03pzzHoZsXpLE4gwnC4vs7GxzAZ9rLivoN/ufgm/Kv4Y595nL7vtWO6YXP4EjSRUzZUXlpqemS0TMzAwOl89k/fcQ/+PAOWnNycMsnJ/AF/GF6FVR6JQJhIlou4U8gViQLmQKhH/V4X8YNicHGX6daxRodV8AfYU5ULhJB8hvPQBDIwMkbj96An3rWxAxCsi+vGitka9zjzJ6/uf6Hwtcim7hTEEiU+b2DI9kciWiLBmj34RswQISkAd0oAo0gS4wAixgDRyAM3AD3iAAhIBIEAOWAy5IAmlABLJBPtgACkEx2AF2g2pwANSBetAEToI2cAZcBFfADXALDIBHQAqGwUswAd6BaQiC8BAVokGqkBakD5lC1hAbWgh5Q0FQOBQDxUOJkBCSQPnQJqgYKoOqoUNQPfQjdBq6CF2D+qAH0CA0Bv0BfYQRmALTYQ3YALaA2bA7HAhHwsvgRHgVnAcXwNvhSrgWPg63whfhG/AALIVfwpMIQMgIA9FGWAgb8URCkFgkAREha5EipAKpRZqQDqQbuY1IkXHkAwaHoWGYGBbGGeOHWYzhYlZh1mJKMNWYY5hWTBfmNmYQM4H5gqVi1bGmWCesP3YJNhGbjS3EVmCPYFuwl7ED2GHsOxwOx8AZ4hxwfrgYXDJuNa4Etw/XjLuA68MN4SbxeLwq3hTvgg/Bc/BifCG+Cn8cfx7fjx/GvyeQCVoEa4IPIZYgJGwkVBAaCOcI/YQRwjRRgahPdCKGEHnEXGIpsY7YQbxJHCZOkxRJhiQXUiQpmbSBVElqIl0mPSa9IZPJOmRHchhZQF5PriSfIF8lD5I/UJQoJhRPShxFQtlOOUq5QHlAeUOlUg2obtRYqpi6nVpPvUR9Sn0vR5Mzl/OX48mtk6uRa5Xrl3slT5TXl3eXXy6fJ18hf0r+pvy4AlHBQMFTgaOwVqFG4bTCPYVJRZqilWKIYppiiWKD4jXFUSW8koGStxJPqUDpsNIlpSEaQtOledK4tE20Otpl2jAdRzek+9OT6cX0H+i99AllJWVb5SjlHOUa5bPKUgbCMGD4M1IZpYyTjLuMj/M05rnP48/bNq9pXv+8KZX5Km4qfJUilWaVAZWPqkxVb9UU1Z2qbapP1DBqJmphatlq+9Uuq43Pp893ns+dXzT/5PyH6rC6iXq4+mr1w+o96pMamhq+GhkaVRqXNMY1GZpumsma5ZrnNMe0aFoLtQRa5VrntV4wlZnuzFRmJbOLOaGtru2nLdE+pN2rPa1jqLNYZ6NOs84TXZIuWzdBt1y3U3dCT0svWC9fr1HvoT5Rn62fpL9Hv1t/ysDQINpgi0GbwaihiqG/YZ5ho+FjI6qRq9Eqo1qjO8Y4Y7ZxivE+41smsImdSZJJjclNU9jU3lRgus+0zwxr5mgmNKs1u8eisNxZWaxG1qA5wzzIfKN5m/krCz2LWIudFt0WXyztLFMt6ywfWSlZBVhttOqw+sPaxJprXWN9x4Zq42Ozzqbd5rWtqS3fdr/tfTuaXbDdFrtOu8/2DvYi+yb7MQc9h3iHvQ732HR2KLuEfdUR6+jhuM7xjOMHJ3snsdNJp9+dWc4pzg3OowsMF/AX1C0YctFx4bgccpEuZC6MX3hwodRV25XjWuv6zE3Xjed2xG3E3dg92f24+ysPSw+RR4vHlKeT5xrPC16Il69XkVevt5L3Yu9q76c+Oj6JPo0+E752vqt9L/hh/QL9dvrd89fw5/rX+08EOASsCegKpARGBFYHPgsyCRIFdQTDwQHBu4IfL9JfJFzUFgJC/EN2hTwJNQxdFfpzGC4sNKwm7Hm4VXh+eHcELWJFREPEu0iPyNLIR4uNFksWd0bJR8VF1UdNRXtFl0VLl1gsWbPkRoxajCCmPRYfGxV7JHZyqffS3UuH4+ziCuPuLjNclrPs2nK15anLz66QX8FZcSoeGx8d3xD/iRPCqeVMrvRfuXflBNeTu4f7kufGK+eN8V34ZfyRBJeEsoTRRJfEXYljSa5JFUnjAk9BteB1sl/ygeSplJCUoykzqdGpzWmEtPi000IlYYqwK10zPSe9L8M0ozBDuspp1e5VE6JA0ZFMKHNZZruYjv5M9UiMJJslg1kLs2qy3mdHZZ/KUcwR5vTkmuRuyx3J88n7fjVmNXd1Z752/ob8wTXuaw6thdauXNu5Tnddwbrh9b7rj20gbUjZ8MtGy41lG99uit7UUaBRsL5gaLPv5sZCuUJR4b0tzlsObMVsFWzt3WazrWrblyJe0fViy+KK4k8l3JLr31l9V/ndzPaE7b2l9qX7d+B2CHfc3em681iZYlle2dCu4F2t5czyovK3u1fsvlZhW3FgD2mPZI+0MqiyvUqvakfVp+qk6oEaj5rmvep7t+2d2sfb17/fbX/TAY0DxQc+HhQcvH/I91BrrUFtxWHc4azDz+ui6rq/Z39ff0TtSPGRz0eFR6XHwo911TvU1zeoN5Q2wo2SxrHjccdv/eD1Q3sTq+lQM6O5+AQ4ITnx4sf4H++eDDzZeYp9qukn/Z/2ttBailqh1tzWibakNml7THvf6YDTnR3OHS0/m/989Iz2mZqzymdLz5HOFZybOZ93fvJCxoXxi4kXhzpXdD66tOTSna6wrt7LgZevXvG5cqnbvfv8VZerZ645XTt9nX297Yb9jdYeu56WX+x+aem172296XCz/ZbjrY6+BX3n+l37L972un3ljv+dGwOLBvruLr57/17cPel93v3RB6kPXj/Mejj9aP1j7OOiJwpPKp6qP6391fjXZqm99Oyg12DPs4hnj4a4Qy//lfmvT8MFz6nPK0a0RupHrUfPjPmM3Xqx9MXwy4yX0+OFvyn+tveV0auffnf7vWdiycTwa9HrmT9K3qi+OfrW9m3nZOjk03dp76anit6rvj/2gf2h+2P0x5Hp7E/4T5WfjT93fAn88ngmbWbm3/eE8/syOll+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB1WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KOXS2agAAAtlJREFUWAntV79rIkEUfv5qJKKW11hYCFdeI1hbeSCYJiFWQQwYFfO3qAlioSgSA4KFdQ61sbOKjUXAwFncdSpyBvx1Owsjs+7bvZ3du73jcEH2ve99897n25nZWYDTderAn+2AhaavVqsvm83mo+BbKWbW3Wq1bu12+5fr6+vPtKadGsL9w9nZmf3q6oqBzDGfnp6sq9XqE1vN9O6wxdXs/1tYr9eDQqEAs9lMrQlcMXaOcQ2k5Hw+T02o1+uifXd3d8D0GoYeZafTQetut1sU5wENCXt7e0Nr3d/fozgPaEgYTyFeriFhSnveX59jwsaINoJdEChBA6i7Y7Q46Q7tEGvTuAYNKEWXMFqUCjrOnM1mRYjyjuNafG5htFg6nVbMb7PZIJFIiPGHhwdFnlqAS1ixWBRzRSIRcDgcannB5XJBKBQC4cQCtVpNlYsFNQtrt9uw2+3A5/NBIBDAcsmwYDAIfr8f5vM5DAYDWVwNUBT2+voKpEPkH4/HY5hOp0Ae0fn5uVo+WSwajYLb7YbhcCjmWK/XQDbg0Wgk47IA+q6k84gQ2TlCJzWbQIstHADFlzzpOr263S6Qn9ICknVsMpnQsZL77e2txOd1crkcOuT5+RnFZcL6/T5KLJVKKK4VfHx8RKmLxQLFZcJQ1m8AhTM9VxaZsFgshiZQ27fIIZFc9DyGJbi8vMRg8Hg8KC4T5vV6UaLSvkUWyn6/F8eQEyy7cI4TWSyHj7JDKBwOH2zWQPtLV0qz2YR4PM7yJbaSiOVyCcIXl4RLHLoAWq0WXFxcyOIsIOsYG1QTxfKO7UqlcgxJ/F+JImRVYZJsJjuGhGUyGVQunQpoUCNoSBjZApxOp6RUMpmU+HoddPLzJLu5ueGha+Ya6pjmKjqI/6yww6MUzlp7Yf/ZNRqNHzr+oKEh7+/vTuFI9Z1NItmKy+XyVyG4YQlm2MKb41sqlQqZUetUw/QO/AQEcsyxO1XX/gAAAABJRU5ErkJggg==" alt="enter image description here">）（服务）</li><li>Node（节点）</li><li>Kubernetes Master（Kubernetes主节点）</li></ul><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">Pod</a>（上图绿色方框）安排在节点上，包含一组容器和卷。同一个Pod里的容器共享同一个网络命名空间，可以使用localhost互相通信。Pod是短暂的，不是持续性实体。你可能会有这些问题：</p><ul><li>如果Pod是短暂的，那么我怎么才能持久化容器数据使其能够跨重启而存在呢？ 是的，Kubernetes支持 <strong><em>卷</em></strong> 的概念，因此可以使用持久化的卷类型。</li><li>是否手动创建Pod，如果想要创建同一个容器的多份拷贝，需要一个个分别创建出来么？可以手动创建单个Pod，但是也可以使用Replication Controller使用Pod模板创建出多份拷贝，下文会详细介绍。</li><li>如果Pod是短暂的，那么重启时IP地址可能会改变，那么怎么才能从前端容器正确可靠地指向后台容器呢？这时可以使用Service，下文会详细介绍。</li></ul><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>正如图所示，一些Pod有Label（<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAhCAYAAAC4JqlRAAAKQWlDQ1BJQ0MgUHJvZmlsZQAASA2dlndUU9kWh8+9N73QEiIgJfQaegkg0jtIFQRRiUmAUAKGhCZ2RAVGFBEpVmRUwAFHhyJjRRQLg4Ji1wnyEFDGwVFEReXdjGsJ7601896a/cdZ39nnt9fZZ+9917oAUPyCBMJ0WAGANKFYFO7rwVwSE8vE9wIYEAEOWAHA4WZmBEf4RALU/L09mZmoSMaz9u4ugGS72yy/UCZz1v9/kSI3QyQGAApF1TY8fiYX5QKUU7PFGTL/BMr0lSkyhjEyFqEJoqwi48SvbPan5iu7yZiXJuShGlnOGbw0noy7UN6aJeGjjAShXJgl4GejfAdlvVRJmgDl9yjT0/icTAAwFJlfzOcmoWyJMkUUGe6J8gIACJTEObxyDov5OWieAHimZ+SKBIlJYqYR15hp5ejIZvrxs1P5YjErlMNN4Yh4TM/0tAyOMBeAr2+WRQElWW2ZaJHtrRzt7VnW5mj5v9nfHn5T/T3IevtV8Sbsz55BjJ5Z32zsrC+9FgD2JFqbHbO+lVUAtG0GQOXhrE/vIADyBQC03pzzHoZsXpLE4gwnC4vs7GxzAZ9rLivoN/ufgm/Kv4Y595nL7vtWO6YXP4EjSRUzZUXlpqemS0TMzAwOl89k/fcQ/+PAOWnNycMsnJ/AF/GF6FVR6JQJhIlou4U8gViQLmQKhH/V4X8YNicHGX6daxRodV8AfYU5ULhJB8hvPQBDIwMkbj96An3rWxAxCsi+vGitka9zjzJ6/uf6Hwtcim7hTEEiU+b2DI9kciWiLBmj34RswQISkAd0oAo0gS4wAixgDRyAM3AD3iAAhIBIEAOWAy5IAmlABLJBPtgACkEx2AF2g2pwANSBetAEToI2cAZcBFfADXALDIBHQAqGwUswAd6BaQiC8BAVokGqkBakD5lC1hAbWgh5Q0FQOBQDxUOJkBCSQPnQJqgYKoOqoUNQPfQjdBq6CF2D+qAH0CA0Bv0BfYQRmALTYQ3YALaA2bA7HAhHwsvgRHgVnAcXwNvhSrgWPg63whfhG/AALIVfwpMIQMgIA9FGWAgb8URCkFgkAREha5EipAKpRZqQDqQbuY1IkXHkAwaHoWGYGBbGGeOHWYzhYlZh1mJKMNWYY5hWTBfmNmYQM4H5gqVi1bGmWCesP3YJNhGbjS3EVmCPYFuwl7ED2GHsOxwOx8AZ4hxwfrgYXDJuNa4Etw/XjLuA68MN4SbxeLwq3hTvgg/Bc/BifCG+Cn8cfx7fjx/GvyeQCVoEa4IPIZYgJGwkVBAaCOcI/YQRwjRRgahPdCKGEHnEXGIpsY7YQbxJHCZOkxRJhiQXUiQpmbSBVElqIl0mPSa9IZPJOmRHchhZQF5PriSfIF8lD5I/UJQoJhRPShxFQtlOOUq5QHlAeUOlUg2obtRYqpi6nVpPvUR9Sn0vR5Mzl/OX48mtk6uRa5Xrl3slT5TXl3eXXy6fJ18hf0r+pvy4AlHBQMFTgaOwVqFG4bTCPYVJRZqilWKIYppiiWKD4jXFUSW8koGStxJPqUDpsNIlpSEaQtOledK4tE20Otpl2jAdRzek+9OT6cX0H+i99AllJWVb5SjlHOUa5bPKUgbCMGD4M1IZpYyTjLuMj/M05rnP48/bNq9pXv+8KZX5Km4qfJUilWaVAZWPqkxVb9UU1Z2qbapP1DBqJmphatlq+9Uuq43Pp893ns+dXzT/5PyH6rC6iXq4+mr1w+o96pMamhq+GhkaVRqXNMY1GZpumsma5ZrnNMe0aFoLtQRa5VrntV4wlZnuzFRmJbOLOaGtru2nLdE+pN2rPa1jqLNYZ6NOs84TXZIuWzdBt1y3U3dCT0svWC9fr1HvoT5Rn62fpL9Hv1t/ysDQINpgi0GbwaihiqG/YZ5ho+FjI6qRq9Eqo1qjO8Y4Y7ZxivE+41smsImdSZJJjclNU9jU3lRgus+0zwxr5mgmNKs1u8eisNxZWaxG1qA5wzzIfKN5m/krCz2LWIudFt0WXyztLFMt6ywfWSlZBVhttOqw+sPaxJprXWN9x4Zq42Ozzqbd5rWtqS3fdr/tfTuaXbDdFrtOu8/2DvYi+yb7MQc9h3iHvQ732HR2KLuEfdUR6+jhuM7xjOMHJ3snsdNJp9+dWc4pzg3OowsMF/AX1C0YctFx4bgccpEuZC6MX3hwodRV25XjWuv6zE3Xjed2xG3E3dg92f24+ysPSw+RR4vHlKeT5xrPC16Il69XkVevt5L3Yu9q76c+Oj6JPo0+E752vqt9L/hh/QL9dvrd89fw5/rX+08EOASsCegKpARGBFYHPgsyCRIFdQTDwQHBu4IfL9JfJFzUFgJC/EN2hTwJNQxdFfpzGC4sNKwm7Hm4VXh+eHcELWJFREPEu0iPyNLIR4uNFksWd0bJR8VF1UdNRXtFl0VLl1gsWbPkRoxajCCmPRYfGxV7JHZyqffS3UuH4+ziCuPuLjNclrPs2nK15anLz66QX8FZcSoeGx8d3xD/iRPCqeVMrvRfuXflBNeTu4f7kufGK+eN8V34ZfyRBJeEsoTRRJfEXYljSa5JFUnjAk9BteB1sl/ygeSplJCUoykzqdGpzWmEtPi000IlYYqwK10zPSe9L8M0ozBDuspp1e5VE6JA0ZFMKHNZZruYjv5M9UiMJJslg1kLs2qy3mdHZZ/KUcwR5vTkmuRuyx3J88n7fjVmNXd1Z752/ob8wTXuaw6thdauXNu5Tnddwbrh9b7rj20gbUjZ8MtGy41lG99uit7UUaBRsL5gaLPv5sZCuUJR4b0tzlsObMVsFWzt3WazrWrblyJe0fViy+KK4k8l3JLr31l9V/ndzPaE7b2l9qX7d+B2CHfc3em681iZYlle2dCu4F2t5czyovK3u1fsvlZhW3FgD2mPZI+0MqiyvUqvakfVp+qk6oEaj5rmvep7t+2d2sfb17/fbX/TAY0DxQc+HhQcvH/I91BrrUFtxWHc4azDz+ui6rq/Z39ff0TtSPGRz0eFR6XHwo911TvU1zeoN5Q2wo2SxrHjccdv/eD1Q3sTq+lQM6O5+AQ4ITnx4sf4H++eDDzZeYp9qukn/Z/2ttBailqh1tzWibakNml7THvf6YDTnR3OHS0/m/989Iz2mZqzymdLz5HOFZybOZ93fvJCxoXxi4kXhzpXdD66tOTSna6wrt7LgZevXvG5cqnbvfv8VZerZ645XTt9nX297Yb9jdYeu56WX+x+aem172296XCz/ZbjrY6+BX3n+l37L972un3ljv+dGwOLBvruLr57/17cPel93v3RB6kPXj/Mejj9aP1j7OOiJwpPKp6qP6391fjXZqm99Oyg12DPs4hnj4a4Qy//lfmvT8MFz6nPK0a0RupHrUfPjPmM3Xqx9MXwy4yX0+OFvyn+tveV0auffnf7vWdiycTwa9HrmT9K3qi+OfrW9m3nZOjk03dp76anit6rvj/2gf2h+2P0x5Hp7E/4T5WfjT93fAn88ngmbWbm3/eE8/syOll+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB1WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KOXS2agAAAWdJREFUWAntk91NhUAUhC8WYB92YQEWYQhWYLQKW4AnOrAA+7AGn3khAXeu+ZIJOfws8mAim9x7dmfnzAy7cLmc4zyB/34CxdwBtG172/f9+3R/HMfPsiyfhDdN8zoMw12aflVV9TLlblmHAeq6fi6K4m1NIAW59qcgI1ww1mv1JiIk84cIn2IYuynYlDu3DgM4WeL8HGeO4d4QqwEwWqq/CXFIAIXbGyJ8CZPYR9K8l3Du4CoIpH6wSOuwE0AcYzcFg+M1DNB13aOTcucYbgkRXoEMEck1dz4BXAsM3mwAEbyRhtyKoWuBSSu8AkycCJZbMXathOklv47FAGJ440/Lsf+LV+BWPIljW+Y8gPeDqX9zAJFdROu1gZH3gdGbFUBNLoZIVDFyPpjzswOo2UVdjDlGzgODQ90VQM0ujpgqRr4P5jzmuwNIwE20xshxMO1HY/UzjJrAXNzn0T7YWc8TOE/gz53AN34Bn5aWTdpfAAAAAElFTkSuQmCC" alt="enter image description here">）。一个Label是attach到Pod的一对键/值对，用来传递用户定义的属性。比如，你可能创建了一个”tier”和“app”标签，通过Label（<strong>tier=frontend, app=myapp</strong>）来标记前端Pod容器，使用Label（<strong>tier=backend, app=myapp</strong>）标记后台Pod。然后可以使用 <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" target="_blank" rel="noopener">Selectors</a> 选择带有特定Label的Pod，并且将Service或者Replication Controller应用到上面。</p><h2 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h2><p><em>是否手动创建Pod，如果想要创建同一个容器的多份拷贝，需要一个个分别创建出来么，能否将Pods划到逻辑组里？</em></p><p>Replication Controller确保任意时间都有指定数量的Pod“副本”在运行。如果为某个Pod创建了Replication Controller并且指定3个副本，它会创建3个Pod，并且持续监控它们。如果某个Pod不响应，那么Replication Controller会替换它，保持总数为3.如下面的动画所示：</p><p><img src="https://s1.ax1x.com/2020/05/04/YPJoVA.png" alt="YPJoVA.png"></p><p>如果之前不响应的Pod恢复了，现在就有4个Pod了，那么Replication Controller会将其中一个终止保持总数为3。如果在运行中将副本总数改为5，Replication Controller会立刻启动2个新Pod，保证总数为5。还可以按照这样的方式缩小Pod，这个特性在执行滚动 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#rolling_updates" target="_blank" rel="noopener">升级</a> 时很有用。</p><p>当创建Replication Controller时，需要指定两个东西：</p><ol><li>Pod模板：用来创建Pod副本的模板</li><li>Label：Replication Controller需要监控的Pod的标签。现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。</li></ol><p>TIP</p><p>最新 Kubernetes 版本里，推荐使用 Deployment</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p><em>如果Pods是短暂的，那么重启时IP地址可能会改变，怎么才能从前端容器正确可靠地指向后台容器呢？</em> <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Service</a> <strong>抽象</strong> 现在，假定有2个后台Pod，并且定义后台Service的名称为‘backend-service’，label选择器为(tier=backend, app=myapp) 的Service会完成如下两件重要的事情：</p><ul><li>会为Service创建一个本地集群的DNS入口，因此前端Pod只需要DNS查找主机名为 ‘backend-service’，就能够解析出前端应用程序可用的IP地址。</li><li>现在前端已经得到了后台服务的IP地址，但是它应该访问2个后台Pod的哪一个呢？Service在这2个后台Pod之间提供透明的负载均衡，会将请求分发给其中的任意一个（如下面的动画所示）。通过每个Node上运行的代理（kube-proxy）完成。</li></ul><p>下述动画展示了Service的功能。注意该图作了很多简化。如果不进入网络配置，那么达到透明的负载均衡目标所涉及的底层网络和路由相对先进。如果有兴趣，有更深入的介绍。</p><p><img src="https://s1.ax1x.com/2020/05/04/YPJOxS.png" alt="YPJOxS.png"></p><p>每个节点都运行如下Kubernetes关键组件：</p><ul><li>Kubelet：是主节点代理。</li><li>Kube-proxy：Service使用其将链接路由到Pod，如上文所述。</li><li>Docker或Rocket：Kubernetes使用的容器技术来创建容器。</li></ul><h3 id="Kubernetes-Master"><a href="#Kubernetes-Master" class="headerlink" title="Kubernetes Master"></a>Kubernetes Master</h3><p>集群拥有一个Kubernetes Master（紫色方框）。Kubernetes Master提供集群的独特视角，并且拥有一系列组件，比如Kubernetes API Server。API Server提供可以用来和集群交互的REST端点。master节点包括用来创建和复制Pod的Replication Controller。</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker数据共享与持久化</title>
      <link href="2020/01/19/rong-qi/docker-shu-ju-gong-xiang-yu-chi-jiu-hua/"/>
      <url>2020/01/19/rong-qi/docker-shu-ju-gong-xiang-yu-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>本文介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：<ul><li>数据卷（Data Volumes）</li><li>挂载主机目录 (Bind mounts)</li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code>是一个可供一个或多个容器使用的特殊目录，它绕过<code>UFS</code>，可以提供很多有用的特性：</p><ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。</p></blockquote><p>选择 -v 还是 -–mount 参数： Docker 新用户应该选择<code>--mount</code>参数，经验丰富的 Docker 使用者对<code>-v</code>或者 <code>--volume</code>已经很熟悉了，但是推荐使用<code>--mount</code>参数。</p><p>创建一个数据卷：</p><pre class=" language-shell"><code class="language-shell">$ docker volume create my-vol</code></pre><p>查看所有的 数据卷：</p><pre class=" language-shell"><code class="language-shell">$ docker volume lslocal               my-vol</code></pre><p>在主机里使用以下命令可以查看指定 数据卷 的信息</p><pre class=" language-shell"><code class="language-shell">$ docker volume inspect my-vol[    {        "Driver": "local",        "Labels": {},        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",        "Name": "my-vol",        "Options": {},        "Scope": "local"    }]</code></pre><p>启动一个挂载数据卷的容器：在用<code>docker run</code>命令的时候，使用<code>--mount</code>标记来将 数据卷 挂载到容器里。在一次<code>docker run</code>中可以挂载多个 数据卷。下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。</p><pre class=" language-shell"><code class="language-shell">$ docker run -d -P \    --name web \    # -v my-vol:/wepapp \    --mount source=my-vol,target=/webapp \    training/webapp \    python app.py</code></pre><p>查看数据卷的具体信息：在主机里使用以下命令可以查看 web 容器的信息</p><pre class=" language-shell"><code class="language-shell">$ docker inspect web..."Mounts": [    {        "Type": "volume",        "Name": "my-vol",        "Source": "/var/lib/docker/volumes/my-vol/_data",        "Destination": "/app",        "Driver": "local",        "Mode": "",        "RW": true,        "Propagation": ""    }],...</code></pre><p>删除数据卷：</p><pre><code>$ docker volume rm my-vol</code></pre><p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用<code>docker rm -v</code>这个命令。 无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><pre><code>$ docker volume prune</code></pre><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><p>选择 -v 还是 -–mount 参数： Docker 新用户应该选择 –mount 参数，经验丰富的 Docker 使用者对 -v 或者 –volume 已经很熟悉了，但是推荐使用 –mount 参数。</p><p>挂载一个主机目录作为数据卷：使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><pre class=" language-shell"><code class="language-shell">$ docker run -d -P \    --name web \    # -v /src/webapp:/opt/webapp \    --mount type=bind,source=/src/webapp,target=/opt/webapp \    training/webapp \    python app.py</code></pre><p>上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 –mount 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加<code>readonly</code>指定为 只读。</p><pre class=" language-shell"><code class="language-shell">$ docker run -d -P \    --name web \    # -v /src/webapp:/opt/webapp:ro \    --mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \    training/webapp \    python app.py</code></pre><p>加了<code>readonly</code>之后，就挂载为 只读 了。如果你在容器内 /opt/webapp 目录新建文件，会显示如下错误:</p><pre class=" language-shell"><code class="language-shell">/opt/webapp # touch new.txttouch: new.txt: Read-only file system</code></pre><p>查看数据卷的具体信息：在主机里使用以下命令可以查看 web 容器的信息</p><pre class=" language-shell"><code class="language-shell">$ docker inspect web..."Mounts": [    {        "Type": "bind",        "Source": "/src/webapp",        "Destination": "/opt/webapp",        "Mode": "",        "RW": true,        "Propagation": "rprivate"    }],</code></pre><p>挂载一个本地主机文件作为数据卷：<code>--mount</code>标记也可以从主机挂载单个文件到容器中</p><pre class=" language-shell"><code class="language-shell">$ docker run --rm -it \   # -v $HOME/.bash_history:/root/.bash_history \   --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \   ubuntu:17.10 \   bashroot@2affd44b4667:/# history1  ls2  diskutil list</code></pre><p>这样就可以记录在容器输入过的命令了。</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zabbix 监控项</title>
      <link href="2020/01/05/jian-kong/zabbix-jian-kong-xiang/"/>
      <url>2020/01/05/jian-kong/zabbix-jian-kong-xiang/</url>
      
        <content type="html"><![CDATA[<h4 id="Zabbix监控什么？"><a href="#Zabbix监控什么？" class="headerlink" title="Zabbix监控什么？"></a>Zabbix监控什么？</h4><p><img src="http://p1.pstatp.com/large/pgc-image/1ee9df63b32b4108a8537cc27eb9252b" alt="Zabbix 监控"></p><p>监控项</p><h4 id="Zabbix常用监控项"><a href="#Zabbix常用监控项" class="headerlink" title="Zabbix常用监控项"></a>Zabbix常用监控项</h4><p><strong>zabbix自带的常用监控项</strong></p><pre><code>agent.ping 检测客户端可达性、返回nothing表示不可达。1表示可达system.cpu.load --检测cpu负载。返回浮点数system.cpu.util -- 检测cpu使用率。返回浮点数vfs.dev.read -- 检测硬盘读取数据，返回是sps.ops.bps浮点类型，需要定义1024倍vfs.dev.write -- 检测硬盘写入数据。返回是sps.ops.bps浮点类型，需要定义1024倍net.if.out[br0] --检测网卡流速、流出方向，时间间隔为60Snet-if-in[br0] --检测网卡流速，流入方向（单位：字节） 时间间隔60Sproc.num[]  目前系统中的进程总数，时间间隔60sproc.num[,,run] 目前正在运行的进程总数，时间间隔60S</code></pre><h5 id="处理器信息"><a href="#处理器信息" class="headerlink" title="处理器信息"></a>处理器信息</h5><pre><code>通过zabbix_get 获取负载值合理的控制用户态、系统态、IO等待时间剋保证进程高效率的运行系统态运行时间较高说明进程进行系统调用的次数比较多，一般的程序如果系统态运行时间占用过高就需要优化程序，减少系统调用io等待时间过高则表明硬盘的io性能差，如果是读写文件比较频繁、读写效率要求比较高，可以考虑更换硬盘，或者使用多磁盘做raid的方案system.cpu.swtiches --cpu的进程上下文切换，单位sps，表示每秒采样次数，api中参数history需指定为3system.cpu.intr  --cpu中断数量、api中参数history需指定为3system.cpu.load[percpu,avg1]  --cpu每分钟的负载值，按照核数做平均值(Processor load (1 min average per core))，api中参数history需指定为0system.cpu.load[percpu,avg5]  --cpu每5分钟的负载值，按照核数做平均值(Processor load (5 min average per core))，api中参数history需指定为0system.cpu.load[percpu,avg15]  --cpu每5分钟的负载值，按照核数做平均值(Processor load (15 min average per core))，api中参数history需指定为0</code></pre><h4 id="zabbix的自定义常用项"><a href="#zabbix的自定义常用项" class="headerlink" title="zabbix的自定义常用项"></a>zabbix的自定义常用项</h4><h5 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h5><pre><code>vim /usr/local/zabbix/etc/zabbix_agentd.conf.d/catcarm.confUserParameter=ram.info[*],/bin/cat  /proc/meminfo  |awk &#39;/^$1:{print $2}&#39;ram.info[Cached] --检测内存的缓存使用量、返回整数，需要定义1024倍ram.info[MemFree] --检测内存的空余量，返回整数，需要定义1024倍ram.info[Buffers] --检测内存的使用量，返回整数，需要定义1024倍</code></pre><h5 id="TCP相关的自定义项"><a href="#TCP相关的自定义项" class="headerlink" title="TCP相关的自定义项"></a>TCP相关的自定义项</h5><pre><code>vim /usr/local/zabbix/share/zabbix/alertscripts/tcp_connection.sh#!/bin/bashfunction ESTAB { /usr/sbin/ss -ant |awk &#39;{++s[$1]} END {for(k in s) print k,s[k]}&#39; | grep &#39;ESTAB&#39; | awk &#39;{print $2}&#39;}function TIMEWAIT {/usr/sbin/ss -ant | awk &#39;{++s[$1]} END {for(k in s) print k,s[k]}&#39; | grep &#39;TIME-WAIT&#39; | awk &#39;{print $2}&#39;}function LISTEN {/usr/sbin/ss -ant | awk &#39;{++s[$1]} END {for(k in s) print k,s[k]}&#39; | grep &#39;LISTEN&#39; | awk &#39;{print $2}&#39;}$1vim /usr/local/zabbix/etc/zabbix_agentd.conf.d/cattcp.confUserParameter=tcp[*],/usr/local/zabbix/share/zabbix/alertscripts/tcp_connection.sh $1tcp[TIMEWAIT] --检测TCP的驻留数，返回整数tcp[ESTAB]  --检测tcp的连接数、返回整数tcp[LISTEN] --检测TCP的监听数，返回整数</code></pre><h5 id="nginx相关的自定义项"><a href="#nginx相关的自定义项" class="headerlink" title="nginx相关的自定义项"></a>nginx相关的自定义项</h5><pre><code>vim /etc/nginx/conf.d/default.conf    location /nginx-status    {        stub_status on;        access_log off;        allow 127.0.0.1;        deny all;    }vim /usr/local/zabbix/etc/zabbix_agentd.conf.d/nginx.confUserParameter=Nginx.active,/usr/bin/curl -s &quot;http://127.0.0.1:80/nginx-status&quot; | awk &#39;/Active/ {print $NF}&#39;UserParameter=Nginx.read,/usr/bin/curl -s &quot;http://127.0.0.1:80/nginx-status&quot; | grep &#39;Reading&#39; | cut -d&quot; &quot; -f2UserParameter=Nginx.wrie,/usr/bin/curl -s &quot;http://127.0.0.1:80/nginx-status&quot; | grep &#39;Writing&#39; | cut -d&quot; &quot; -f4UserParameter=Nginx.wait,/usr/bin/curl -s &quot;http://127.0.0.1:80/nginx-status&quot; | grep &#39;Waiting&#39; | cut -d&quot; &quot; -f6UserParameter=Nginx.accepted,/usr/bin/curl -s &quot;http://127.0.0.1:80/nginx-status&quot; | awk &#39;/^[ \t]+[0-9]+[ \t]+[0-9]+[ \t]+[0-9]+/ {print $1}&#39;UserParameter=Nginx.handled,/usr/bin/curl -s &quot;http://127.0.0.1:80/nginx-status&quot; | awk &#39;/^[ \t]+[0-9]+[ \t]+[0-9]+[ \t]+[0-9]+/ {print $2}&#39;UserParameter=Nginx.requests,/usr/bin/curl -s &quot;http://127.0.0.1:80/nginx-status&quot; | awk &#39;/^[ \t]+[0-9]+[ \t]+[0-9]+[ \t]+[0-9]+/ {print $3}&#39;PHP.listenqueue --检测PHP队列数，返回整数PHP.idle --检测PHP空闲进程数，返回整数PHP.active --检测PHP活动进程数，返回整数PHP.conn --检测PHP请求数,返回整数PHP.reached --检测PHP达到限制次数，返回整数PHP.requets --检测PHP慢请求书，返回整数</code></pre><h5 id="redis相关的自定义项"><a href="#redis相关的自定义项" class="headerlink" title="redis相关的自定义项"></a>redis相关的自定义项</h5><pre><code>vim /usr/local/zabbix/etc/zabbix_agentd.conf.d/redis.confUserParameter=Redis.Status,/usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6379 ping |grep -c PONGUserParameter=Redis_conn[*],/usr/local/redis/bin/redis-cli -h $1 -p $2 info | grep -w &quot;connected_clients&quot; | awk -F&#39;:&#39; &#39;{print $2}&#39;UserParameter=Redis_rss_mem[*],/usr/local/redis/bin/redis-cli -h $1 -p $2 info | grep -w &quot;used_memory_rss&quot; | awk -F&#39;:&#39; &#39;{print $2}&#39;UserParameter=Redis_lua_mem[*],/usr/local/redis/bin/redis-cli -h $1 -p $2 info | grep -w &quot;used_memory_lua&quot; | awk -F&#39;:&#39; &#39;{print $2}&#39;UserParameter=Redis_cpu_sys[*],/usr/local/redis/bin/redis-cli -h $1 -p $2 info | grep -w &quot;used_cpu_sys&quot; | awk -F&#39;:&#39; &#39;{print $2}&#39;UserParameter=Redis_cpu_user[*],/usr/local/redis/bin/redis-cli -h $1 -p $2 info | grep -w &quot;used_cpu_user&quot; | awk -F&#39;:&#39; &#39;{print $2}&#39;UserParameter=Redis_cpu_sys_cline[*],/usr/local/redis/bin/redis-cli -h $1 -p $2 info | grep -w &quot;used_cpu_sys_children&quot; | awk -F&#39;:&#39; &#39;{print $2}&#39;UserParameter=Redis_cpu_user_cline[*],/usr/local/redis/bin/redis-cli -h $1 -p $2 info | grep -w &quot;used_cpu_user_children&quot; | awk -F&#39;:&#39; &#39;{print $2}&#39;UserParameter=Redis_keys_num[*],/usr/local/redis/bin/redis-cli -h $1 -p $2 info | grep -w &quot;$$1&quot; | grep -w &quot;keys&quot; | grep db$3 | awk -F&#39;=&#39; &#39;{print $2}&#39; | awk -F&#39;,&#39; &#39;{print $1}&#39;UserParameter=Redis_loading[*],/usr/local/redis/bin/redis-cli -h $1 -p $2 info | grep loading | awk -F&#39;:&#39; &#39;{print $$2}&#39;Redis.Status --检测Redis运行状态， 返回整数Redis_conn  --检测Redis成功连接数，返回整数Redis_rss_mem  --检测Redis系统分配内存，返回整数Redis_lua_mem  --检测Redis引擎消耗内存，返回整数Redis_cpu_sys --检测Redis主程序核心CPU消耗率，返回整数Redis_cpu_user --检测Redis主程序用户CPU消耗率，返回整数Redis_cpu_sys_cline --检测Redis后台核心CPU消耗率，返回整数Redis_cpu_user_cline --检测Redis后台用户CPU消耗率，返回整数Redis_keys_num --检测库键值数，返回整数Redis_loding --检测Redis持久化文件状态，返回整数</code></pre><h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL:"></a>MySQL:</h5><pre><code>version:数据库版本key_buffer_size:myisam的索引buffer大小sort_buffer_size:会话的排序空间（每个线程会申请一个）join_buffer_size:这是为链接操作分配的最小缓存大小，这些连接使用普通索引扫描、范围扫描、或者连接不适用索引max_connections:最大允许同时连接的数量max_connect_errors：允许一个主机最多的错误链接次数，如果超过了就会拒绝之后链接（默认100）。可以使用flush hosts命令去解除拒绝open_files_limits:操作系统允许mysql打开的文件数量，可以通过opened_tables状态确定是否需要增大table_open_cache,如果opened_tables比较大且一直还在增大说明需要增大table_open_cachemax-heap_tables_size:建立的内存表的最大大小（默认16M）这个参数和tmp_table_size一起限制内部临时表的最大值(取这两个参数的小的一个），如果超过限制，则表会变为innodb或myisam引擎，（5.7.5之前是默认是myisam，5.7.6开始是innodb，可以通过internal_tmp_disk_storage_engine参数调整）。max_allowed_packet:一个包的最大大小##########GET INNODB INFO#INNODB variablesinnodb_version:innodb_buffer_pool_instances：将innodb缓冲池分为指定的多个（默认为1）innodb_buffer_pool_size:innodb缓冲池大小、5.7.5引入了innodb_buffer_pool_chunk_size,innodb_doublewrite：是否开启doublewrite（默认开启）innodb_read_io_threads:IO读线程的数量innodb_write_io_threads:IO写线程的数量########innodb statusinnodb_buffer_pool_pages_total:innodb缓冲池页的数量、大小等于innodb_buffer_pool_size/(16*1024)innodb_buffer_pool_pages_data:innodb缓冲池中包含数据的页的数量########## GET MYSQL HITRATE1、查询缓存命中率如果Qcache_hits+Com_select&lt;&gt;0则为 Qcache_hits/（Qcache_hits+Com_select），否则为02、线程缓存命中率如果Connections&lt;&gt;0,则为1-Threads_created/Connections，否则为03、myisam键缓存命中率如果Key_read_requests&lt;&gt;0,则为1-Key_reads/Key_read_requests，否则为04、myisam键缓存写命中率如果Key_write_requests&lt;&gt;0,则为1-Key_writes/Key_write_requests，否则为05、键块使用率如果Key_blocks_used+Key_blocks_unused&lt;&gt;0，则Key_blocks_used/（Key_blocks_used+Key_blocks_unused），否则为06、创建磁盘存储的临时表比率如果Created_tmp_disk_tables+Created_tmp_tables&lt;&gt;0,则Created_tmp_disk_tables/（Created_tmp_disk_tables+Created_tmp_tables），否则为07、连接使用率如果max_connections&lt;&gt;0，则threads_connected/max_connections，否则为08、打开文件比率如果open_files_limit&lt;&gt;0，则open_files/open_files_limit，否则为09、表缓存使用率如果table_open_cache&lt;&gt;0，则open_tables/table_open_cache，否则为0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go_学习之Docke容器</title>
      <link href="2019/12/05/devops/golang/go-study/"/>
      <url>2019/12/05/devops/golang/go-study/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="mysql容器"><a href="#mysql容器" class="headerlink" title="mysql容器"></a>mysql容器</h3><pre><code>[mysqld]log-error=/mylog/error.logslow_query_log = onlong_query_time=2slow-query-log-file =/mylog/slow.logdocker run -it --rm --entrypoint=&quot;/bin/bash&quot; mysql:5.7 -c &quot;cat /etc/group &quot;因为容器默认使用的是mysql用户。 因此我们需要把映射的文件夹修改ownerdocker run --name mysql -d   \-p 3306:3306  \-v /home/cyy/mysql/data:/data \-v  /home/cyy/mysql/conf/my.cnf:/etc/mysql/my.cnf  \-v /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime \-v  /home/cyy/mysql/mylog:/mylog  \-e MYSQL_ROOT_PASSWORD=123456   \mysql:5.7</code></pre><h3 id="alpine容器"><a href="#alpine容器" class="headerlink" title="alpine容器"></a>alpine容器</h3><pre class=" language-shell"><code class="language-shell">docker pull alpine docker run --name goserver  -d \-v /home/cyy/web:/server  \-v /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime \-w /server \alpine ./gin</code></pre><h3 id="nginx容器"><a href="#nginx容器" class="headerlink" title="nginx容器"></a>nginx容器</h3><pre class=" language-shell"><code class="language-shell">docker pull  nginx:alpine </code></pre><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">user</span>  nginx<span class="token punctuation">;</span><span class="token keyword">worker_processes</span>  auto<span class="token punctuation">;</span><span class="token keyword">error_log</span>  <span class="token operator">/</span>var<span class="token operator">/</span>log<span class="token operator">/</span>nginx<span class="token operator">/</span>error<span class="token punctuation">.</span>log warn<span class="token punctuation">;</span><span class="token keyword">pid</span>        <span class="token operator">/</span>var<span class="token operator">/</span>run<span class="token operator">/</span>nginx<span class="token punctuation">.</span><span class="token keyword">pid</span><span class="token punctuation">;</span><span class="token keyword">events</span> <span class="token punctuation">{</span>    <span class="token keyword">worker_connections</span>  <span class="token number">1024</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">http</span> <span class="token punctuation">{</span>    <span class="token keyword">include</span>       <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>mime<span class="token punctuation">.</span><span class="token keyword">types</span><span class="token punctuation">;</span>    <span class="token keyword">default_type</span>  application<span class="token operator">/</span>octet<span class="token operator">-</span>stream<span class="token punctuation">;</span>     <span class="token keyword">keepalive_timeout</span>  <span class="token number">65</span><span class="token punctuation">;</span><span class="token keyword">upstream</span> gin  <span class="token punctuation">{</span>    <span class="token keyword">server</span> <span class="token number">172.17</span><span class="token punctuation">.</span><span class="token number">0.4</span><span class="token punctuation">:</span><span class="token number">8080</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">server</span><span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>    <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>        <span class="token keyword">proxy_pass</span>  <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>gin<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">#Proxy Settings</span>        <span class="token keyword">proxy_redirect</span>     off<span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span>   Host             <span class="token variable">$host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span>   X<span class="token operator">-</span>Real<span class="token operator">-</span>IP        <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span>   X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For  <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-shell"><code class="language-shell">docker run -d --name ngx  \-v /home/cyy/ngx/nginx.conf:/etc/nginx/nginx.conf \-v /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime \-p 80:80  \nginx:alpine</code></pre><h4 id="Redis-容器"><a href="#Redis-容器" class="headerlink" title="Redis 容器"></a>Redis 容器</h4><pre class=" language-shell"><code class="language-shell">docker run --name redis-d -v /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime -p 6379:6379 redis:5-alpine redis-servver</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle设置开机自启</title>
      <link href="2019/11/27/sql/oracle-she-zhi-kai-ji-zi-qi/"/>
      <url>2019/11/27/sql/oracle-she-zhi-kai-ji-zi-qi/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><strong>步骤：</strong></p><h5 id="1：查看ORACLE-HOME是否设置"><a href="#1：查看ORACLE-HOME是否设置" class="headerlink" title="1：查看ORACLE_HOME是否设置"></a><strong>1：查看ORACLE_HOME是否设置</strong></h5><pre><code>$ echo $ORACLE_HOME/u01/app/oracle/product/11.2.0/db_1</code></pre><h5 id="2：执行dbstart-数据库自带启动脚本"><a href="#2：执行dbstart-数据库自带启动脚本" class="headerlink" title="2：执行dbstart 数据库自带启动脚本"></a><strong>2：执行dbstart 数据库自带启动脚本</strong></h5><pre><code>[oracle@njdzjkdb ~]$ cd $ORACLE_HOME[oracle@njdzjkdb dbhome_1]$ cd bin/[oracle@njdzjkdb bin]$ dbstartORACLE_HOME_LISTNER is not SET, unable to auto-start Oracle Net Listener Usage: /u01/app/oracle/product/11.2.0/db_1/bin/dbstart ORACLE_HOME错误提示：ORACLE_HOME_LISTNER 没有设置[oracle@njdzjkdb bin]$ ll | grep dbs-rwxr-x---. 1 oracle oinstall 6088 1月 1 2000 dbshut-rwxr-x---. 1 oracle oinstall 13892 12月 11 16:01 dbstart编辑 dbstart，将ORACLE_HOME_LISTNER=$1修改成 ORACLE_HOME_LISTNER=$ORACLE_HOME 前提是$ORACLE_HOME环境设置正确[oracle@njdzjkdb bin]$ vi dbstart ORACLE_HOME_LISTNER=/u01/app/oracle/product/11.2.0/db_1</code></pre><h5 id="3：编辑-etc-oratab文件"><a href="#3：编辑-etc-oratab文件" class="headerlink" title="3：编辑/etc/oratab文件"></a><strong>3：编辑/etc/oratab文件</strong></h5><pre><code>dbca建库时都会自动创建/etc/oratab文件将oracle:/u01/app/oracle/product/11.2.0/db_1:N修改成 oracle:/u01/app/oracle/product/11.2.0/db_1:Y</code></pre><h5 id="4：编辑-etc-rc-d-rc-local启动文件，添加数据库启动脚本dbstart"><a href="#4：编辑-etc-rc-d-rc-local启动文件，添加数据库启动脚本dbstart" class="headerlink" title="4：编辑/etc/rc.d/rc.local启动文件，添加数据库启动脚本dbstart"></a><strong>4：编辑/etc/rc.d/rc.local启动文件，添加数据库启动脚本dbstart</strong></h5><pre><code>[root@njdzjkdb ~]# vi /etc/rc.d/rc.local#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run &#39;chmod +x /etc/rc.d/rc.local&#39; to ensure# that this script will be executed during boot.touch /var/lock/subsys/localsu oracle -lc &quot;/u01/app/oracle/product/11.2.0/db_1/bin/lsnrctl start&quot;su oracle -lc /u01/app/oracle/product/11.2.0/db_1/bin/dbstart</code></pre><h5 id="5：重启主机，查看数据库和监听是自启动"><a href="#5：重启主机，查看数据库和监听是自启动" class="headerlink" title="5：重启主机，查看数据库和监听是自启动"></a><strong>5：重启主机，查看数据库和监听是自启动</strong></h5><pre><code>netstat -tunlp | grep 1521</code></pre><h5 id="6：查看数据库是否处于open状态"><a href="#6：查看数据库是否处于open状态" class="headerlink" title="6：查看数据库是否处于open状态"></a><strong>6：查看数据库是否处于open状态</strong></h5><pre><code>select status from v$instance</code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7静默安装oracle11g</title>
      <link href="2019/11/27/sql/centos7-jing-mo-an-zhuang-oracle11g/"/>
      <url>2019/11/27/sql/centos7-jing-mo-an-zhuang-oracle11g/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h5 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a><strong>操作系统：</strong></h5><pre><code>[root@cyylog ~]# uname -mx86_64[root@cyylog ~]# cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) </code></pre><h1 id="安装前的准备："><a href="#安装前的准备：" class="headerlink" title="安装前的准备："></a><strong>安装前的准备：</strong></h1><h5 id="1-修改主机名"><a href="#1-修改主机名" class="headerlink" title="1. 修改主机名"></a><strong>1. 修改主机名</strong></h5><pre><code>#sed -i &quot;s/HOSTNAME=localhost.localdomain/HOSTNAME=oracledb/&quot; /etc/sysconfig/network</code></pre><h5 id="2-添加主机名与IP对应记录"><a href="#2-添加主机名与IP对应记录" class="headerlink" title="2.添加主机名与IP对应记录"></a><strong>2.添加主机名与IP对应记录</strong></h5><pre><code># vim /etc/hosts 192.168.0.9 oracledb</code></pre><h5 id="3-关闭Selinux"><a href="#3-关闭Selinux" class="headerlink" title="3.关闭Selinux"></a><strong>3.关闭Selinux</strong></h5><pre><code># sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/&quot; /etc/selinux/config # setenforce 0 </code></pre><h5 id="4-检查是否有swap分区"><a href="#4-检查是否有swap分区" class="headerlink" title="4.检查是否有swap分区."></a><strong>4.检查是否有swap分区.</strong></h5><p>(我的机器是没有这个,所有后面有报错) Linux一切皆文件,没有就自己造一个</p><pre><code>1、检查 Swap 空间在设置 Swap 文件之前，有必要先检查一下系统里有没有既存的 Swap 文件。运行以下命令：# swapon -s如果返回的信息概要是空的，则表示 Swap 文件不存在。2、检查文件系统在设置 Swap 文件之前，同样有必要检查一下文件系统，看看是否有足够的硬盘空间来设置 Swap 。运行以下命令：# df -hal3、创建并允许 Swap 文件下面使用 dd 命令来创建 Swap 文件。检查返回的信息，还剩余足够的硬盘空间即可。# dd if=/dev/zero of=/swapfile bs=1024 count=512k参数解读：if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;bs=bytes：同时设置读入/输出的块大小为bytes个字节count=blocks：仅拷贝blocks个块，块大小等于bs指定的字节数。4、格式化并激活 Swap 文件上面已经创建好 Swap 文件，还需要格式化后才能使用。运行命令：# mkswap /swapfile激活 Swap ，运行命令：# swapon /swapfile以上步骤做完，再次运行命令：# swapon -s你会发现返回的信息概要：1 Filename Type Size Used Priority2 /swapfile file 524284 0 -1如果要机器重启的时候自动挂载 Swap ，那么还需要修改 fstab 配置。用 vim 打开 /etc/fstab 文件，在其最后添加如下一行：/swapfile swap swap defaults 0 0最后，赋予 Swap 文件适当的权限：# chown root:root /swapfile # chmod 0600 /swapfile</code></pre><h5 id="5-安装常用工具-配置阿里源"><a href="#5-安装常用工具-配置阿里源" class="headerlink" title="5.安装常用工具,配置阿里源"></a><strong>5.安装常用工具,配置阿里源</strong></h5><p>(个人习惯,在使用的主机上面配置这些常用工具)</p><pre><code># curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo# curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo# yum clean all# yum makecache fast# yum install -y wget ntpdate net-tools vim bash-completion ShellCheck# ntpdate -b ntp1.aliyun.com</code></pre><h4 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h4><p>参考官方：<a href="http://docs.oracle.com/cd/E11882_01/install.112/e24326/toc.htm#BHCCADGD" target="_blank" rel="noopener">http://docs.oracle.com/cd/E11882_01/install.112/e24326/toc.htm#BHCCADGD</a></p><ul><li>The following or later version of packages for Oracle Linux 7, and Red Hat Enterprise Linux 7 must be installed:</li></ul><pre><code>binutils-2.23.52.0.1-12.el7.x86_64 compat-libcap1-1.10-3.el7.x86_64 compat-libstdc++-33-3.2.3-71.el7.i686compat-libstdc++-33-3.2.3-71.el7.x86_64gcc-4.8.2-3.el7.x86_64 gcc-c++-4.8.2-3.el7.x86_64 glibc-2.17-36.el7.i686 glibc-2.17-36.el7.x86_64 glibc-devel-2.17-36.el7.i686 glibc-devel-2.17-36.el7.x86_64 kshlibaio-0.3.109-9.el7.i686 libaio-0.3.109-9.el7.x86_64 libaio-devel-0.3.109-9.el7.i686 libaio-devel-0.3.109-9.el7.x86_64 libgcc-4.8.2-3.el7.i686 libgcc-4.8.2-3.el7.x86_64 libstdc++-4.8.2-3.el7.i686 libstdc++-4.8.2-3.el7.x86_64 libstdc++-devel-4.8.2-3.el7.i686 libstdc++-devel-4.8.2-3.el7.x86_64 libXi-1.7.2-1.el7.i686 libXi-1.7.2-1.el7.x86_64 libXtst-1.2.2-1.el7.i686 libXtst-1.2.2-1.el7.x86_64 make-3.82-19.el7.x86_64 sysstat-10.1.5-1.el7.x86_64unixODBC-2.3.1-6.el7.x86_64 or laterunixODBC-2.3.1-6.el7.i686 or laterunixODBC-devel-2.3.1-6.el7.x86_64 or laterunixODBC-devel-2.3.1-6.el7.i686 or later</code></pre><pre><code>binutils-2.23.52.0.1-12.el7.x86_64 compat-libcap1-1.10-3.el7.x86_64 compat-libstdc++-33-3.2.3-71.el7.i686compat-libstdc++-33-3.2.3-71.el7.x86_64gcc-4.8.2-3.el7.x86_64 gcc-c++-4.8.2-3.el7.x86_64 glibc-2.17-36.el7.i686 glibc-2.17-36.el7.x86_64 glibc-devel-2.17-36.el7.i686 glibc-devel-2.17-36.el7.x86_64 kshlibaio-0.3.109-9.el7.i686 libaio-0.3.109-9.el7.x86_64 libaio-devel-0.3.109-9.el7.i686 libaio-devel-0.3.109-9.el7.x86_64 libgcc-4.8.2-3.el7.i686 libgcc-4.8.2-3.el7.x86_64 libstdc++-4.8.2-3.el7.i686 libstdc++-4.8.2-3.el7.x86_64 libstdc++-devel-4.8.2-3.el7.i686 libstdc++-devel-4.8.2-3.el7.x86_64 libXi-1.7.2-1.el7.i686 libXi-1.7.2-1.el7.x86_64 libXtst-1.2.2-1.el7.i686 libXtst-1.2.2-1.el7.x86_64 make-3.82-19.el7.x86_64 sysstat-10.1.5-1.el7.x86_64unixODBC-2.3.1-6.el7.x86_64 or laterunixODBC-2.3.1-6.el7.i686 or laterunixODBC-devel-2.3.1-6.el7.x86_64 or laterunixODBC-devel-2.3.1-6.el7.i686 or later</code></pre><h5 id="用yum进行安装"><a href="#用yum进行安装" class="headerlink" title="用yum进行安装"></a><strong>用yum进行安装</strong></h5><pre><code>yum -y install binutils compat-libcap1 compat-libstdc++-33 compat-libstdc++-33*i686 compat-libstdc++-33*.devel compat-libstdc++-33 compat-libstdc++-33*.devel gcc gcc-c++ glibc glibc*.i686 glibc-devel glibc-devel*.i686 ksh libaio libaio*.i686 libaio-devel libaio-devel*.devel libgcc libgcc*.i686 libstdc++ libstdc++*.i686 libstdc++-devel libstdc++-devel*.devel libXi libXi*.i686 libXtst libXtst*.i686 make sysstat unixODBC unixODBC*.i686 unixODBC-devel unixODBC-devel*.i686</code></pre><h5 id="检测是否31个包都有安装"><a href="#检测是否31个包都有安装" class="headerlink" title="检测是否31个包都有安装"></a><strong>检测是否31个包都有安装</strong></h5><p>开放源码绿色蓝色按钮样式</p><pre><code>[root@cyylog ~]# rpm -q binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc glibc-devel ksh libaio libaio-devel libgcc libstdc++ libstdc++-devel libXi libXtst make sysstat unixODBC unixODBC-develbinutils-2.23.52.0.1-55.el7.x86_64compat-libcap1-1.10-7.el7.x86_64compat-libstdc++-33-3.2.3-72.el7.x86_64compat-libstdc++-33-3.2.3-72.el7.i686gcc-4.8.5-4.el7.x86_64gcc-c++-4.8.5-4.el7.x86_64glibc-2.17-106.el7_2.8.x86_64glibc-2.17-106.el7_2.8.i686glibc-devel-2.17-106.el7_2.8.x86_64glibc-devel-2.17-106.el7_2.8.i686ksh-20120801-22.el7_1.3.x86_64libaio-0.3.109-13.el7.x86_64libaio-0.3.109-13.el7.i686libaio-devel-0.3.109-13.el7.x86_64libaio-devel-0.3.109-13.el7.i686libgcc-4.8.5-4.el7.x86_64libgcc-4.8.5-4.el7.i686libstdc++-4.8.5-4.el7.x86_64libstdc++-4.8.5-4.el7.i686libstdc++-devel-4.8.5-4.el7.x86_64libstdc++-devel-4.8.5-4.el7.i686libXi-1.7.2-2.1.el7.x86_64libXi-1.7.4-2.el7.i686libXtst-1.2.2-2.1.el7.x86_64libXtst-1.2.2-2.1.el7.i686make-3.82-21.el7.x86_64sysstat-10.1.5-7.el7.x86_64unixODBC-2.3.1-11.el7.x86_64unixODBC-2.3.1-11.el7.i686unixODBC-devel-2.3.1-11.el7.x86_64unixODBC-devel-2.3.1-11.el7.i686</code></pre><p>版本号只能大于规定的版本，不能小于。</p><p>创建oinstall和dba组</p><pre><code># groupadd oinstall# groupadd dba</code></pre><p>创建oracle用户</p><pre><code># useradd -g oinstall -G dba oracle</code></pre><p>设置oracle用户密码</p><pre><code># passwd oracle</code></pre><p>验证创建是否正确</p><pre><code>[root@cyylog ~]# id oracleuid=1000(oracle) gid=1000(oinstall) groups=1000(oinstall),1001(dba)</code></pre><h5 id="配置内核参数"><a href="#配置内核参数" class="headerlink" title="配置内核参数"></a>配置内核参数</h5><pre><code>[root@cyylog ~]# vim /etc/sysctl.conf # System default settings live in /usr/lib/sysctl.d/00-system.conf.# To override those settings, enter new settings here, or in an /etc/sysctl.d/&lt;name&gt;.conf file## For more information, see sysctl.conf(5) and sysctl.d(5).fs.aio-max-nr = 1048576fs.file-max = 6815744kernel.shmall = 2097152kernel.shmmax = 536870912 #最低：536870912，最大值：比物理内存小1个字节的值，建议超过物理内存的一半kernel.shmmni = 4096kernel.sem = 250 32000 100 128net.ipv4.ip_local_port_range = 9000 65500net.core.rmem_default = 262144net.core.rmem_max = 4194304net.core.wmem_default = 262144net.core.wmem_max = 1048576</code></pre><p>参数的值不能小于上面的配置，这是oracle官方建议的最小值，生产环境建议调整这些参数，以优化系统性能。</p><p>修改后使之生效</p><pre><code># sysctl -p</code></pre><p>修改用户限制</p><pre><code>vim /etc/security/limits.conf#在末尾添加oracle soft nproc 2047oracle hard nproc 16384oracle soft nofile 1024oracle hard nofile 65536oracle soft stack 10240oracle hard stack 10240</code></pre><p>在/etc/pam.d/login 文件中，使用文本编辑器或vi命令增加或修改以下内容</p><pre><code>session required /lib64/security/pam_limits.sosession required pam_limits.so</code></pre><p>在/etc/profile 文件中，使用文本编辑器或vi命令增加或修改以下内容</p><pre><code>if [ $USER = &quot;oracle&quot; ]; then if [ $SHELL = &quot;/bin/ksh&quot; ]; then ulimit -p 16384 ulimit -n 65536 else ulimit -u 16384 -n 65536 fifi</code></pre><p>使之生效</p><pre><code># source /etc/profile</code></pre><p>创建安装目录</p><pre><code># mkdir -p /u01/app/# chown -R oracle:oinstall /u01/app/# chmod -R 775 /u01/app/</code></pre><p>配置环境变量</p><pre><code>[oracle@cyylog ~]$ vim ~/.bash_profile export ORACLE_BASE=/u01/app/oracleexport ORACLE_SID=dbsrv2</code></pre><p>使之生效</p><pre><code>source ~/.bash_profile</code></pre><p>解压oracle软件</p><pre><code>[root@cyylog src]# unzip linux.x64_11gR2_database_1of2.zip[root@cyylog src]# unzip linux.x64_11gR2_database_2of2.zip</code></pre><p>复制响应文件模板</p><pre><code>[oracle@cyylog ~]$ mkdir etc[oracle@cyylog ~]$ cp /usr/local/src/database/response/* /home/oracle/etc/[oracle@cyylog ~]$ ls etcdbca.rsp db_install.rsp netca.rsp</code></pre><p>设置响应文件权限</p><pre><code>[oracle@cyylog ~]$ su - root[root@cyylog ~]# chmod 700 /home/oracle/etc/*.rsp</code></pre><h1 id="静默安装Oracle软件"><a href="#静默安装Oracle软件" class="headerlink" title="静默安装Oracle软件"></a><strong>静默安装Oracle软件</strong></h1><p>su - oracle</p><p>修改安装Oracle软件的响应文件/home/oracle/etc/db_install.rsp</p><pre><code>oracle.install.option=INSTALL_DB_SWONLY // 安装类型ORACLE_HOSTNAME=oracledb // 主机名称（hostname查询）UNIX_GROUP_NAME=oinstall // 安装组INVENTORY_LOCATION=/u01/app/oraInventory //INVENTORY目录（不填就是默认值）SELECTED_LANGUAGES=en,zh_CN,zh_TW // 选择语言ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1 //oracle_homeORACLE_BASE=/u01/app/oracle //oracle_baseoracle.install.db.InstallEdition=EE 　　　　// oracle版本oracle.install.db.isCustomInstall=false 　　//自定义安装，否，使用默认组件oracle.install.db.DBA_GROUP=dba /　　/ dba用户组oracle.install.db.OPER_GROUP=oinstall // oper用户组oracle.install.db.config.starterdb.type=GENERAL_PURPOSE //数据库类型oracle.install.db.config.starterdb.globalDBName=orcl //globalDBNameoracle.install.db.config.starterdb.SID=dbsrv2 //SIDoracle.install.db.config.starterdb.memoryLimit=81920 //自动管理内存的内存(M)oracle.install.db.config.starterdb.password.ALL=oracle //设定所有数据库用户使用同一个密码SECURITY_UPDATES_VIA_MYORACLESUPPORT=false //（手动写了false）DECLINE_SECURITY_UPDATES=true 　　//设置安全更新（貌似是有bug，这个一定要选true，否则会无限提醒邮件地址有问题，终止安装。PS：不管地址对不对）</code></pre><pre><code>oracle.install.option=INSTALL_DB_SWONLY // 安装类型ORACLE_HOSTNAME=oracledb // 主机名称（hostname查询）UNIX_GROUP_NAME=oinstall // 安装组INVENTORY_LOCATION=/u01/app/oraInventory //INVENTORY目录（不填就是默认值）SELECTED_LANGUAGES=en,zh_CN,zh_TW // 选择语言ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1 //oracle_homeORACLE_BASE=/u01/app/oracle //oracle_baseoracle.install.db.InstallEdition=EE 　　　　// oracle版本oracle.install.db.isCustomInstall=false 　　//自定义安装，否，使用默认组件oracle.install.db.DBA_GROUP=dba /　　/ dba用户组oracle.install.db.OPER_GROUP=oinstall // oper用户组oracle.install.db.config.starterdb.type=GENERAL_PURPOSE //数据库类型oracle.install.db.config.starterdb.globalDBName=orcl //globalDBNameoracle.install.db.config.starterdb.SID=dbsrv2 //SIDoracle.install.db.config.starterdb.memoryLimit=81920 //自动管理内存的内存(M)oracle.install.db.config.starterdb.password.ALL=oracle //设定所有数据库用户使用同一个密码SECURITY_UPDATES_VIA_MYORACLESUPPORT=false //（手动写了false）DECLINE_SECURITY_UPDATES=true 　　//设置安全更新（貌似是有bug，这个一定要选true，否则会无限提醒邮件地址有问题，终止安装。PS：不管地址对不对）</code></pre><p>开始静默安装</p><pre><code>[oracle@cyylog database]$ ./runInstaller -silent -responseFile /home/oracle/etc/db_install.rsp</code></pre><p>新开一个终端 查看安装日志</p><pre><code># tail -f /u01/app/oraInventory/logs/installActions2016-08-31_06-56-29PM.log</code></pre><p>出现类似如下提示表示安装完成：</p><p>-———————————————————————–</p><p>The following configuration scripts need to be executed as the “root” user. #!/bin/sh #Root scripts to run</p><p>/u01/app/oraInventory/orainstRoot.sh /u01/app/oracle/product/11.2.0/db_1/root.sh To execute the configuration scripts:</p><ol><li>Open a terminal window</li><li>Log in as “root”</li><li>Run the scripts</li><li>Return to this window and hit “Enter” key to continue</li></ol><p>Successfully Setup Software.</p><p>-—————————————————————————-</p><p>使用root用户执行脚本</p><pre><code>$ su - root# /u01/app/oraInventory/orainstRoot.sh# /u01/app/oracle/product/11.2.0/db_1/root.sh</code></pre><p>增加或修改oracle的环境变量</p><pre><code># su - oracle# vim ~/.bash_profile</code></pre><pre><code>#for oracleexport ORACLE_BASE=/u01/app/oracleexport ORACLE_SID=dbsrv2export ROACLE_PID=ora11g#export NLS_LANG=AMERICAN_AMERICA.AL32UTF8export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/usr/libexport ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1export PATH=$PATH:$ORACLE_HOME/binexport LANG=&quot;zh_CN.UTF-8&quot;export NLS_LANG=&quot;SIMPLIFIED CHINESE_CHINA.AL32UTF8&quot;export NLS_DATE_FORMAT=&#39;yyyy-mm-dd hh24:mi:ss&#39;刷新环境变量# source ~/.bash_profile</code></pre><p>配置监听程序</p><pre><code>[oracle@cyylog ~]$ netca /silent /responsefile /home/oracle/etc/netca.rspParsing command line arguments:Parameter &quot;silent&quot; = trueParameter &quot;responsefile&quot; = /home/oracle/etc/netca.rspDone parsing command line arguments.Oracle Net Services Configuration:Profile configuration complete.Oracle Net Listener Startup:Running Listener Control: /u01/app/oracle/product/11.2.0/db_1/bin/lsnrctl start LISTENERListener Control complete.Listener started successfully.Listener configuration complete.Oracle Net Services configuration successful. The exit code is 0</code></pre><p>启动监控程序</p><pre><code>[oracle@cyylog ~]$ lsnrctl startLSNRCTL for Linux: Version 11.2.0.1.0 - Production on 01-SEP-2016 11:23:31Copyright (c) 1991, 2009, Oracle. All rights reserved.Starting /u01/app/oracle/product/11.2.0/db_1/bin/tnslsnr: please wait...TNSLSNR for Linux: Version 11.2.0.1.0 - ProductionSystem parameter file is /u01/app/oracle/product/11.2.0/db_1/network/admin/listener.oraLog messages written to /u01/app/oracle/diag/tnslsnr/cyylog/listener/alert/log.xmlListening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1521)))Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=cyylog)(PORT=1521)))Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1521)))STATUS of the LISTENER------------------------Alias LISTENERVersion TNSLSNR for Linux: Version 11.2.0.1.0 - ProductionStart Date 01-SEP-2016 11:23:31Uptime 0 days 0 hr. 0 min. 0 secTrace Level offSecurity ON: Local OS AuthenticationSNMP OFFListener Parameter File /u01/app/oracle/product/11.2.0/db_1/network/admin/listener.oraListener Log File /u01/app/oracle/diag/tnslsnr/cyylog/listener/alert/log.xmlListening Endpoints Summary... (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1521))) (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=cyylog)(PORT=1521)))The listener supports no servicesThe command completed successfully</code></pre><p>静默dbca建库</p><p>编辑应答文件</p><pre><code>[oracle@cyylog ~]$ vi etc/dbca.rsp[GENERAL]RESPONSEFILE_VERSION = &quot;11.2.0&quot;OPERATION_TYPE = &quot;createDatabase&quot;[CREATEDATABASE]GDBNAME = &quot;dbsrv2&quot;SID = &quot;dbsrv2&quot;TEMPLATENAME = &quot;General_Purpose.dbc&quot;CHARACTERSET = &quot;AL32UTF8&quot;</code></pre><p><strong><em>建库(我的finashell会闪屏,但是不影响使用，因为这个是因为无图形界面的情况)</em></strong></p><pre><code>[oracle@cyylog ~]$ dbca -silent -responseFile etc/dbca.rspEnter SYS user password: Enter SYSTEM user password: sh: /bin/ksh: No such file or directorysh: /bin/ksh: No such file or directoryCopying database files1% complete3% complete11% complete18% complete26% complete37% completeCreating and starting Oracle instance40% complete45% complete50% complete55% complete56% complete57% complete60% complete62% completeCompleting Database Creation66% complete70% complete73% complete74% complete85% complete96% complete100% completeLook at the log file Look at the log file &quot;/u01/app/oracle/cfgtoollogs/dbca/orcl11g/orcl11g.log&quot; for further details.</code></pre><pre><code>[oracle@cyylog ~]$ dbca -silent -responseFile etc/dbca.rspEnter SYS user password: Enter SYSTEM user password: sh: /bin/ksh: No such file or directorysh: /bin/ksh: No such file or directoryCopying database files1% complete3% complete11% complete18% complete26% complete37% completeCreating and starting Oracle instance40% complete45% complete50% complete55% complete56% complete57% complete60% complete62% completeCompleting Database Creation66% complete70% complete73% complete74% complete85% complete96% complete100% completeLook at the log file Look at the log file &quot;/u01/app/oracle/cfgtoollogs/dbca/orcl11g/orcl11g.log&quot; for further details.</code></pre><p>查看输出日志</p><pre><code>[oracle@cyylog ~]$ tailf /u01/app/oracle/cfgtoollogs/dbca/silent.logCopying database filesDBCA_PROGRESS : 1%DBCA_PROGRESS : 3%DBCA_PROGRESS : 11%DBCA_PROGRESS : 18%DBCA_PROGRESS : 26%DBCA_PROGRESS : 37%Creating and starting Oracle instanceDBCA_PROGRESS : 40%DBCA_PROGRESS : 45%DBCA_PROGRESS : 50%DBCA_PROGRESS : 55%DBCA_PROGRESS : 56%DBCA_PROGRESS : 60%DBCA_PROGRESS : 62%Completing Database CreationDBCA_PROGRESS : 66%DBCA_PROGRESS : 70%DBCA_PROGRESS : 73%DBCA_PROGRESS : 85%DBCA_PROGRESS : 96%DBCA_PROGRESS : 100%Database creation complete. For details check the logfiles at: /u01/app/oracle/cfgtoollogs/dbca/orcl11g.Database Information:Global Database Name:orcl11g.us.oracle.comSystem Identifier(SID):dbsrv2</code></pre><p><strong>至此完成数据库实例的创建。</strong></p><p>-———————————————————————————-</p><p>-———————————————————————————-</p><p><strong>附：</strong></p><p>删除实例：</p><pre><code>[oracle@cyylog ~]$ dbca -silent -deleteDatabase -sourcedb dbsrv2</code></pre><p>文章来源:<a href="https://www.cnblogs.com/zydev/p/5827207.html" target="_blank" rel="noopener">https://www.cnblogs.com/zydev/p/5827207.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker_002</title>
      <link href="2019/11/19/rong-qi/dockerfilee-002/"/>
      <url>2019/11/19/rong-qi/dockerfilee-002/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="Dockerfile-redis-5-0"><a href="#Dockerfile-redis-5-0" class="headerlink" title="Dockerfile_redis_5.0"></a>Dockerfile_redis_5.0</h4><pre class=" language-dockerfile"><code class="language-dockerfile">FROM debian:buster-slim# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get addedRUN groupadd -r -g 999 redis && useradd -r -g redis -u 999 redis# grab gosu for easy step-down from root# https://github.com/tianon/gosu/releasesENV GOSU_VERSION 1.11RUN set -eux; \# save list of currently installed packages for later so we can clean up    savedAptMark="$(apt-mark showmanual)"; \    apt-get update; \    apt-get install -y --no-install-recommends \        ca-certificates \        dirmngr \        gnupg \        wget \    ; \    rm -rf /var/lib/apt/lists/*; \    \    dpkgArch="$(dpkg --print-architecture | awk -F- '{ print $NF }')"; \    wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch"; \    wget -O /usr/local/bin/gosu.asc "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch.asc"; \    \# verify the signature    export GNUPGHOME="$(mktemp -d)"; \    gpg --batch --keyserver hkps://keys.openpgp.org --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4; \    gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu; \    gpgconf --kill all; \    rm -rf "$GNUPGHOME" /usr/local/bin/gosu.asc; \    \# clean up fetch dependencies    apt-mark auto '.*' > /dev/null; \    [ -z "$savedAptMark" ] || apt-mark manual $savedAptMark > /dev/null; \    apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \    \    chmod +x /usr/local/bin/gosu; \# verify that the binary works    gosu --version; \    gosu nobody trueENV REDIS_VERSION 5.0.8ENV REDIS_DOWNLOAD_URL http://download.redis.io/releases/redis-5.0.8.tar.gzENV REDIS_DOWNLOAD_SHA f3c7eac42f433326a8d981b50dba0169fdfaf46abb23fcda2f933a7552ee4ed7RUN set -eux; \    \    savedAptMark="$(apt-mark showmanual)"; \    apt-get update; \    apt-get install -y --no-install-recommends \        ca-certificates \        wget \        \        gcc \        libc6-dev \        make \    ; \    rm -rf /var/lib/apt/lists/*; \    \    wget -O redis.tar.gz "$REDIS_DOWNLOAD_URL"; \    echo "$REDIS_DOWNLOAD_SHA *redis.tar.gz" | sha256sum -c -; \    mkdir -p /usr/src/redis; \    tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1; \    rm redis.tar.gz; \    \# disable Redis protected mode [1] as it is unnecessary in context of Docker# (ports are not automatically exposed when running inside Docker, but rather explicitly by specifying -p / -P)# [1]: https://github.com/antirez/redis/commit/edd4d555df57dc84265fdfb4ef59a4678832f6da    grep -q '^#define CONFIG_DEFAULT_PROTECTED_MODE 1$' /usr/src/redis/src/server.h; \    sed -ri 's!^(#define CONFIG_DEFAULT_PROTECTED_MODE) 1$!\1 0!' /usr/src/redis/src/server.h; \    grep -q '^#define CONFIG_DEFAULT_PROTECTED_MODE 0$' /usr/src/redis/src/server.h; \# for future reference, we modify this directly in the source instead of just supplying a default configuration flag because apparently "if you specify any argument to redis-server, [it assumes] you are going to specify everything"# see also https://github.com/docker-library/redis/issues/4#issuecomment-50780840# (more exactly, this makes sure the default behavior of "save on SIGTERM" stays functional by default)    \    make -C /usr/src/redis -j "$(nproc)" all; \    make -C /usr/src/redis install; \    \# TODO https://github.com/antirez/redis/pull/3494 (deduplicate "redis-server" copies)    serverMd5="$(md5sum /usr/local/bin/redis-server | cut -d' ' -f1)"; export serverMd5; \    find /usr/local/bin/redis* -maxdepth 0 \        -type f -not -name redis-server \        -exec sh -eux -c ' \            md5="$(md5sum "$1" | cut -d" " -f1)"; \            test "$md5" = "$serverMd5"; \        ' -- '{}' ';' \        -exec ln -svfT 'redis-server' '{}' ';' \    ; \    \    rm -r /usr/src/redis; \    \    apt-mark auto '.*' > /dev/null; \    [ -z "$savedAptMark" ] || apt-mark manual $savedAptMark > /dev/null; \    find /usr/local -type f -executable -exec ldd '{}' ';' \        | awk '/=>/ { print $(NF-1) }' \        | sort -u \        | xargs -r dpkg-query --search \        | cut -d: -f1 \        | sort -u \        | xargs -r apt-mark manual \    ; \    apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \    \    redis-cli --version; \    redis-server --versionRUN mkdir /data && chown redis:redis /dataVOLUME /dataWORKDIR /dataCOPY docker-entrypoint.sh /usr/local/bin/ENTRYPOINT ["docker-entrypoint.sh"]EXPOSE 6379CMD ["redis-server"]</code></pre><h4 id="Dockerfile-alpine-httpd-2-4"><a href="#Dockerfile-alpine-httpd-2-4" class="headerlink" title="Dockerfile_alpine_httpd_2.4"></a>Dockerfile_alpine_httpd_2.4</h4><pre class=" language-dockerfile"><code class="language-dockerfile">FROM alpine:3.11# ensure www-data user existsRUN set -x \    && addgroup -g 82 -S www-data \    && adduser -u 82 -D -S -G www-data www-data# 82 is the standard uid/gid for "www-data" in Alpine# https://git.alpinelinux.org/cgit/aports/tree/main/apache2/apache2.pre-install?h=v3.8.1# https://git.alpinelinux.org/cgit/aports/tree/main/lighttpd/lighttpd.pre-install?h=v3.8.1# https://git.alpinelinux.org/cgit/aports/tree/main/nginx/nginx.pre-install?h=v3.8.1ENV HTTPD_PREFIX /usr/local/apache2ENV PATH $HTTPD_PREFIX/bin:$PATHRUN mkdir -p "$HTTPD_PREFIX" \    && chown www-data:www-data "$HTTPD_PREFIX"WORKDIR $HTTPD_PREFIXENV HTTPD_VERSION 2.4.43ENV HTTPD_SHA256 a497652ab3fc81318cdc2a203090a999150d86461acff97c1065dc910fe10f43# https://httpd.apache.org/security/vulnerabilities_24.htmlENV HTTPD_PATCHES=""# see https://httpd.apache.org/docs/2.4/install.html#requirementsRUN set -eux; \    \    runDeps=' \        apr-dev \        apr-util-dbm_db \        apr-util-dev \        apr-util-ldap \        perl \    '; \    apk add --no-cache --virtual .build-deps \        $runDeps \        ca-certificates \        coreutils \        dpkg-dev dpkg \        gcc \        gnupg \        libc-dev \        # mod_md        curl-dev \        jansson-dev \        # mod_proxy_html mod_xml2enc        libxml2-dev \        # mod_lua        lua-dev \        make \        # mod_http2        nghttp2-dev \        # mod_session_crypto        openssl \        openssl-dev \        pcre-dev \        tar \        # mod_deflate        zlib-dev \        # mod_brotli        brotli-dev \    ; \    \    ddist() { \        local f="$1"; shift; \        local distFile="$1"; shift; \        local success=; \        local distUrl=; \        for distUrl in \# https://issues.apache.org/jira/browse/INFRA-8753?focusedCommentId=14735394#comment-14735394            'https://www.apache.org/dyn/closer.cgi?action=download&filename=' \# if the version is outdated (or we're grabbing the .asc file), we might have to pull from the dist/archive :/            https://www-us.apache.org/dist/ \            https://www.apache.org/dist/ \            https://archive.apache.org/dist/ \        ; do \            if wget -O "$f" "$distUrl$distFile" && [ -s "$f" ]; then \                success=1; \                break; \            fi; \        done; \        [ -n "$success" ]; \    }; \    \    ddist 'httpd.tar.bz2' "httpd/httpd-$HTTPD_VERSION.tar.bz2"; \    echo "$HTTPD_SHA256 *httpd.tar.bz2" | sha256sum -c -; \    \# see https://httpd.apache.org/download.cgi#verify    ddist 'httpd.tar.bz2.asc' "httpd/httpd-$HTTPD_VERSION.tar.bz2.asc"; \    export GNUPGHOME="$(mktemp -d)"; \    for key in \# gpg: key 791485A8: public key "Jim Jagielski (Release Signing Key) <jim@apache.org>" imported        A93D62ECC3C8EA12DB220EC934EA76E6791485A8 \# gpg: key 995E35221AD84DFF: public key "Daniel Ruggeri (https://home.apache.org/~druggeri/) <druggeri@apache.org>" imported        B9E8213AEFB861AF35A41F2C995E35221AD84DFF \    ; do \        gpg --batch --keyserver ha.pool.sks-keyservers.net --recv-keys "$key"; \    done; \    gpg --batch --verify httpd.tar.bz2.asc httpd.tar.bz2; \    command -v gpgconf && gpgconf --kill all || :; \    rm -rf "$GNUPGHOME" httpd.tar.bz2.asc; \    \    mkdir -p src; \    tar -xf httpd.tar.bz2 -C src --strip-components=1; \    rm httpd.tar.bz2; \    cd src; \    \    patches() { \        while [ "$#" -gt 0 ]; do \            local patchFile="$1"; shift; \            local patchSha256="$1"; shift; \            ddist "$patchFile" "httpd/patches/apply_to_$HTTPD_VERSION/$patchFile"; \            echo "$patchSha256 *$patchFile" | sha256sum -c -; \            patch -p0 < "$patchFile"; \            rm -f "$patchFile"; \        done; \    }; \    patches $HTTPD_PATCHES; \    \    gnuArch="$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)"; \    ./configure \        --build="$gnuArch" \        --prefix="$HTTPD_PREFIX" \        --enable-mods-shared=reallyall \        --enable-mpms-shared=all \# PIE and hardening flags are unnecessary as Alpine enables them automatically (https://alpinelinux.org/about/)    ; \    make -j "$(nproc)"; \    make install; \    \    cd ..; \    rm -r src man manual; \    \    sed -ri \        -e 's!^(\s*CustomLog)\s+\S+!\1 /proc/self/fd/1!g' \        -e 's!^(\s*ErrorLog)\s+\S+!\1 /proc/self/fd/2!g' \        -e 's!^(\s*TransferLog)\s+\S+!\1 /proc/self/fd/1!g' \        "$HTTPD_PREFIX/conf/httpd.conf" \        "$HTTPD_PREFIX/conf/extra/httpd-ssl.conf" \    ; \    \    runDeps="$runDeps $( \        scanelf --needed --nobanner --format '%n#p' --recursive /usr/local \            | tr ',' '\n' \            | sort -u \            | awk 'system("[ -e /usr/local/lib/" $1 " ]") == 0 { next } { print "so:" $1 }' \    )"; \    apk add --no-network --virtual .httpd-rundeps $runDeps; \    apk del --no-network .build-deps; \    \# smoke test    httpd -v# https://httpd.apache.org/docs/2.4/stopping.html#gracefulstopSTOPSIGNAL SIGWINCHCOPY httpd-foreground /usr/local/bin/EXPOSE 80CMD ["httpd-foreground"]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker_001</title>
      <link href="2019/11/17/rong-qi/dockerfilee-001/"/>
      <url>2019/11/17/rong-qi/dockerfilee-001/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="Docker-MySQL-5-7"><a href="#Docker-MySQL-5-7" class="headerlink" title="Docker_MySQL 5.7"></a>Docker_MySQL 5.7</h4><pre class=" language-dockerfile"><code class="language-dockerfile">FROM debian:buster-slim# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get addedRUN groupadd -r mysql && useradd -r -g mysql mysqlRUN apt-get update && apt-get install -y --no-install-recommends gnupg dirmngr && rm -rf /var/lib/apt/lists/*# add gosu for easy step-down from rootENV GOSU_VERSION 1.7RUN set -x \    && apt-get update && apt-get install -y --no-install-recommends ca-certificates wget && rm -rf /var/lib/apt/lists/* \    && wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture)" \    && wget -O /usr/local/bin/gosu.asc "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture).asc" \    && export GNUPGHOME="$(mktemp -d)" \    && gpg --batch --keyserver ha.pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4 \    && gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu \    && gpgconf --kill all \    && rm -rf "$GNUPGHOME" /usr/local/bin/gosu.asc \    && chmod +x /usr/local/bin/gosu \    && gosu nobody true \    && apt-get purge -y --auto-remove ca-certificates wgetRUN mkdir /docker-entrypoint-initdb.dRUN apt-get update && apt-get install -y --no-install-recommends \# for MYSQL_RANDOM_ROOT_PASSWORD        pwgen \# for mysql_ssl_rsa_setup        openssl \# FATAL ERROR: please install the following Perl modules before executing /usr/local/mysql/scripts/mysql_install_db:# File::Basename# File::Copy# Sys::Hostname# Data::Dumper        perl \# install "xz-utils" for .sql.xz docker-entrypoint-initdb.d files        xz-utils \    && rm -rf /var/lib/apt/lists/*RUN set -ex; \# gpg: key 5072E1F5: public key "MySQL Release Engineering <mysql-build@oss.oracle.com>" imported    key='A4A9406876FCBD3C456770C88C718D3B5072E1F5'; \    export GNUPGHOME="$(mktemp -d)"; \    gpg --batch --keyserver ha.pool.sks-keyservers.net --recv-keys "$key"; \    gpg --batch --export "$key" > /etc/apt/trusted.gpg.d/mysql.gpg; \    gpgconf --kill all; \    rm -rf "$GNUPGHOME"; \    apt-key list > /dev/nullENV MYSQL_MAJOR 5.7ENV MYSQL_VERSION 5.7.29-1debian10RUN echo "deb http://repo.mysql.com/apt/debian/ buster mysql-${MYSQL_MAJOR}" > /etc/apt/sources.list.d/mysql.list# the "/var/lib/mysql" stuff here is because the mysql-server postinst doesn't have an explicit way to disable the mysql_install_db codepath besides having a database already "configured" (ie, stuff in /var/lib/mysql/mysql)# also, we set debconf keys to make APT a little quieterRUN { \        echo mysql-community-server mysql-community-server/data-dir select ''; \        echo mysql-community-server mysql-community-server/root-pass password ''; \        echo mysql-community-server mysql-community-server/re-root-pass password ''; \        echo mysql-community-server mysql-community-server/remove-test-db select false; \    } | debconf-set-selections \    && apt-get update && apt-get install -y mysql-server="${MYSQL_VERSION}" && rm -rf /var/lib/apt/lists/* \    && rm -rf /var/lib/mysql && mkdir -p /var/lib/mysql /var/run/mysqld \    && chown -R mysql:mysql /var/lib/mysql /var/run/mysqld \# ensure that /var/run/mysqld (used for socket and lock files) is writable regardless of the UID our mysqld instance ends up having at runtime    && chmod 777 /var/run/mysqld \# comment out a few problematic configuration values    && find /etc/mysql/ -name '*.cnf' -print0 \        | xargs -0 grep -lZE '^(bind-address|log)' \        | xargs -rt -0 sed -Ei 's/^(bind-address|log)/#&/' \# don't reverse lookup hostnames, they are usually another container    && echo '[mysqld]\nskip-host-cache\nskip-name-resolve' > /etc/mysql/conf.d/docker.cnfVOLUME /var/lib/mysqlCOPY docker-entrypoint.sh /usr/local/bin/RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compatENTRYPOINT ["docker-entrypoint.sh"]EXPOSE 3306 33060CMD ["mysqld"]</code></pre><h4 id="Docker-NGINX-1-17-9"><a href="#Docker-NGINX-1-17-9" class="headerlink" title="Docker_NGINX_1.17.9"></a>Docker_NGINX_1.17.9</h4><pre class=" language-dockerfile"><code class="language-dockerfile">FROM alpine:3.10LABEL maintainer="NGINX Docker Maintainers <docker-maint@nginx.com>"ENV NGINX_VERSION 1.17.9ENV NJS_VERSION   0.3.9ENV PKG_RELEASE   1RUN set -x \# create nginx user/group first, to be consistent throughout docker variants    && addgroup -g 101 -S nginx \    && adduser -S -D -H -u 101 -h /var/cache/nginx -s /sbin/nologin -G nginx -g nginx nginx \    && apkArch="$(cat /etc/apk/arch)" \    && nginxPackages=" \        nginx=${NGINX_VERSION}-r${PKG_RELEASE} \        nginx-module-xslt=${NGINX_VERSION}-r${PKG_RELEASE} \        nginx-module-geoip=${NGINX_VERSION}-r${PKG_RELEASE} \        nginx-module-image-filter=${NGINX_VERSION}-r${PKG_RELEASE} \        nginx-module-njs=${NGINX_VERSION}.${NJS_VERSION}-r${PKG_RELEASE} \    " \    && case "$apkArch" in \        x86_64) \# arches officially built by upstream            set -x \            && KEY_SHA512="e7fa8303923d9b95db37a77ad46c68fd4755ff935d0a534d26eba83de193c76166c68bfe7f65471bf8881004ef4aa6df3e34689c305662750c0172fca5d8552a *stdin" \            && apk add --no-cache --virtual .cert-deps \                openssl \            && wget -O /tmp/nginx_signing.rsa.pub https://nginx.org/keys/nginx_signing.rsa.pub \            && if [ "$(openssl rsa -pubin -in /tmp/nginx_signing.rsa.pub -text -noout | openssl sha512 -r)" = "$KEY_SHA512" ]; then \                echo "key verification succeeded!"; \                mv /tmp/nginx_signing.rsa.pub /etc/apk/keys/; \            else \                echo "key verification failed!"; \                exit 1; \            fi \            && apk del .cert-deps \            && apk add -X "https://nginx.org/packages/mainline/alpine/v$(egrep -o '^[0-9]+\.[0-9]+' /etc/alpine-release)/main" --no-cache $nginxPackages \            ;; \        *) \# we're on an architecture upstream doesn't officially build for# let's build binaries from the published packaging sources            set -x \            && tempDir="$(mktemp -d)" \            && chown nobody:nobody $tempDir \            && apk add --no-cache --virtual .build-deps \                gcc \                libc-dev \                make \                openssl-dev \                pcre-dev \                zlib-dev \                linux-headers \                libxslt-dev \                gd-dev \                geoip-dev \                perl-dev \                libedit-dev \                mercurial \                bash \                alpine-sdk \                findutils \            && su nobody -s /bin/sh -c " \                export HOME=${tempDir} \                && cd ${tempDir} \                && hg clone https://hg.nginx.org/pkg-oss \                && cd pkg-oss \                && hg up ${NGINX_VERSION}-${PKG_RELEASE} \                && cd alpine \                && make all \                && apk index -o ${tempDir}/packages/alpine/${apkArch}/APKINDEX.tar.gz ${tempDir}/packages/alpine/${apkArch}/*.apk \                && abuild-sign -k ${tempDir}/.abuild/abuild-key.rsa ${tempDir}/packages/alpine/${apkArch}/APKINDEX.tar.gz \                " \            && cp ${tempDir}/.abuild/abuild-key.rsa.pub /etc/apk/keys/ \            && apk del .build-deps \            && apk add -X ${tempDir}/packages/alpine/ --no-cache $nginxPackages \            ;; \    esac \# if we have leftovers from building, let's purge them (including extra, unnecessary build deps)    && if [ -n "$tempDir" ]; then rm -rf "$tempDir"; fi \    && if [ -n "/etc/apk/keys/abuild-key.rsa.pub" ]; then rm -f /etc/apk/keys/abuild-key.rsa.pub; fi \    && if [ -n "/etc/apk/keys/nginx_signing.rsa.pub" ]; then rm -f /etc/apk/keys/nginx_signing.rsa.pub; fi \# Bring in gettext so we can get `envsubst`, then throw# the rest away. To do this, we need to install `gettext`# then move `envsubst` out of the way so `gettext` can# be deleted completely, then move `envsubst` back.    && apk add --no-cache --virtual .gettext gettext \    && mv /usr/bin/envsubst /tmp/ \    \    && runDeps="$( \        scanelf --needed --nobanner /tmp/envsubst \            | awk '{ gsub(/,/, "\nso:", $2); print "so:" $2 }' \            | sort -u \            | xargs -r apk info --installed \            | sort -u \    )" \    && apk add --no-cache $runDeps \    && apk del .gettext \    && mv /tmp/envsubst /usr/local/bin/ \# Bring in tzdata so users could set the timezones through the environment# variables    && apk add --no-cache tzdata \# forward request and error logs to docker log collector    && ln -sf /dev/stdout /var/log/nginx/access.log \    && ln -sf /dev/stderr /var/log/nginx/error.logEXPOSE 80STOPSIGNAL SIGTERMCMD ["nginx", "-g", "daemon off;"]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker_000</title>
      <link href="2019/11/15/rong-qi/dockerfilee-000/"/>
      <url>2019/11/15/rong-qi/dockerfilee-000/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="Dockerfile构建镜像"><a href="#Dockerfile构建镜像" class="headerlink" title="Dockerfile构建镜像"></a>Dockerfile构建镜像</h4><pre><code>通过Dockerfile创建镜像虽然可以自己制作 rootfs(见&#39;容器文件系统那些事儿&#39;)，但Docker 提供了一种更便捷的方式，叫作 Dockerfiledocker build命令用于根据给定的Dockerfile和上下文以构建Docker镜像。docker build语法：# docker build [OPTIONS] &lt;PATH | URL | -&gt;1. 常用选项说明--build-arg，设置构建时的变量--no-cache，默认false。设置该选项，将不使用Build Cache构建镜像--pull，默认false。设置该选项，总是尝试pull镜像的最新版本--compress，默认false。设置该选项，将使用gzip压缩构建的上下文--disable-content-trust，默认true。设置该选项，将对镜像进行验证--file, -f，Dockerfile的完整路径，默认值为‘PATH/Dockerfile’--isolation，默认--isolation=&quot;default&quot;，即Linux命名空间；其他还有process或hyperv--label，为生成的镜像设置metadata--squash，默认false。设置该选项，将新构建出的多个层压缩为一个新层，但是将无法在多个镜像之间共享新层；设置该选项，实际上是创建了新image，同时保留原有image。--tag, -t，镜像的名字及tag，通常name:tag或者name格式；可以在一次构建中为一个镜像设置多个tag--network，默认default。设置该选项，Set the networking mode for the RUN instructions during build--quiet, -q ，默认false。设置该选项，Suppress the build output and print image ID on success--force-rm，默认false。设置该选项，总是删除掉中间环节的容器--rm，默认--rm=true，即整个构建过程成功后删除中间环节的容器2. PATH | URL | -说明：给出命令执行的上下文。上下文可以是构建执行所在的本地路径，也可以是远程URL，如Git库、tarball或文本文件等。如果是Git库，如https://github.com/docker/rootfs.git#container:docker，则隐含先执行git clone --depth 1 --recursive，到本地临时目录；然后再将该临时目录发送给构建进程。构建镜像的进程中，可以通过ADD命令将上下文中的任何文件（注意文件必须在上下文中）加入到镜像中。-表示通过STDIN给出Dockerfile或上下文。示例：    docker build - &lt; Dockerfile说明：该构建过程只有Dockerfile，没有上下文    docker build - &lt; context.tar.gz说明：其中Dockerfile位于context.tar.gz的根路径    docker build -t champagne/bbauto:latest -t champagne/bbauto:v2.1 .    docker build -f dockerfiles/Dockerfile.debug -t myapp_debug .2.1、 创建镜像所在的文件夹和Dockerfile文件           命令：          1、mkdir sinatra          2、cd sinatra          3、touch Dockerfile 2.2、 在Dockerfile文件中写入指令，每一条指令都会更新镜像的信息例如：          # This is a comment          FROM ubuntu:14.04          MAINTAINER tiger tiger@localhost.localdomain         RUN apt-get update &amp;&amp; apt-get install -y ruby ruby-dev          RUN gem install sinatra           格式说明：           每行命令都是以  INSTRUCTION statement 形式，就是命令+ 清单的模式。命令要大写，&quot;#&quot;是注解。          FROM 命令是告诉docker 我们的镜像什么。          MAINTAINER 是描述 镜像的创建人。          RUN 命令是在镜像内部执行。就是说他后面的命令应该是针对镜像可以运行的命令。  2.3、创建镜像           命令：docker build -t tiger/sinatra:v2 .          docker build  是docker创建镜像的命令          -t 是标识新建的镜像属于 ouruser的           sinatra是仓库的名称          ：v2 是tag           &quot;.&quot;是用来指明 我们的使用的Dockerfile文件当前目录的          详细执行过程：        [root@master sinatra]# docker build -t tiger/sinatra:v2 .         Sending build context to Docker daemon 2.048 kB        Step 1 : FROM daocloud.io/ubuntu:14.04        Trying to pull repository daocloud.io/ubuntu ...         14.04: Pulling from daocloud.io/ubuntu        f3ead5e8856b: Pull complete         Digest: sha256:ea2b82924b078d9c8b5d3f0db585297a5cd5b9c2f7b60258cdbf9d3b9181d828         ---&gt; 2ff3b426bbaa        Step 2 : MAINTAINER tiger tiger@localhost.localdomain         ---&gt; Running in 948396c9edaa         ---&gt; 227da301bad8        Removing intermediate container 948396c9edaa        Step 3 : RUN apt-get update &amp;&amp; apt-get install -y ruby ruby-dev         ...        Step 4 : RUN gem install sinatra        ---&gt; Running in 89234cb493d9 2.4、创建完成后，从镜像创建容器          #docker run -t -i tiger/sinatra:v2 /bin/bash</code></pre><p>Dockerfile分为四个部分: 基础镜像信息、维护者信息、镜像操作指令和容器启动指令。 即FROM、MAINTAINER、RUN、CMD四个部分</p><h5 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h5><pre><code>FROM         指定所创建镜像的基础镜像MAINTAINER   制定维护者信息RUN          运行命令CMD          容器启动是默认执行的命令LABEL        指定生成镜像的元数据标签信息EXPOSE       声明镜像内服务所监听的端口ENV          指定环境变量ADD          复制指定src路径的内容到容器的dest路径下，如果src为tar文件，则自动解压到dest路径下copy         复制指定src路径的内容到镜像的dest路径下ENTERPOINT   指定镜像的默认入口VOLUME       创建数据卷挂载点USER         指定运行容器是的用户名或UIDWORKDIR      配置工作目录ARG          指定镜像内使用的参数ONBUILD      配置当所创建的镜像作为其他镜像的基础镜像时，所执行创建操作指令STOPSIGAL    容器退出信号值HEALTHCHECK  如何进行健康检查SHELL        指定使用shell的默认shell类型</code></pre><h5 id="nginx-dockerfile示例"><a href="#nginx-dockerfile示例" class="headerlink" title="nginx-dockerfile示例"></a>nginx-dockerfile示例</h5><p>vim Dockerfile</p><pre><code>FROM centos:7.2.1511ENV TZ=Asia/ShanghaiRUN yum -y install epel* \    yum -y install gcc openssl openssl-devel  pcre-devel zlib-develADD nginx-1.14.2.tar.gz /opt/WORKDIR /opt/nginx-1.14.2RUN ./configure --prefix=/opt/nginx  --http-log-path=/opt/nginx/logs/access.log --error-log-path=/opt/nginx/logs/error.log --http-client-body-temp-path=/opt/nginx/client/  --http-proxy-temp-path=/opt/nginx/proxy/  --with-http_stub_status_module --with-file-aio --with-http_flv_module --with-http_gzip_static_module --with-stream --with-threads --user=www --group=wwwRUN make &amp;&amp; make installRUN groupadd www &amp;&amp; useradd -g www wwwWORKDIR /opt/nginxRUN rm -rf /opt/nginx-1.14.2ENV NGINX_HOME=/opt/nginxENV PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/nginx/sbinEXPOSE 80 443CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></pre><p>需要先下载nginx-1.14.2.tar.gz在Dockerfile同级目录下，然后执行如下命令 docker build -t nginx_image ./Dockerfile</p><h5 id="tomcat-dockerfile示例"><a href="#tomcat-dockerfile示例" class="headerlink" title="tomcat-dockerfile示例"></a>tomcat-dockerfile示例</h5><pre><code>FROM centos:7.4.1708ADD jdk-8u171-linux-x64.tar.gz /usr/local/ADD apache-tomcat-7.0.88.tar.gz /usr/local/WORKDIR /usr/local/RUN mv jdk1.8.0_171 jdk &amp;&amp; mv apache-tomcat-7.0.88 tomcatENV JAVA_HOME=/usr/local/jdkENV CLASS_PATH=$JAVA_HOME/lib:$JAVA_HOME/jre/libENV PATH=$JAVA_HOME/bin:$PATHENV CATALINA_HOME /usr/local/tomcatEXPOSE 8080CMD /usr/local/tomcat/bin/catalina.sh run</code></pre><p>需要先下载jdk和tomcat在dockerfile的同级目录下，然后执行如下命令 docker build -t tomcat_image ./Dockerfile</p><h4 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h4><p><img src="https://i.loli.net/2019/06/10/5cfe19e2a618834176.jpg" alt=""></p><pre><code>小规模docker环境大部分运行在单台主机上，如果公司大规模采用docker，那么多个宿主机上的docker如何互联Docker默认的内部ip为172.17.42.0网段，所以必须要修改其中一台的默认网段以免ip冲突。#vim /etc/sysconfig/docker-networkDOCKER_NETWORK_OPTIONS= --bip=172.18.42.1/16#rebootdocker 130上：#route add -net 172.18.0.0/16 gw 192.168.18.128docker 128上：#route add -net 172.17.0.0/16 gw 192.168.18.130现在两台宿主机里的容器就可以通信了。</code></pre><h4 id="容器固定IP"><a href="#容器固定IP" class="headerlink" title="容器固定IP"></a>容器固定IP</h4><pre><code>docker安装后，默认会创建三种网络类型，bridge、host和none显示当前网络：# docker network listNETWORK ID            NAME                DRIVER              SCOPE90b22f633d2f          bridge              bridge              locale0b365da7fd2          host                host                localda7b7a090837         none                null                localbridge:网络桥接默认情况下启动、创建容器都是用该模式，所以每次docker容器重启时会按照顺序获取对应ip地址，这就导致容器每次重启，ip都发生变化none：无指定网络启动容器时，可以通过–network=none,docker容器不会分配局域网iphost：主机网络docker容器的网络会附属在主机上，两者是互通的。创建固定ip容器1、创建自定义网络类型，并且指定网段#docker network create --subnet=192.168.0.0/16 staticnet通过docker network ls可以查看到网络类型中多了一个staticnet2、使用新的网络类型创建并启动容器#docker run -it --name userserver --net staticnet --ip 192.168.0.2 centos:6 /bin/bash通过docker inspect可以查看容器ip为192.168.0.2，关闭容器并重启，发现容器ip并未发生改变</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zabbix微信报警设置</title>
      <link href="2019/11/05/jian-kong/zabbix-pei-zhi-qi-ye-wei-xin-bao-jing/"/>
      <url>2019/11/05/jian-kong/zabbix-pei-zhi-qi-ye-wei-xin-bao-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="zabbix-微信报警设置"><a href="#zabbix-微信报警设置" class="headerlink" title="zabbix 微信报警设置"></a>zabbix 微信报警设置</h2><h4 id="一、主要获取三个参数-企业ID、用户账号、AgentId-和Secret："><a href="#一、主要获取三个参数-企业ID、用户账号、AgentId-和Secret：" class="headerlink" title="一、主要获取三个参数:企业ID、用户账号、AgentId,和Secret："></a>一、主要获取三个参数:企业ID、用户账号、AgentId,和Secret：</h4><h5 id="1-获取企业ID"><a href="#1-获取企业ID" class="headerlink" title="1.获取企业ID"></a>1.获取企业ID</h5><p><img src="https://s1.ax1x.com/2020/04/24/J0OeUI.png" alt="J0OeUI.png"></p><h5 id="2-获取AgentId-和Secret3"><a href="#2-获取AgentId-和Secret3" class="headerlink" title="2.获取AgentId,和Secret3"></a>2.获取AgentId,和Secret3</h5><p>这里要先点通讯录创建一个部门，然后再点应用小程序创建应用，填写logo、名称、和选择部门就可以了</p><p><a href="https://imgchr.com/i/J0Om5t" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/24/J0Om5t.png" alt="J0Om5t.png"></a></p><h5 id="3-获取用户账号"><a href="#3-获取用户账号" class="headerlink" title="3.获取用户账号"></a>3.获取用户账号</h5><p><img src="https://s1.ax1x.com/2020/04/24/J0OYan.png" alt="J0OYan.png"></p><p><img src="https://s1.ax1x.com/2020/04/24/J0OaGV.png" alt="J0OaGV.png"></p><h5 id="4-测试gentId-和Secret"><a href="#4-测试gentId-和Secret" class="headerlink" title="4.测试gentId,和Secret"></a>4.测试gentId,和Secret</h5><p>这个是接口调用测试gentId,和Secret的地址：<a href="https://work.weixin.qq.com/api/devtools/devtool.php" target="_blank" rel="noopener">https://work.weixin.qq.com/api/devtools/devtool.php</a></p><p>这里看到有HTTP/1.1 200 OK 就说明接口有效了，其它的不管。</p><p><img src="https://s1.ax1x.com/2020/04/24/J0OyZ9.png" alt="J0OyZ9.png"></p><p><img src="https://s1.ax1x.com/2020/04/24/J0O2Px.png" alt="J0O2Px.png"></p><h4 id="二、调用的shell脚本方式，脚本如下："><a href="#二、调用的shell脚本方式，脚本如下：" class="headerlink" title="二、调用的shell脚本方式，脚本如下："></a>二、调用的shell脚本方式，脚本如下：</h4><h6 id="这里要注意的是填写正确的通讯录-部门ID，可以点那个下线三个点那里。"><a href="#这里要注意的是填写正确的通讯录-部门ID，可以点那个下线三个点那里。" class="headerlink" title="这里要注意的是填写正确的通讯录 部门ID，可以点那个下线三个点那里。"></a>这里要注意的是填写正确的通讯录 部门ID，可以点那个下线三个点那里。</h6><p><img src="https://s1.ax1x.com/2020/04/24/J0O7dA.png" alt="J0O7dA.png"></p><pre class=" language-shell"><code class="language-shell">[root@cyy alertscripts]# vim wechat.sh#!/usr/bin/env bash#!/usr/bin/env bash## Author: cyylog# Email: cyylog@aliyun.com# Date: 2019/09/25# Github:    https://github.com/cyylog# Usage:    Wechat alert script for zabbix# if [ $# -eq 0 ] || [[ "$1" == "-h" || "$1" == "--help" ]];then        echo "Usage of $0:"        echo -e " --CorpID=string"        echo -e " --Secret=string"        echo -e " --AgentID=string"        echo -e " --UserID=string"        echo -e " --Msg=string"        exitfi#ops=(-c -s -a -u)#args=(CorpID Secret AgentID UserID)#while [ $# -gt 0 ];do#    [ "$1" == "-m" ] && Msg="$2" && shift 2#    for i in {0..3};do#        [ "$1" == "${ops[i]}" ] &&  eval ${args[i]}="$2"#    done#    shift 2#donefor i in "$@";do        echo $i|grep Msg &> /dev/null && msg=$(echo $i|sed 's/.*=//') && Msg="$msg" && continue        eval "$(echo $i|sed 's/--//')"done#echo $CorpID#echo $Secret#echo $UserID#echo $AgentID#echo $Msg#GURL="https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=$CorpID&corpsecret=$Secret"Token=$(/usr/bin/curl -s -G $GURL |awk -F \" '{print $10}')PURL="https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=$Token"Info(){        printf '{\n'        printf '\t"touser": "'"$UserID"\"",\n"        printf '\t"msgtype": "text",\n'        printf '\t"agentid": "'"$AgentID"\"",\n"        printf '\t"text": {\n'        printf '\t\t"content": "'"$Msg"\""\n"        printf '\t},\n'        printf '\t"safe":"0"\n'        printf '}\n'}/usr/bin/curl --data-ascii "$(Info)" $PURLecho[root@cyy alertscripts]# chmod +x wechat.sh[root@cyy alertscripts]# ./wechat.sh  "这里一个测试"     //可以这样直接调试，然后登陆到企业微信查看该部门的群成员是否收到此信息脚本测试通过后就是在zabbix控制台上设置了</code></pre><h4 id="三、zabbix-控制台添加新媒体"><a href="#三、zabbix-控制台添加新媒体" class="headerlink" title="三、zabbix 控制台添加新媒体"></a>三、zabbix 控制台添加新媒体</h4><h5 id="1-点管理-gt-报警媒介类型-gt-创建媒介类型"><a href="#1-点管理-gt-报警媒介类型-gt-创建媒介类型" class="headerlink" title="1.点管理 -&gt; 报警媒介类型 -&gt; 创建媒介类型"></a>1.点管理 -&gt; 报警媒介类型 -&gt; 创建媒介类型</h5><p><a href="https://imgchr.com/i/J0X1W6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/24/J0X1W6.png" alt="J0X1W6.png"></a></p><pre class=" language-shell"><code class="language-shell">--AgentID=1000002--CorpID=ww74c********56c    --Secret=-c-3Xw*****************j-Zj6cw--Msg={ALERT.MESSAGE}--UserID={ALERT.SENDTO}</code></pre><h5 id="2-然后再设置上用户：点管理-—-gt-创建用户（微信报警的用户）"><a href="#2-然后再设置上用户：点管理-—-gt-创建用户（微信报警的用户）" class="headerlink" title="2.然后再设置上用户：点管理 —&gt; 创建用户（微信报警的用户）"></a>2.然后再设置上用户：点管理 —&gt; 创建用户（微信报警的用户）</h5><p><img src="https://s1.ax1x.com/2020/04/24/J0XYOe.png" alt="J0XYOe.png"></p><h5 id="3-再点用户旁边的-报警媒介-进行设置（收件人要填写用户的账号）"><a href="#3-再点用户旁边的-报警媒介-进行设置（收件人要填写用户的账号）" class="headerlink" title="3.再点用户旁边的 报警媒介 进行设置（收件人要填写用户的账号）"></a>3.再点用户旁边的 报警媒介 进行设置（收件人要填写用户的账号）</h5><p><strong>第一步的第3点获取的账号</strong></p><p><img src="https://s1.ax1x.com/2020/04/24/J0XaTA.png" alt="J0XaTA.png"></p><h6 id="到这里就基本都设置完成了，可以设置个触发器和动作来测试脚本。"><a href="#到这里就基本都设置完成了，可以设置个触发器和动作来测试脚本。" class="headerlink" title="到这里就基本都设置完成了，可以设置个触发器和动作来测试脚本。"></a>到这里就基本都设置完成了，可以设置个触发器和动作来测试脚本。</h6>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Gitlab</title>
      <link href="2019/10/05/devops/da-jian-gitlab/"/>
      <url>2019/10/05/devops/da-jian-gitlab/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>Gitlab Server 部署</p><h3 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h3><pre><code>1.系统版本：CentOS7.42.Gitlab版本：gitlab-ee 11.0.13.初始化系统环境4.关闭防火墙[root@localhost ~]#  systemctl stop iptables firewalld[root@localhost ~]#  systemctl disable iptables firewalld5.开启邮件服务[root@vm1 ~]# systemctl start postfix[root@vm1 ~]# systemctl enable postfix6.关闭SELinux[root@localhost ~]#  sed -ri &#39;/SELINUX=/cSELINUX=disabled&#39; /etc/selinux/config[root@localhost ~]#  setenforce 0           # 临时关闭SELinux[root@localhost ~]#  reboot</code></pre><h3 id="2、部署Gitlab"><a href="#2、部署Gitlab" class="headerlink" title="2、部署Gitlab"></a>2、部署Gitlab</h3><pre><code>1.安装Gitlab社区版/企业版2.安装gitlab依赖包[root@localhost ~]# yum install -y curl openssh-server openssh-clients postfix cronie policycoreutils-python# gitlab-ce 10.x.x以后的版本需要依赖policycoreutils-python3.开启postfix，并设置开机自启[root@localhost ~]# systemctl start postfix;systemctl enable postfix4.选择添加yum源安装gitlab(根据需求配置源)（1）添加阿里源# vim /etc/yum.repos.d/gitlab-ce.repo[gitlab-ce]name=gitlab-cebaseurl=http://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7Repo_gpgcheck=0Enabled=1Gpgkey=https://packages.gitlab.com/gpg.key（2） 添加清华源# vim gitlab-ce.repo[gitlab-ce]name=Gitlab CE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/gpgcheck=0enabled=1# vim gitlab-ee.repo[gitlab-ee]name=Gitlab EE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ee/yum/el$releasever/gpgcheck=0enabled=1# vim runner_gitlab-ci-multi-runner.repo[runner_gitlab-ci-multi-runner]name=runner_gitlab-ci-multi-runnerbaseurl=https://packages.gitlab.com/runner/gitlab-ci-multi-runner/el/7/$basearchrepo_gpgcheck=1gpgcheck=0enabled=1gpgkey=https://packages.gitlab.com/runner/gitlab-ci-multi-runner/gpgkeysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300[runner_gitlab-ci-multi-runner-source]name=runner_gitlab-ci-multi-runner-sourcebaseurl=https://packages.gitlab.com/runner/gitlab-ci-multi-runner/el/7/SRPMSrepo_gpgcheck=1gpgcheck=0enabled=1gpgkey=https://packages.gitlab.com/runner/gitlab-ci-multi-runner/gpgkeysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300(3) 添加官方源curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash5.安装包下载https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/https://mirrors.tuna.tsinghua.edu.cn/gitlab-ee/yum/el7/6.根据需要选择ce/ee[root@localhost ~]# yum -y install gitlab-ce                    # 自动安装最新版[root@localhost ~]# yum -y install gitlab-ce-x.x.x              # 安装指定版本Gitlab[root@localhost ~]# yum -y install gitlab-ce warning: gitlab-ce-10.7.2-ce.0.el7.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID f27eab47: NOKEYPreparing...                          ################################# [100%]Updating / installing...   1:gitlab-ce-10.7.2-ce.0.el7        ################################# [100%]It looks like GitLab has not been configured yet; skipping the upgrade script.       *.                  *.      ***                 ***     *****               *****    .******             *******    ********            ********   ,,,,,,,,,***********,,,,,,,,,  ,,,,,,,,,,,*********,,,,,,,,,,,  .,,,,,,,,,,,*******,,,,,,,,,,,,      ,,,,,,,,,*****,,,,,,,,,.         ,,,,,,,****,,,,,,            .,,,***,,,,                ,*,.     _______ __  __          __    / ____(_) /_/ /   ____ _/ /_   / / __/ / __/ /   / __ `/ __ \  / /_/ / / /_/ /___/ /_/ / /_/ /  \____/_/\__/_____/\__,_/_.___/Thank you for installing GitLab!GitLab was unable to detect a valid hostname for your instance.Please configure a URL for your GitLab instance by setting `external_url`configuration in /etc/gitlab/gitlab.rb file.Then, you can start your GitLab instance by running the following command:  sudo gitlab-ctl reconfigureFor a comprehensive list of configuration options please see the Omnibus GitLab readmehttps://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md</code></pre><p>###3、配置 Gitlab</p><h4 id="1、查看Gitlab版本"><a href="#1、查看Gitlab版本" class="headerlink" title="1、查看Gitlab版本"></a>1、查看Gitlab版本</h4><pre><code>[root@localhost ~]# head -1 /opt/gitlab/version-manifest.txtgitlab-ce 10.1.1</code></pre><h4 id="2、Gitlab-配置文登录链接"><a href="#2、Gitlab-配置文登录链接" class="headerlink" title="2、Gitlab 配置文登录链接"></a>2、Gitlab 配置文登录链接</h4><pre><code>#设置登录链接[root@localhost ~]# vim /etc/gitlab/gitlab.rb***## GitLab URL##! URL on which GitLab will be reachable.##! For more details on configuring external_url see:##! https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlab# 没有域名，可以设置为本机IP地址external_url &#39;http://172.17.0.61&#39;***[root@localhost ~]# grep &quot;^external_url&quot; /etc/gitlab/gitlab.rbexternal_url &#39;http://172.17.0.61&#39;     #绑定监听的域名或IP</code></pre><h4 id="3、初始化-Gitlab-第一次使用配置时间较长"><a href="#3、初始化-Gitlab-第一次使用配置时间较长" class="headerlink" title="3、初始化 Gitlab (第一次使用配置时间较长)"></a>3、初始化 Gitlab (第一次使用配置时间较长)</h4><pre><code> [root@localhost ~]# gitlab-ctl reconfigure   .....</code></pre><h4 id="4、启动-Gitlab-服务"><a href="#4、启动-Gitlab-服务" class="headerlink" title="4、启动 Gitlab 服务"></a>4、启动 Gitlab 服务</h4><pre><code>[root@vm1 ~]# gitlab-ctl startok: run: gitaly: (pid 22896) 2922sok: run: gitlab-monitor: (pid 22914) 2921sok: run: gitlab-workhorse: (pid 22882) 2922sok: run: logrotate: (pid 22517) 2987sok: run: nginx: (pid 22500) 2993sok: run: node-exporter: (pid 22584) 2974sok: run: postgres-exporter: (pid 22946) 2919sok: run: postgresql: (pid 22250) 3047sok: run: prometheus: (pid 22931) 2920sok: run: redis: (pid 22190) 3053sok: run: redis-exporter: (pid 22732) 2962sok: run: sidekiq: (pid 22472) 3005sok: run: unicorn: (pid 22433) 3011s[root@vm1 ~]# [root@vm1 ~]# lsof -i:80COMMAND   PID       USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEnginx   22500       root    7u  IPv4  50923      0t0  TCP *:http (LISTEN)nginx   22501 gitlab-www    7u  IPv4  50923      0t0  TCP *:http (LISTEN)[root@vm1 ~]# </code></pre><h4 id="5、Gitlab-设置-HTTPS-方式"><a href="#5、Gitlab-设置-HTTPS-方式" class="headerlink" title="5、Gitlab 设置 HTTPS 方式"></a>5、Gitlab 设置 HTTPS 方式</h4><pre><code>如果想要以上的 https 方式正常生效使用，则需要把 letsencrypt 自动生成证书的配置打开，这样在执行重新让配置生效命令 (gitlab-ctl reconfigure) 的时候会自动给域名生成免费的证书并自动在 gitlab 自带的 nginx 中加上相关的跳转配置，都是全自动的，非常方便。letsencrypt[&#39;enable&#39;] = true letsencrypt[&#39;contact_emails&#39;] = [&#39;caryyu@qq.com&#39;]     # 这应该是一组要添加为联系人的电子邮件地址</code></pre><h4 id="6、Gitlab-添加smtp邮件功能"><a href="#6、Gitlab-添加smtp邮件功能" class="headerlink" title="6、Gitlab 添加smtp邮件功能"></a>6、Gitlab 添加smtp邮件功能</h4><pre><code>[root@vm1 ~]# vim /etc/gitlab/gitlab.rbpostfix 并非必须的；根据具体情况配置，以 SMTP 的为例配置邮件服务器来实现通知；参考配置如下： ### Email Settings  gitlab_rails[&#39;gitlab_email_enabled&#39;] = true  gitlab_rails[&#39;gitlab_email_from&#39;] = &#39;system.notice@qq.com&#39;  gitlab_rails[&#39;gitlab_email_display_name&#39;] = &#39;gitlab.notice&#39;  gitlab_rails[&#39;gitlab_email_reply_to&#39;] = &#39;system.notice@qq.com&#39;  gitlab_rails[&#39;gitlab_email_subject_suffix&#39;] = &#39;gitlab&#39;  ### GitLab email server settings ###! Docs: https://docs.gitlab.com/omnibus/settings/smtp.html ###! **Use smtp instead of sendmail/postfix.**   gitlab_rails[&#39;smtp_enable&#39;] = true  gitlab_rails[&#39;smtp_address&#39;] = &quot;smtp.qq.com&quot;  gitlab_rails[&#39;smtp_port&#39;] = 465  gitlab_rails[&#39;smtp_user_name&#39;] = &quot;system.notice@qq.com&quot;  gitlab_rails[&#39;smtp_password&#39;] = &quot;xxxxx&quot;  gitlab_rails[&#39;smtp_domain&#39;] = &quot;qq.com&quot;  gitlab_rails[&#39;smtp_authentication&#39;] = &quot;login&quot;  gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true  gitlab_rails[&#39;smtp_tls&#39;] = true[root@vm1 ~]# grep -P &quot;^[^#].*smtp_|user_email|gitlab_email&quot; /etc/gitlab/gitlab.rbgitlab_rails[&#39;gitlab_email_enabled&#39;] = truegitlab_rails[&#39;gitlab_email_from&#39;] = &#39;username@domain.cn&#39;gitlab_rails[&#39;gitlab_email_display_name&#39;] = &#39;Admin&#39;gitlab_rails[&#39;gitlab_email_reply_to&#39;] = &#39;usernamei@domain.cn&#39;gitlab_rails[&#39;gitlab_email_subject_suffix&#39;] = &#39;[gitlab]&#39;gitlab_rails[&#39;smtp_enable&#39;] = truegitlab_rails[&#39;smtp_address&#39;] = &quot;smtp.exmail.qq.com&quot;gitlab_rails[&#39;smtp_port&#39;] = 25 gitlab_rails[&#39;smtp_user_name&#39;] = &quot;username@domain.cn&quot;gitlab_rails[&#39;smtp_password&#39;] = &quot;password&quot;gitlab_rails[&#39;smtp_domain&#39;] = &quot;domain.cn&quot;gitlab_rails[&#39;smtp_authentication&#39;] = &quot;login&quot;gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = truegitlab_rails[&#39;smtp_tls&#39;] = falseuser[&#39;git_user_email&#39;] = &quot;username@domain.cn&quot;[root@vm1 ~]# gitlab-ctl reconfigure  #修改配置后需要初始化配置......[root@vm1 ~]# gitlab-ctl stopok: down: gitaly: 0s, normally upok: down: gitlab-monitor: 1s, normally upok: down: gitlab-workhorse: 0s, normally upok: down: logrotate: 1s, normally upok: down: nginx: 0s, normally upok: down: node-exporter: 1s, normally upok: down: postgres-exporter: 0s, normally upok: down: postgresql: 0s, normally upok: down: prometheus: 0s, normally upok: down: redis: 0s, normally upok: down: redis-exporter: 1s, normally upok: down: sidekiq: 0s, normally upok: down: unicorn: 1s, normally up[root@vm1 ~]# gitlab-ctl startok: run: gitaly: (pid 37603) 0sok: run: gitlab-monitor: (pid 37613) 0sok: run: gitlab-workhorse: (pid 37625) 0sok: run: logrotate: (pid 37631) 0sok: run: nginx: (pid 37639) 1sok: run: node-exporter: (pid 37644) 0sok: run: postgres-exporter: (pid 37648) 1sok: run: postgresql: (pid 37652) 0sok: run: prometheus: (pid 37660) 1sok: run: redis: (pid 37668) 0sok: run: redis-exporter: (pid 37746) 0sok: run: sidekiq: (pid 37750) 1sok: run: unicorn: (pid 37757) 0s</code></pre><h4 id="7、Gitlab-发送邮件测试"><a href="#7、Gitlab-发送邮件测试" class="headerlink" title="7、Gitlab 发送邮件测试"></a>7、Gitlab 发送邮件测试</h4><pre><code>[root@vm1 ~]# gitlab-rails console Loading production environment (Rails 4.2.10)irb(main):001:0&gt;  Notify.test_email(&#39;user@destination.com&#39;, &#39;Message Subject&#39;, &#39;Message Body&#39;).deliver_nowNotify#test_email: processed outbound mail in 2219.5msSent mail to user@destination.com (2469.5ms)Date: Fri, 04 May 2018 15:50:10 +0800From: Admin &lt;username@domain.cn&gt;Reply-To: Admin &lt;username@domain.cn&gt;To: user@destination.comMessage-ID: &lt;5aec10b24cfaa_93933fee282db10c162d@vm1.mail&gt;Subject: Message SubjectMime-Version: 1.0Content-Type: text/html; charset=UTF-8Content-Transfer-Encoding: 7bitAuto-Submitted: auto-generatedX-Auto-Response-Suppress: All&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Message Body&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;=&gt; #&lt;Mail::Message:70291731344240, Multipart: false, Headers: &lt;Date: Fri, 04 May 2018 15:50:10 +0800&gt;, &lt;From: Admin &lt;username@domain.cn&gt;&gt;, &lt;Reply-To: Admin &lt;username@domain.cn&gt;&gt;, &lt;To: user@destination.com&gt;, &lt;Message-ID: &lt;5aec10b24cfaa_93933fee282db10c162d@vm1.mail&gt;&gt;, &lt;Subject: Message Subject&gt;, &lt;Mime-Version: 1.0&gt;, &lt;Content-Type: text/html; charset=UTF-8&gt;, &lt;Content-Transfer-Encoding: 7bit&gt;, &lt;Auto-Submitted: auto-generated&gt;, &lt;X-Auto-Response-Suppress: All&gt;&gt;irb(main):002:0&gt;quit </code></pre><p>###3、<strong>gitlab的使用</strong> <strong>在浏览器中输入 <a href="http://192.168.60.119/" target="_blank" rel="noopener">http://192.168.60.119/</a> ，然后 change password: ，并使用root用户登录 即可 (后续动作根据提示操作)</strong></p><h4 id="1、gitlab-命令行修改密码"><a href="#1、gitlab-命令行修改密码" class="headerlink" title="1、gitlab 命令行修改密码"></a>1、gitlab 命令行修改密码</h4><pre><code>gitlab-rails console productionirb(main):001:0&gt; user = User.where(id: 1).first     # id为1的是超级管理员irb(main):002:0&gt;user.password = &#39;yourpassword&#39;      # 密码必须至少8个字符irb(main):003:0&gt;user.save!                          # 如没有问题 返回trueexit                                                # 退出</code></pre><h4 id="2、gitlab服务管理"><a href="#2、gitlab服务管理" class="headerlink" title="2、gitlab服务管理"></a>2、gitlab服务管理</h4><pre><code>gitlab-ctl start                        # 启动所有 gitlab 组件；gitlab-ctl stop                         # 停止所有 gitlab 组件；gitlab-ctl restart                      # 重启所有 gitlab 组件；gitlab-ctl status                       # 查看服务状态；gitlab-ctl reconfigure                  # 启动服务；vim /etc/gitlab/gitlab.rb               # 修改默认的配置文件；gitlab-ctl tail                         # 查看日志；</code></pre><p>3、登陆 Gitlab</p><p><img src="http://p3.pstatp.com/large/pgc-image/bab871f315204370a5a0fb7608617551" alt="Gitlab Server 部署"></p><p><strong>如果需要手工修改nginx的port ，可以在gitlab.rb中设置 nginx[‘listen_port’] = 8000 ，然后再次 gitlab-ctl reconfigure即可</strong></p><p><strong>登录 gitlab 如下所示(首次登陆设置 root 密码)：</strong></p><p><img src="http://p1.pstatp.com/large/pgc-image/8fbf9685623b4ca3a3db0db73eae8896" alt="Gitlab Server 部署"></p><p><strong>创建项目组 group ，组名为plat-sp ,如下所示:</strong></p><p><img src="http://p1.pstatp.com/large/pgc-image/30b33c344c914b10b7efdc44cae76214" alt="Gitlab Server 部署"></p><p><img src="http://p1.pstatp.com/large/pgc-image/cbd2fd9e30454e2c9514192f0706cb31" alt="Gitlab Server 部署"></p><p><strong>去掉用户的自动注册功能（安全）：</strong> admin are -&gt; settings -&gt; Sign-up Restrictions 去掉钩钩，然后拉到最下面保存，重新登录</p><p><img src="http://p3.pstatp.com/large/pgc-image/6cefb48804534f60b67e16168a7717a0" alt="Gitlab Server 部署"></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux服务器被黑排查思路</title>
      <link href="2019/10/05/linux/fu-wu-qi-bei-hei-pai-cha-si-lu/"/>
      <url>2019/10/05/linux/fu-wu-qi-bei-hei-pai-cha-si-lu/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="账户和登录安全"><a href="#账户和登录安全" class="headerlink" title="账户和登录安全"></a>账户和登录安全</h3><p>账户安全是系统安全的第一道屏障，也是系统安全的核心，保障登录账户的安全，在一定程度上可以提高服务器的安全级别，下面重点介绍下 Linux 系统登录账户的安全设置方法。</p><h4 id="①删除特殊的账户和账户组"><a href="#①删除特殊的账户和账户组" class="headerlink" title="①删除特殊的账户和账户组"></a><strong>①删除特殊的账户和账户组</strong></h4><p>Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会安装很多不必要的用户和用户组。</p><p>如果不需要某些用户或者组，就要立即删除它，因为账户越多，系统就越不安全，很可能被黑客利用，进而威胁到服务器的安全。</p><p>Linux系统中可以删除的默认用户和组大致有如下这些：</p><p><strong>可删除的用户，</strong>如 adm，lp，sync，shutdown，halt，news，uucp，operator，games，gopher 等。</p><p><strong>可删除的组，</strong>如 adm，lp，news，uucp，games，dip，pppusers，popusers，slipusers 等。</p><h4 id="②关闭系统不需要的服务"><a href="#②关闭系统不需要的服务" class="headerlink" title="②关闭系统不需要的服务"></a><strong>②关闭系统不需要的服务</strong></h4><p>Linux 在安装完成后，绑定了很多没用的服务，这些服务默认都是自动启动的。</p><p>对于服务器来说，运行的服务越多，系统就越不安全，越少服务在运行，安全性就越好，因此关闭一些不需要的服务，对系统安全有很大的帮助。</p><p>具体哪些服务可以关闭，要根据服务器的用途而定，一般情况下，只要系统本身用不到的服务都认为是不必要的服务。</p><p>例如：某台 Linux 服务器用于 www 应用，那么除了 httpd 服务和系统运行是必须的服务外，其他服务都可以关闭。</p><p>下面这些服务一般情况下是不需要的，可以选择关闭：</p><p>anacron、auditd、autofs、avahi-daemon、avahi-dnsconfd、bluetooth、cpuspeed、firstboot、gpm、haldaemon、hidd、ip6tables、ipsec、isdn、lpd、mcstrans、messagebus、netfs、nfs、nfslock、nscd、pcscd portmap、readahead_early、restorecond、rpcgssd、rpcidmapd、rstatd、sendmail、setroubleshoot、yppasswdd ypserv</p><h4 id="③密码安全策略"><a href="#③密码安全策略" class="headerlink" title="③密码安全策略"></a><strong>③密码安全策略</strong></h4><p>在 Linux 下，远程登录系统有两种认证方式：</p><ul><li><strong>密码认证</strong></li><li><strong>密钥认证</strong></li></ul><p>密码认证方式是传统的安全策略，对于密码的设置，比较普遍的说法是：至少 6 个字符以上，密码要包含数字、字母、下划线、特殊符号等。</p><p>设置一个相对复杂的密码，对系统安全能起到一定的防护作用，但是也面临一些其他问题，例如密码暴力破解、密码泄露、密码丢失等，同时过于复杂的密码对运维工作也会造成一定的负担。</p><p>密钥认证是一种新型的认证方式，公用密钥存储在远程服务器上，专用密钥保存在本地，当需要登录系统时，通过本地专用密钥和远程服务器的公用密钥进行配对认证，如果认证成功，就成功登录系统。</p><p>这种认证方式避免了被暴力破解的危险，同时只要保存在本地的专用密钥不被黑客盗用，攻击者一般无法通过密钥认证的方式进入系统。</p><p>因此，在 Linux 下推荐用密钥认证方式登录系统，这样就可以抛弃密码认证登录系统的弊端。</p><p>Linux 服务器一般通过 SecureCRT、Putty、Xshell 之类的工具进行远程维护和管理，密钥认证方式的实现就是借助于 SecureCRT 软件和 Linux 系统中的 SSH 服务实现的。</p><h4 id="④合理使用-su、sudo-命令"><a href="#④合理使用-su、sudo-命令" class="headerlink" title="④合理使用 su、sudo 命令"></a><strong>④合理使用 su、sudo 命令</strong></h4><p><strong>su 命令：</strong>是一个切换用户的工具，经常用于将普通用户切换到超级用户下，当然也可以从超级用户切换到普通用户。</p><p>为了保证服务器的安全，几乎所有服务器都禁止了超级用户直接登录系统，而是通过普通用户登录系统，然后再通过 su 命令切换到超级用户下，执行一些需要超级权限的工作。</p><p>通过 su 命令能够给系统管理带来一定的方便，但是也存在不安全的因素，例如：系统有 10 个普通用户，每个用户都需要执行一些有超级权限的操作，就必须把超级用户的密码交给这 10 个普通用户。</p><p>如果这 10 个用户都有超级权限，通过超级权限可以做任何事，那么会在一定程度上对系统的安全造成了威协。</p><p>因此 su 命令在很多人都需要参与的系统管理中，并不是最好的选择，超级用户密码应该掌握在少数人手中，此时 sudo 命令就派上用场了。</p><p><strong>sudo 命令：</strong>允许系统管理员分配给普通用户一些合理的“权利”，并且不需要普通用户知道超级用户密码，就能让他们执行一些只有超级用户或其他特许用户才能完成的任务。</p><p>比如：系统服务重启、编辑系统配置文件等，通过这种方式不但能减少超级用户登录次数和管理时间，也提高了系统安全性。</p><p>因此，sudo 命令相对于权限无限制性的 su 来说，还是比较安全的，所以 sudo 也被称为受限制的 su，另外 sudo 也是需要事先进行授权认证的，所以也被称为授权认证的 su。</p><p><strong>sudo 执行命令的流程是：</strong>将当前用户切换到超级用户下，或切换到指定的用户下，然后以超级用户或其指定切换到的用户身份执行命令。</p><p>执行完成后，直接退回到当前用户，而这一切的完成要通过 sudo 的配置文件 /etc/sudoers 来进行授权。</p><p><strong>sudo 设计的宗旨是：</strong>赋予用户尽可能少的权限但仍允许它们完成自己的工作，这种设计兼顾了安全性和易用性。</p><p>因此，强烈推荐通过 sudo 来管理系统账号的安全，只允许普通用户登录系统，如果这些用户需要特殊的权限，就通过配置 /etc/sudoers 来完成，这也是多用户系统下账号安全管理的基本方式。</p><h4 id="⑤删减系统登录欢迎信息"><a href="#⑤删减系统登录欢迎信息" class="headerlink" title="⑤删减系统登录欢迎信息"></a><strong>⑤删减系统登录欢迎信息</strong></h4><p>系统的一些欢迎信息或版本信息，虽然能给系统管理者带来一定的方便，但是这些信息有时候可能被黑客利用，成为攻击服务器的帮凶。</p><p>为了保证系统的安全，可以修改或删除某些系统文件，需要修改或删除的文件有四个，分别是：</p><ul><li><strong>/etc/issue</strong></li><li><strong>/etc/issue.net</strong></li><li><strong>/etc/redhat-release</strong></li><li><strong>/etc/motd</strong></li></ul><p>/etc/issue 和 /etc/issue.net 文件都记录了操作系统的名称和版本号，当用户通过本地终端或本地虚拟控制台等登录系统时，/etc/issue 的文件内容就会显示。</p><p>当用户通过 ssh 或 telnet 等远程登录系统时，/etc/issue.net 文件内容就会在登录后显示。</p><p>在默认情况下 /etc/issue.net 文件的内容是不会在 ssh 登录后显示的，要显示这个信息可以修改 /etc/ssh/sshd_config 文件，在此文件中添加如下内容即可：Banner /etc/issue.net。</p><p>其实这些登录提示很明显泄漏了系统信息，为了安全起见，建议将此文件中的内容删除或修改。</p><p>/etc/redhat-release 文件也记录了操作系统的名称和版本号，为了安全起见，可以将此文件中的内容删除。</p><p>/etc/motd 文件是系统的公告信息。每次用户登录后，/etc/motd 文件的内容就会显示在用户的终端。</p><p>通过这个文件系统，管理员可以发布一些软件或硬件的升级、系统维护等通告信息，但是此文件的最大作用就是可以发布一些警告信息，当黑客登录系统后，会发现这些警告信息，进而产生一些震慑作用。</p><p>看过国外的一个报道，黑客入侵了一个服务器，而这个服务器却给出了欢迎登录的信息，因此法院不做任何裁决。</p><h3 id="远程访问和认证安全"><a href="#远程访问和认证安全" class="headerlink" title="远程访问和认证安全"></a><strong>远程访问和认证安全</strong></h3><h4 id="①远程登录取消-telnet-而采用-SSH-方式"><a href="#①远程登录取消-telnet-而采用-SSH-方式" class="headerlink" title="①远程登录取消 telnet 而采用 SSH 方式"></a><strong>①远程登录取消 telnet 而采用 SSH 方式</strong></h4><p>telnet 是一种古老的远程登录认证服务，它在网络上用明文传送口令和数据，因此别有用心的人就会非常容易截获这些口令和数据。</p><p>而且，telnet 服务程序的安全验证方式也极其脆弱，攻击者可以轻松将虚假信息传送给服务器。</p><p>现在远程登录基本抛弃了 telnet 这种方式，而取而代之的是通过 SSH 服务远程登录服务器。</p><h4 id="②合理使用-Shell-历史命令记录功能"><a href="#②合理使用-Shell-历史命令记录功能" class="headerlink" title="②合理使用 Shell 历史命令记录功能"></a><strong>②合理使用 Shell 历史命令记录功能</strong></h4><p>在 Linux 下可通过 history 命令查看用户所有的历史操作记录，同时 shell 命令操作记录默认保存在用户目录下的 .bash_history 文件中。</p><p>通过这个文件可以查询 shell 命令的执行历史，有助于运维人员进行系统审计和问题排查。</p><p>同时，在服务器遭受黑客攻击后，也可以通过这个命令或文件查询黑客登录服务器所执行的历史命令操作。</p><p>但是有时候黑客在入侵服务器后为了毁灭痕迹，可能会删除 .bash_history 文件，这就需要合理的保护或备份 .bash_history 文件。</p><h4 id="③启用-Tcp-Wrappers-防火墙"><a href="#③启用-Tcp-Wrappers-防火墙" class="headerlink" title="③启用 Tcp_Wrappers 防火墙"></a><strong>③启用 Tcp_Wrappers 防火墙</strong></h4><p>Tcp_Wrappers 是一个用来分析 TCP/IP 封包的软件，类似的 IP 封包软件还有 iptables。</p><p>Linux 默认都安装了 Tcp_Wrappers。作为一个安全的系统，Linux 本身有两层安全防火墙，通过 IP 过滤机制的 iptables 实现第一层防护。</p><p>iptables 防火墙通过直观地监视系统的运行状况，阻挡网络中的一些恶意攻击，保护整个系统正常运行，免遭攻击和破坏。</p><p>如果通过了第一层防护，那么下一层防护就是 Tcp_Wrappers 了。通过 Tcp_Wrappers 可以实现对系统中提供的某些服务的开放与关闭、允许和禁止，从而更有效地保证系统安全运行。</p><h3 id="文件系统安全"><a href="#文件系统安全" class="headerlink" title="文件系统安全"></a><strong>文件系统安全</strong></h3><h4 id="①锁定系统重要文件"><a href="#①锁定系统重要文件" class="headerlink" title="①锁定系统重要文件"></a><strong>①锁定系统重要文件</strong></h4><p>系统运维人员有时候可能会遇到通过 Root 用户都不能修改或者删除某个文件的情况，产生这种情况的大部分原因可能是这个文件被锁定了。</p><p>在 Linux 下锁定文件的命令是 Chattr，通过这个命令可以修改 ext2、ext3、ext4 文件系统下文件属性，但是这个命令必须有超级用户 Root 来执行。和这个命令对应的命令是 lsattr，这个命令用来查询文件属性。</p><p>对重要的文件进行加锁，虽然能够提高服务器的安全性，但是也会带来一些不便。</p><p>例如：在软件的安装、升级时可能需要去掉有关目录和文件的 immutable 属性和 append-only 属性，同时，对日志文件设置了 append-only 属性，可能会使日志轮换（logrotate）无法进行。</p><p>因此，在使用 Chattr 命令前，需要结合服务器的应用环境来权衡是否需要设置 immutable 属性和 append-only 属性。</p><p>另外，虽然通过 Chattr 命令修改文件属性能够提高文件系统的安全性，但是它并不适合所有的目录。Chattr 命令不能保护 /、/dev、/tmp、/var 等目录。</p><p>根目录不能有不可修改属性，因为如果根目录具有不可修改属性，那么系统根本无法工作：</p><ul><li>/dev 在启动时，syslog 需要删除并重新建立 /dev/log 套接字设备，如果设置了不可修改属性，那么可能出问题。</li><li>/tmp 目录会有很多应用程序和系统程序需要在这个目录下建立临时文件，也不能设置不可修改属性。</li><li>/var 是系统和程序的日志目录，如果设置为不可修改属性，那么系统写日志将无法进行，所以也不能通过 Chattr 命令保护。</li></ul><h4 id="②文件权限检查和修改"><a href="#②文件权限检查和修改" class="headerlink" title="②文件权限检查和修改"></a><strong>②文件权限检查和修改</strong></h4><p>不正确的权限设置直接威胁着系统的安全，因此运维人员应该能及时发现这些不正确的权限设置，并立刻修正，防患于未然。下面列举几种查找系统不安全权限的方法。</p><p>查找系统中任何用户都有写权限的文件或目录：</p><pre><code>查找文件：find / -type f -perm -2 -o -perm -20 |xargs ls -al查找目录：find / -type d -perm -2 -o -perm -20 |xargs ls –ld</code></pre><p>查找系统中所有含“s”位的程序：</p><pre><code>find / -type f -perm -4000 -o -perm -2000 -print | xargs ls –al</code></pre><p>含有“s”位权限的程序对系统安全威胁很大，通过查找系统中所有具有“s”位权限的程序，可以把某些不必要的“s”位程序去掉，这样可以防止用户滥用权限或提升权限的可能性。</p><p>检查系统中所有 suid 及 sgid 文件：</p><pre><code>find / -user root -perm -2000 -print -exec md5sum {} ;find / -user root -perm -4000 -print -exec md5sum {} ;</code></pre><p>将检查的结果保存到文件中，可在以后的系统检查中作为参考。</p><p>检查系统中没有属主的文件：</p><pre><code>find / -nouser -o –nogroup</code></pre><p>没有属主的孤儿文件比较危险，往往成为黑客利用的工具，因此找到这些文件后，要么删除掉，要么修改文件的属主，使其处于安全状态。</p><h4 id="③-tmp、-var-tmp、-dev-shm-安全设定"><a href="#③-tmp、-var-tmp、-dev-shm-安全设定" class="headerlink" title="③/tmp、/var/tmp、/dev/shm 安全设定"></a><strong>③/tmp、/var/tmp、/dev/shm 安全设定</strong></h4><p>在 Linux 系统中，主要有两个目录或分区用来存放临时文件，分别是 /tmp 和 /var/tmp。</p><p>存储临时文件的目录或分区有个共同点就是所有用户可读写、可执行，这就为系统留下了安全隐患。</p><p>攻击者可以将病毒或者木马脚本放到临时文件的目录下进行信息收集或伪装，严重影响服务器的安全。</p><p>此时，如果修改临时目录的读写执行权限，还有可能影响系统上应用程序的正常运行，因此，如果要兼顾两者，就需要对这两个目录或分区进行特殊的设置。</p><p>/dev/shm 是 Linux 下的一个共享内存设备，在 Linux 启动的时候系统默认会加载 /dev/shm，被加载的 /dev/shm 使用的是 tmpfs 文件系统，而 tmpfs 是一个内存文件系统，存储到 tmpfs 文件系统的数据会完全驻留在 RAM 中。</p><p>这样通过 /dev/shm 就可以直接操控系统内存，这将非常危险，因此如何保证 /dev/shm 安全也至关重要。</p><p>对于 /tmp 的安全设置，需要看 /tmp 是一个独立磁盘分区，还是一个根分区下的文件夹。</p><p>如果 /tmp 是一个独立的磁盘分区，那么设置非常简单，修改 /etc/fstab 文件中 /tmp 分区对应的挂载属性，加上 nosuid、noexec、nodev 三个选项即可。</p><p>修改后的 /tmp 分区挂载属性类似如下：</p><pre><code>LABEL=/tmp  /tmp ext3 rw,nosuid,noexec,nodev 0 0</code></pre><p>其中，nosuid、noexec、nodev 选项，表示不允许任何 suid 程序，并且在这个分区不能执行任何脚本等程序，并且不存在设备文件。</p><p>在挂载属性设置完成后，重新挂载 /tmp 分区，保证设置生效。</p><p>对于 /var/tmp，如果是独立分区，安装 /tmp 的设置方法是修改 /etc/fstab 文件即可。</p><p>如果是 /var 分区下的一个目录，那么可以将 /var/tmp 目录下所有数据移动到 /tmp 分区下，然后在 /var 下做一个指向 /tmp 的软连接即可。</p><p>也就是执行如下操作：</p><pre><code>[root@server ~]# mv /var/tmp/* /tmp[root@server ~]# ln -s  /tmp /var/tmp</code></pre><p>如果 /tmp 是根目录下的一个目录，那么设置稍微复杂，可以通过创建一个 loopback 文件系统来利用 Linux 内核的 loopback 特性将文件系统挂载到 /tmp 下，然后在挂载时指定限制加载选项即可。</p><p>一个简单的操作示例如下：</p><pre><code>[root@server ~]# dd if=/dev/zero of=/dev/tmpfs bs=1M count=10000[root@server ~]# mke2fs -j /dev/tmpfs[root@server ~]# cp -av /tmp /tmp.old[root@server ~]# mount -o loop,noexec,nosuid,rw /dev/tmpfs /tmp[root@server ~]# chmod 1777 /tmp[root@server ~]# mv -f /tmp.old/* /tmp/[root@server ~]# rm -rf /tmp.old</code></pre><p>最后，编辑 /etc/fstab，添加如下内容，以便系统在启动时自动加载 loopback 文件系统：</p><pre><code>/dev/tmpfs /tmp ext3 loop,nosuid,noexec,rw 0 0</code></pre><h3 id="Linux-后门入侵检测工具"><a href="#Linux-后门入侵检测工具" class="headerlink" title="Linux 后门入侵检测工具"></a><strong>Linux 后门入侵检测工具</strong></h3><p>Rootkit 是 Linux 平台下最常见的一种木马后门工具，它主要通过替换系统文件来达到入侵和和隐蔽的目的，这种木马比普通木马后门更加危险和隐蔽，普通的检测工具和检查手段很难发现这种木马。</p><p>Rootkit 攻击能力极强，对系统的危害很大，它通过一套工具来建立后门和隐藏行迹，从而让攻击者保住权限，以使它在任何时候都可以使用 Root 权限登录到系统。</p><p>Rootkit 主要有两种类型：文件级别和内核级别，下面分别进行简单介绍。</p><p>文件级别的 Rootkit 一般是通过程序漏洞或者系统漏洞进入系统后，通过修改系统的重要文件来达到隐藏自己的目的。</p><p>在系统遭受 Rootkit 攻击后，合法的文件被木马程序替代，变成了外壳程序，而其内部是隐藏着的后门程序。</p><p>通常容易被 Rootkit 替换的系统程序有 login、ls、ps、ifconfig、du、find、netstat 等，其中 login 程序是最经常被替换的。</p><p>因为当访问 Linux 时，无论是通过本地登录还是远程登录，/bin/login 程序都会运行，系统将通过 /bin/login 来收集并核对用户的账号和密码。</p><p>而 Rootkit 就是利用这个程序的特点，使用一个带有根权限后门密码的 /bin/login 来替换系统的 /bin/login，这样攻击者通过输入设定好的密码就能轻松进入系统。</p><p>此时，即使系统管理员修改 Root 密码或者清除 Root 密码，攻击者还是一样能通过 Root 用户登录系统。</p><p>攻击者通常在进入 Linux 系统后，会进行一系列的攻击动作，最常见的是安装嗅探器收集本机或者网络中其他服务器的重要数据。</p><p>在默认情况下，Linux 中也有一些系统文件会监控这些工具动作，例如 ifconfig 命令。</p><p>所以，攻击者为了避免被发现，会想方设法替换其他系统文件，常见的就是 ls、ps、ifconfig、du、find、netstat 等。</p><p>如果这些文件都被替换，那么在系统层面就很难发现 Rootkit 已经在系统中运行了。</p><p>这就是文件级别的 Rootkit，对系统维护很大，目前最有效的防御方法是定期对系统重要文件的完整性进行检查。</p><p>如果发现文件被修改或者被替换，那么很可能系统已经遭受了 Rootkit 入侵。</p><p>检查文件完整性的工具很多，常见的有 Tripwire、 aide 等，可以通过这些工具定期检查文件系统的完整性，以检测系统是否被 Rootkit 入侵。</p><p>内核级 Rootkit 是比文件级 Rootkit 更高级的一种入侵方式，它可以使攻击者获得对系统底层的完全控制权。</p><p>此时攻击者可以修改系统内核，进而截获运行程序向内核提交的命令，并将其重定向到入侵者所选择的程序并运行此程序。</p><p>也就是说，当用户要运行程序 A 时，被入侵者修改过的内核会假装执行 A 程序，而实际上却执行了程序 B。</p><p>内核级 Rootkit 主要依附在内核上，它并不对系统文件做任何修改，因此一般的检测工具很难检测到它的存在，这样一旦系统内核被植入 Rootkit，攻击者就可以对系统为所欲为而不被发现。</p><p>目前对于内核级的 Rootkit 还没有很好的防御工具，因此，做好系统安全防范就非常重要，将系统维持在最小权限内工作，只要攻击者不能获取 Root 权限，就无法在内核中植入 Rootkit。</p><h4 id="①Rootkit-后门检测工具-Chkrootkit"><a href="#①Rootkit-后门检测工具-Chkrootkit" class="headerlink" title="①Rootkit 后门检测工具 Chkrootkit"></a><strong>①Rootkit 后门检测工具 Chkrootkit</strong></h4><p>Chkrootkit 是一个 Linux 系统下查找并检测 Rootkit 后门的工具，它的官方地址：</p><pre><code>http://www.chkrootkit.org/</code></pre><p>Chkrootkit 没有包含在官方的 CentOS 源中，因此要采取手动编译的方法来安装，不过这种安装方法也更加安全。</p><p>Chkrootkit 的使用比较简单，直接执行 Chkrootkit 命令即可自动开始检测系统。</p><p>下面是某个系统的检测结果：</p><pre><code>[root@server chkrootkit]# /usr/local/chkrootkit/chkrootkitChecking `ifconfig&#39;... INFECTEDChecking `ls&#39;... INFECTEDChecking `login&#39;... INFECTEDChecking `netstat&#39;... INFECTEDChecking `ps&#39;... INFECTEDChecking `top&#39;... INFECTEDChecking `sshd&#39;... not infectedChecking `syslogd&#39;... not tested</code></pre><p>从输出可以看出，此系统的 ifconfig、ls、login、netstat、ps 和 top 命令已经被感染。</p><p>针对被感染 Rootkit 的系统，最安全而有效的方法就是备份数据重新安装系统。</p><p>Chkrootkit 在检查 Rootkit 的过程中使用了部分系统命令，因此，如果服务器被黑客入侵，那么依赖的系统命令可能也已经被入侵者替换，此时 Chkrootkit 的检测结果将变得完全不可信。</p><p>为了避免 Chkrootkit 的这个问题，可以在服务器对外开放前，事先将 Chkrootkit 使用的系统命令进行备份，在需要的时候使用备份的原始系统命令让 Chkrootkit 对 Rootkit 进行检测。</p><h4 id="②Rootkit-后门检测工具-RKHunter"><a href="#②Rootkit-后门检测工具-RKHunter" class="headerlink" title="②Rootkit 后门检测工具 RKHunter"></a><strong>②Rootkit 后门检测工具 RKHunter</strong></h4><p>RKHunter 是一款专业的检测系统是否感染 Rootkit 的工具，它通过执行一系列的脚本来确认服务器是否已经感染 Rootkit。</p><p>在官方的资料中，RKHunter 可以做的事情有：</p><pre><code>MD5校验测试，检测文件是否有改动，比较系统命令的md5，从而判断系统命令是否被篡改检测rootkit使用的二进制和系统工具文件检测特洛伊木马程序的特征码检测常用程序的文件属性是否异常检测系统相关的测试检测隐藏文件检测可疑的核心模块LKM检测系统已启动的监听端口</code></pre><p>在 Linux 终端使用 RKHunter 来检测，最大的好处在于每项的检测结果都有不同的颜色显示，如果是绿色的表示没有问题，如果是红色的，那就要引起关注了。</p><p>另外，在执行检测的过程中，在每个部分检测完成后，需要以 Enter 键来继续。</p><p>如果要让程序自动运行，可以执行如下命令：</p><pre><code>[root@server ~]# /usr/local/bin/rkhunter --check --skip-keypress</code></pre><p>同时，如果想让检测程序每天定时运行，那么可以在 /etc/crontab 中加入如下内容：</p><pre><code>30 09 * * * root /usr/local/bin/rkhunter --check --cronjob </code></pre><p>这样，RKHunter 检测程序就会在每天的 9:30 分运行一次。</p><h3 id="服务器遭受攻击后的处理过程"><a href="#服务器遭受攻击后的处理过程" class="headerlink" title="服务器遭受攻击后的处理过程"></a><strong>服务器遭受攻击后的处理过程</strong></h3><p>安全总是相对的，再安全的服务器也有可能遭受到攻击。</p><p>作为一个安全运维人员，要把握的原则是：尽量做好系统安全防护，修复所有已知的危险行为，同时，在系统遭受攻击后能够迅速有效地处理攻击行为，最大限度地降低攻击对系统产生的影响。</p><h4 id="①处理服务器遭受攻击的一般思路"><a href="#①处理服务器遭受攻击的一般思路" class="headerlink" title="①处理服务器遭受攻击的一般思路"></a><strong>①处理服务器遭受攻击的一般思路</strong></h4><p>系统遭受攻击并不可怕，可怕的是面对攻击束手无策，下面就详细介绍下在服务器遭受攻击后的一般处理思路。</p><p><strong>切断网络：</strong>所有的攻击都来自于网络，因此，在得知系统正遭受黑客的攻击后，首先要做的就是断开服务器的网络连接，这样除了能切断攻击源之外，也能保护服务器所在网络的其他主机。</p><p><strong>查找攻击源：</strong>可以通过分析系统日志或登录日志文件，查看可疑信息，同时也要查看系统都打开了哪些端口，运行哪些进程，并通过这些进程分析哪些是可疑的程序。</p><p>这个过程要根据经验和综合判断能力进行追查和分析。下面会详细介绍这个过程的处理思路。</p><p><strong>分析入侵原因和途径：</strong>既然系统遭到入侵，那么原因是多方面的，可能是系统漏洞，也可能是程序漏洞。</p><p>一定要查清楚是哪个原因导致的，并且还要查清楚遭到攻击的途径，找到攻击源，因为只有知道了遭受攻击的原因和途径，才能删除攻击源同时进行漏洞的修复。</p><p><strong>备份用户数据：</strong>在服务器遭受攻击后，需要立刻备份服务器上的用户数据，同时也要查看这些数据中是否隐藏着攻击源。</p><p>如果攻击源在用户数据中，一定要彻底删除，然后将用户数据备份到一个安全的地方。</p><p><strong>重新安装系统：</strong>永远不要认为自己能彻底清除攻击源，因为没有人能比黑客更了解攻击程序。</p><p>在服务器遭到攻击后，最安全也最简单的方法就是重新安装系统，因为大部分攻击程序都会依附在系统文件或者内核中，所以重新安装系统才能彻底清除攻击源。</p><p><strong>修复程序或系统漏洞：</strong>在发现系统漏洞或者应用程序漏洞后，首先要做的就是修复系统漏洞或者更改程序 Bug，因为只有将程序的漏洞修复完毕才能正式在服务器上运行。</p><p><strong>恢复数据和连接网络：</strong>将备份的数据重新复制到新安装的服务器上，然后开启服务，最后将服务器开启网络连接，对外提供服务。</p><h4 id="②检查并锁定可疑用户"><a href="#②检查并锁定可疑用户" class="headerlink" title="②检查并锁定可疑用户"></a><strong>②检查并锁定可疑用户</strong></h4><p>当发现服务器遭受攻击后，首先要切断网络连接，但是在有些情况下，比如无法马上切断网络连接时，就必须登录系统查看是否有可疑用户。</p><p>如果有可疑用户登录了系统，那么需要马上将这个用户锁定，然后中断此用户的远程连接。</p><h4 id="③查看系统日志"><a href="#③查看系统日志" class="headerlink" title="③查看系统日志"></a><strong>③查看系统日志</strong></h4><p>查看系统日志是查找攻击源最好的方法，可查的系统日志有 /var/log/messages、/var/log/secure 等。</p><p>这两个日志文件可以记录软件的运行状态以及远程用户的登录状态，还可以查看每个用户目录下的 .bash_history 文件。</p><p>特别是 /root 目录下的 .bash_history 文件，这个文件中记录着用户执行的所有历史命令。</p><h4 id="④检查并关闭系统可疑进程"><a href="#④检查并关闭系统可疑进程" class="headerlink" title="④检查并关闭系统可疑进程"></a><strong>④检查并关闭系统可疑进程</strong></h4><p>检查可疑进程的命令很多，例如 ps、top 等，但是有时候只知道进程的名称无法得知路径，此时可以通过如下命令查看。</p><p>首先通过 pidof 命令可以查找正在运行的进程 PID，例如要查找 sshd 进程的 PID。</p><p><strong>执行如下命令：</strong></p><pre><code>[root@server ~]# pidof sshd13276 12942 4284</code></pre><p>然后进入内存目录，查看对应 PID 目录下 exe 文件的信息：</p><pre><code>[root@server ~]# ls -al /proc/13276/exe lrwxrwxrwx 1 root root 0 Oct  4 22:09 /proc/13276/exe -&gt; /usr/sbin/sshd</code></pre><p>这样就找到了进程对应的完整执行路径。如果还要查看文件的句柄，可以查看如下目录：</p><pre><code>[root@server ~]# ls -al /proc/13276/fd</code></pre><p>通过这种方式基本可以找到任何进程的完整执行信息。</p><h4 id="⑤检查文件系统的完好性"><a href="#⑤检查文件系统的完好性" class="headerlink" title="⑤检查文件系统的完好性"></a><strong>⑤检查文件系统的完好性</strong></h4><p>检查文件属性是否发生变化是验证文件系统完好性最简单、最直接的方法，例如可以检查被入侵服务器上 /bin/ls 文件的大小是否与正常系统上此文件的大小相同，以验证文件是否被替换，但是这种方法比较低级。</p><p><strong>此时可以借助于 Linux 下 rpm 这个工具来完成验证，操作如下：</strong></p><pre><code>[root@server ~]# rpm -Va....L...  c /etc/pam.d/system-authS.5.....  c /etc/security/limits.confS.5....T  c /etc/sysctl.confS.5....T    /etc/sgml/docbook-simple.catS.5....T  c /etc/login.defsS.5.....  c /etc/openldap/ldap.confS.5....T  c /etc/sudoers</code></pre><h4 id="⑥重新安装系统恢复数据"><a href="#⑥重新安装系统恢复数据" class="headerlink" title="⑥重新安装系统恢复数据"></a><strong>⑥重新安装系统恢复数据</strong></h4><p>很多情况下，被攻击过的系统已经不再可信任，因此，最好的方法是将服务器上面数据进行备份，然后重新安装系统，最后再恢复数据即可。</p><p>数据恢复完成，马上对系统做上面介绍的安全加固策略，保证系统安全。</p><blockquote><p>原文链接如下：</p><p><a href="https://www.cnblogs.com/MYSQLZOUQI/p/5317916.html" target="_blank" rel="noopener">https://www.cnblogs.com/MYSQLZOUQI/p/5317916.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux-初探</title>
      <link href="2019/09/05/linux/rang-ni-de-linux-ku-qi-lai-xiao-bai-ye-neng-wan-zhuan-tmux/"/>
      <url>2019/09/05/linux/rang-ni-de-linux-ku-qi-lai-xiao-bai-ye-neng-wan-zhuan-tmux/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="Linux终端复用神器-tmux初探"><a href="#Linux终端复用神器-tmux初探" class="headerlink" title="Linux终端复用神器-tmux初探"></a>Linux终端复用神器-tmux初探</h3><pre><code>Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。是BSD实现的Screen替代品，相对于Screen，它更加先进：支持屏幕切分，而且具备丰富的命令行参数，使其可以灵活、动态的进行各种布局和操作。</code></pre><p>废话不多说来个效果图<br><img src="https://i.loli.net/2018/12/14/5c139f4ab6ad2.jpg" alt="tmux"></p><h3 id="Tmux的使用场景"><a href="#Tmux的使用场景" class="headerlink" title="Tmux的使用场景"></a>Tmux的使用场景</h3><pre><code>1）可以某个程序在执行时一直是输出状态，需要结合nohup、&amp;来放在后台执行，并且ctrl+c结束。这时可以打开一个Tmux窗口，在该窗口里执行这个程序，用来保证该程序一直在执行中，只要Tmux这个窗口不关闭2）公司需要备份数据库时，数据量巨大，备份两三天弄不完，这时不小心关闭了终端窗口或误操作就前功尽弃了，使用Tmux会话运行命令或任务，就不用担心这些问题。3）下班后，你需要断开ssh或关闭电脑，将运行的命令或任务放置后台运行。4）关闭终端,再次打开时原终端里面的任务进程依然不会中断</code></pre><h3 id="Tmux功能："><a href="#Tmux功能：" class="headerlink" title="Tmux功能："></a>Tmux功能：</h3><pre><code>-  提供了强劲的、易于使用的命令行界面。-  可横向和纵向分割窗口。-  窗格可以自由移动和调整大小，或直接利用四个预设布局之一。-  支持 UTF-8 编码及 256 色终端。-  可在多个缓冲区进行复制和粘贴。-  可通过交互式菜单来选择窗口、会话及客户端。-  支持跨窗口搜索。-  支持自动及手动锁定窗口。</code></pre><h3 id="Tmux安装"><a href="#Tmux安装" class="headerlink" title="Tmux安装"></a>Tmux安装</h3><pre><code>yum -y install tmux</code></pre><h3 id="Tmux个性化配置"><a href="#Tmux个性化配置" class="headerlink" title="Tmux个性化配置"></a>Tmux个性化配置</h3><pre><code>此类配置可以在命令行模式中输入show-options -g查询tmux加上下列参数,实现个性化设置set-option -g base-index 1                        # 窗口的初始序号；默认为0，这里设置为1set-option -g display-time 5000                   # 提示信息的持续时间；设置足够的时间以避免看不清提示，单位为毫秒set-option -g repeat-time 1000                    # 控制台激活后的持续时间；设置合适的时间以避免每次操作都要先激活控制台，单位为毫秒set-option -g status-keys vi                      # 操作状态栏时的默认键盘布局；可以设置为vi或emacsset-option -g status-utf8 on                      # 开启状态栏的UTF-8支持---set-option -g status-bg blueset-option -g status-fg &#39;#bbbbbb&#39;set-option -g status-left-fg greenset-option -g status-left-bg blueset-option -g status-right-fg greenset-option -g status-right-bg blueset-option -g status-left-length 10               # 状态栏左方的内容长度；set-option -g status-right-length 15              # 状态栏右方的内容长度；建议把更多的空间留给状态栏左方（用于列出当前窗口）set-option -g status-left &#39;[#(whoami)]&#39;           # 状态栏左方的内容set-option -g status-right &#39;[#(date +&quot; %m-%d %H:%M &quot;)]&#39;     # 状态栏右方的内容；这里的设置将得到类似23:59的显示set-option -g status-justify &quot;centre&quot;             # 窗口列表居中显示set-option -g default-terminal &quot;screen-256color&quot;  # 支持256色显示分割窗口边界的颜色set-option -g pane-active-border-fg &#39;#55ff55&#39;set-option -g pane-border-fg &#39;#555555&#39;---此类设置可以在命令行模式中输入show-window-options -g查询set-window-option -g mode-keys vi    # 复制模式中的默认键盘布局；可以设置为vi或emacsset-window-option -g utf8 on         # 开启窗口的UTF-8支持set-window-option -g mode-mouse on   # 窗口切换后让人可以用鼠标上下滑动显示历史输出---窗口切分快捷键(没设置成功)bind \ split-window -h                      # 使用 \ 将窗口竖切bind - split-window -v                      # 使用 - 将窗口横切bind K confirm-before -p &quot;kill-window #W? (y/n)&quot; kill-window    # 使用大写 K 来关闭窗口bind &#39;&quot;&#39; choose-window                      # 双引号选择窗口---Pane之间切换的快捷键bind h select-pane -L                       # 定位到左边窗口的快捷键bind j select-pane -D                       # 定位到上边窗口的快捷键bind k select-pane -U                       # 定位到下方窗口的快捷键bind l select-pane -R                       # 定位到右边窗口的快捷键---设置window属性setw -g window-status-current-bg redsetw -g window-status-current-fg whitesetw -g window-status-current-attr brightsetw -g window-status-attr brightset-option -g window-status-format &#39;#I #W&#39;set-option -g window-status-current-format &#39; #I #W &#39;setw -g window-status-current-bg bluesetw -g window-status-current-fg green不使用prefix键，使用Ctrl和左右方向键方便切换窗口bind-key -n &quot;C-Left&quot; select-window -t :-bind-key -n &quot;C-Right&quot; select-window -t :+</code></pre><h3 id="tmux-session-使用介绍"><a href="#tmux-session-使用介绍" class="headerlink" title="tmux session 使用介绍"></a>tmux session 使用介绍</h3><pre><code>运行tmux并开启一个新的会话tmux显示所有会话tmux ls新建会话并指定会话名称（建议制定会话名称，以便了解该会话用途）tmux new -s &lt;session-name&gt;新建会话（不指定会话名称）tmux new接入上一个会话tmux a接入指定名称的会话tmux a -t &lt;session-name&gt;断开当前会话（还可以使用快捷键：control+b，再按d）tmux detach关闭指定会话tmux kill-session -t session-name关闭除指定会话外的所有会话tmux kill-session -a -t session-name在会话中切换control+b，再按s 显示会话列表，再进行会话切换销毁所有会话并停止tmuxtmux kill-serverG复制粘贴Ctrl+b   [          //进入复制模式空格+方向键      //选择回车                  //  确认Ctrl+b  [           //粘贴</code></pre><h3 id="需要注意的几点"><a href="#需要注意的几点" class="headerlink" title="需要注意的几点"></a>需要注意的几点</h3><pre><code>1）进入tmux面板后，一定要先按ctrl+b，然后松开，再按其他的组合键才生效。2）常用到的几个组合键：ctrl+b ?            显示快捷键帮助ctrl+b 空格键       采用下一个内置布局，这个很有意思，在多屏时，用这个就会将多有屏幕竖着展示ctrl+b !            把当前窗口变为新窗口ctrl+b  &quot;           模向分隔窗口ctrl+b %            纵向分隔窗口ctrl+b q            显示分隔窗口的编号ctrl+b o            跳到下一个分隔窗口。多屏之间的切换ctrl+b 上下键      上一个及下一个分隔窗口ctrl+b C-方向键    调整分隔窗口大小ctrl+b &amp;           确认后退出当前tmuxctrl+b [           复制模式，即将当前屏幕移到上一个的位置上，其他所有窗口都向前移动一个。ctrl+b c           创建新窗口ctrl+b n           选择下一个窗口ctrl+b l           最后使用的窗口ctrl+b p           选择前一个窗口ctrl+b w           以菜单方式显示及选择窗口ctrl+b s           以菜单方式显示和选择会话。这个常用到，可以选择进入哪个tmuxctrl+b t           显示时钟。然后按enter键后就会恢复到shell终端状态ctrl+b d           脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话</code></pre><h3 id="tmux的常规运维命令"><a href="#tmux的常规运维命令" class="headerlink" title="tmux的常规运维命令"></a>tmux的常规运维命令</h3><pre><code>1）安装命令：　[root@---title: tmux-初探date: 2018-12-07 13:59:25tags:  - tmux  - 骚操作---### Linux终端复用神器-tmux初探​```Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。是BSD实现的Screen替代品，相对于Screen，它更加先进：支持屏幕切分，而且具备丰富的命令行参数，使其可以灵活、动态的进行各种布局和操作。​```废话不多说来个效果图![tmux](https://i.loli.net/2018/12/14/5c139f4ab6ad2.jpg)### Tmux的使用场景​```1）可以某个程序在执行时一直是输出状态，需要结合nohup、&amp;来放在后台执行，并且ctrl+c结束。这时可以打开一个Tmux窗口，在该窗口里执行这个程序，用来保证该程序一直在执行中，只要Tmux这个窗口不关闭2）公司需要备份数据库时，数据量巨大，备份两三天弄不完，这时不小心关闭了终端窗口或误操作就前功尽弃了，使用Tmux会话运行命令或任务，就不用担心这些问题。3）下班后，你需要断开ssh或关闭电脑，将运行的命令或任务放置后台运行。4）关闭终端,再次打开时原终端里面的任务进程依然不会中断​```&lt;!--more--&gt;### Tmux功能：​```-  提供了强劲的、易于使用的命令行界面。-  可横向和纵向分割窗口。-  窗格可以自由移动和调整大小，或直接利用四个预设布局之一。-  支持 UTF-8 编码及 256 色终端。-  可在多个缓冲区进行复制和粘贴。-  可通过交互式菜单来选择窗口、会话及客户端。-  支持跨窗口搜索。-  支持自动及手动锁定窗口。​```### Tmux安装​```yum -y install tmux​```### Tmux个性化配置​```此类配置可以在命令行模式中输入show-options -g查询tmux加上下列参数,实现个性化设置set-option -g base-index 1                        # 窗口的初始序号；默认为0，这里设置为1set-option -g display-time 5000                   # 提示信息的持续时间；设置足够的时间以避免看不清提示，单位为毫秒set-option -g repeat-time 1000                    # 控制台激活后的持续时间；设置合适的时间以避免每次操作都要先激活控制台，单位为毫秒set-option -g status-keys vi                      # 操作状态栏时的默认键盘布局；可以设置为vi或emacsset-option -g status-utf8 on                      # 开启状态栏的UTF-8支持---set-option -g status-bg blueset-option -g status-fg &#39;#bbbbbb&#39;set-option -g status-left-fg greenset-option -g status-left-bg blueset-option -g status-right-fg greenset-option -g status-right-bg blueset-option -g status-left-length 10               # 状态栏左方的内容长度；set-option -g status-right-length 15              # 状态栏右方的内容长度；建议把更多的空间留给状态栏左方（用于列出当前窗口）set-option -g status-left &#39;[#(whoami)]&#39;           # 状态栏左方的内容set-option -g status-right &#39;[#(date +&quot; %m-%d %H:%M &quot;)]&#39;     # 状态栏右方的内容；这里的设置将得到类似23:59的显示set-option -g status-justify &quot;centre&quot;             # 窗口列表居中显示set-option -g default-terminal &quot;screen-256color&quot;  # 支持256色显示分割窗口边界的颜色set-option -g pane-active-border-fg &#39;#55ff55&#39;set-option -g pane-border-fg &#39;#555555&#39;---此类设置可以在命令行模式中输入show-window-options -g查询set-window-option -g mode-keys vi    # 复制模式中的默认键盘布局；可以设置为vi或emacsset-window-option -g utf8 on         # 开启窗口的UTF-8支持set-window-option -g mode-mouse on   # 窗口切换后让人可以用鼠标上下滑动显示历史输出---窗口切分快捷键(没设置成功)bind \ split-window -h                      # 使用 \ 将窗口竖切bind - split-window -v                      # 使用 - 将窗口横切bind K confirm-before -p &quot;kill-window #W? (y/n)&quot; kill-window    # 使用大写 K 来关闭窗口bind &#39;&quot;&#39; choose-window                      # 双引号选择窗口---Pane之间切换的快捷键bind h select-pane -L                       # 定位到左边窗口的快捷键bind j select-pane -D                       # 定位到上边窗口的快捷键bind k select-pane -U                       # 定位到下方窗口的快捷键bind l select-pane -R                       # 定位到右边窗口的快捷键---设置window属性setw -g window-status-current-bg redsetw -g window-status-current-fg whitesetw -g window-status-current-attr brightsetw -g window-status-attr brightset-option -g window-status-format &#39;#I #W&#39;set-option -g window-status-current-format &#39; #I #W &#39;setw -g window-status-current-bg bluesetw -g window-status-current-fg green不使用prefix键，使用Ctrl和左右方向键方便切换窗口bind-key -n &quot;C-Left&quot; select-window -t :-bind-key -n &quot;C-Right&quot; select-window -t :+​```### tmux session 使用介绍​```运行tmux并开启一个新的会话tmux显示所有会话tmux ls新建会话并指定会话名称（建议制定会话名称，以便了解该会话用途）tmux new -s &lt;session-name&gt;新建会话（不指定会话名称）tmux new接入上一个会话tmux a接入指定名称的会话tmux a -t &lt;session-name&gt;断开当前会话（还可以使用快捷键：control+b，再按d）tmux detach关闭指定会话tmux kill-session -t session-name关闭除指定会话外的所有会话tmux kill-session -a -t session-name在会话中切换control+b，再按s 显示会话列表，再进行会话切换销毁所有会话并停止tmuxtmux kill-serverG复制粘贴Ctrl+b   [          //进入复制模式空格+方向键      //选择回车                  //  确认Ctrl+b  [           //粘贴​```### 需要注意的几点​```1）进入tmux面板后，一定要先按ctrl+b，然后松开，再按其他的组合键才生效。2）常用到的几个组合键：ctrl+b ?            显示快捷键帮助ctrl+b 空格键       采用下一个内置布局，这个很有意思，在多屏时，用这个就会将多有屏幕竖着展示ctrl+b !            把当前窗口变为新窗口ctrl+b  &quot;           模向分隔窗口ctrl+b %            纵向分隔窗口ctrl+b q            显示分隔窗口的编号ctrl+b o            跳到下一个分隔窗口。多屏之间的切换ctrl+b 上下键      上一个及下一个分隔窗口ctrl+b C-方向键    调整分隔窗口大小ctrl+b &amp;           确认后退出当前tmuxctrl+b [           复制模式，即将当前屏幕移到上一个的位置上，其他所有窗口都向前移动一个。ctrl+b c           创建新窗口ctrl+b n           选择下一个窗口ctrl+b l           最后使用的窗口ctrl+b p           选择前一个窗口ctrl+b w           以菜单方式显示及选择窗口ctrl+b s           以菜单方式显示和选择会话。这个常用到，可以选择进入哪个tmuxctrl+b t           显示时钟。然后按enter键后就会恢复到shell终端状态ctrl+b d           脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话​```### tmux的常规运维命令​```1）安装命令：　[root@Centos6 ~]# yum -y install tmux　　2）默认创建一个会话，以数字命名。（不推荐）[root@Centos6 ~]# tmux　　3）新建会话，比如新创建一个会话以&quot;ccc&quot;命名[root@Centos6 ~]# tmux new -s ccc加上参数-d，表示在后台新建会话root@bobo:~# tmux new -s shibo -droot@bobo:~# tmux lsshibo: 1 windows (created Tue Oct  2 19:22:32 2018) [135x35]4）查看创建得所有会话[root@Centos6 ~]# tmux ls0: 1 windows (created Wed Aug 30 17:58:20 2017) [112x22](attached)    #这里的attached表示该会话是当前会话aaa: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]ccc: 1 windows (created Wed Aug 30 17:01:05 2017) [112x22]5）登录一个已知会话。即从终端环境进入会话。第一个参数a也可以写成attach。后面的aaa是会话名称。[root@Centos6 ~]# tmux a -t aaa 　　6）退出会话不是关闭：登到某一个会话后，依次按键ctrl-b + d，这样就会退化该会话，但不会关闭会话。如果直接ctrl + d，就会在退出会话的通话也关闭了该会话！7）关闭会话（销毁会话）[root@Centos6 ~]# tmux lsaaa: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]bbb: 1 windows (created Wed Aug 30 19:02:09 2017) [112x22][root@Centos6 ~]# tmux kill-session -t bbb[root@Centos6 ~]# tmux lsaaa: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]8）重命名会话[root@Centos6 ~]# tmux ls  wangshibo: 1 windows (created Sun Sep 30 10:17:00 2018) [136x29] (attached)[root@Centos6 ~]# tmux rename -t wangshibo kevin[root@Centos6 ~]# tmux lskevin: 1 windows (created Sun Sep 30 10:17:00 2018) [136x29] (attached)​```---title: tmux-初探date: 2018-12-07 13:59:25tags:  - tmux  - 骚操作---### Linux终端复用神器-tmux初探​```Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。是BSD实现的Screen替代品，相对于Screen，它更加先进：支持屏幕切分，而且具备丰富的命令行参数，使其可以灵活、动态的进行各种布局和操作。​```废话不多说来个效果图![tmux](https://i.loli.net/2018/12/14/5c139f4ab6ad2.jpg)### Tmux的使用场景​```1）可以某个程序在执行时一直是输出状态，需要结合nohup、&amp;来放在后台执行，并且ctrl+c结束。这时可以打开一个Tmux窗口，在该窗口里执行这个程序，用来保证该程序一直在执行中，只要Tmux这个窗口不关闭2）公司需要备份数据库时，数据量巨大，备份两三天弄不完，这时不小心关闭了终端窗口或误操作就前功尽弃了，使用Tmux会话运行命令或任务，就不用担心这些问题。3）下班后，你需要断开ssh或关闭电脑，将运行的命令或任务放置后台运行。4）关闭终端,再次打开时原终端里面的任务进程依然不会中断​```&lt;!--more--&gt;### Tmux功能：​```-  提供了强劲的、易于使用的命令行界面。-  可横向和纵向分割窗口。-  窗格可以自由移动和调整大小，或直接利用四个预设布局之一。-  支持 UTF-8 编码及 256 色终端。-  可在多个缓冲区进行复制和粘贴。-  可通过交互式菜单来选择窗口、会话及客户端。-  支持跨窗口搜索。-  支持自动及手动锁定窗口。​```### Tmux安装​```yum -y install tmux​```### Tmux个性化配置​```此类配置可以在命令行模式中输入show-options -g查询tmux加上下列参数,实现个性化设置set-option -g base-index 1                        # 窗口的初始序号；默认为0，这里设置为1set-option -g display-time 5000                   # 提示信息的持续时间；设置足够的时间以避免看不清提示，单位为毫秒set-option -g repeat-time 1000                    # 控制台激活后的持续时间；设置合适的时间以避免每次操作都要先激活控制台，单位为毫秒set-option -g status-keys vi                      # 操作状态栏时的默认键盘布局；可以设置为vi或emacsset-option -g status-utf8 on                      # 开启状态栏的UTF-8支持---set-option -g status-bg blueset-option -g status-fg &#39;#bbbbbb&#39;set-option -g status-left-fg greenset-option -g status-left-bg blueset-option -g status-right-fg greenset-option -g status-right-bg blueset-option -g status-left-length 10               # 状态栏左方的内容长度；set-option -g status-right-length 15              # 状态栏右方的内容长度；建议把更多的空间留给状态栏左方（用于列出当前窗口）set-option -g status-left &#39;[#(whoami)]&#39;           # 状态栏左方的内容set-option -g status-right &#39;[#(date +&quot; %m-%d %H:%M &quot;)]&#39;     # 状态栏右方的内容；这里的设置将得到类似23:59的显示set-option -g status-justify &quot;centre&quot;             # 窗口列表居中显示set-option -g default-terminal &quot;screen-256color&quot;  # 支持256色显示分割窗口边界的颜色set-option -g pane-active-border-fg &#39;#55ff55&#39;set-option -g pane-border-fg &#39;#555555&#39;---此类设置可以在命令行模式中输入show-window-options -g查询set-window-option -g mode-keys vi    # 复制模式中的默认键盘布局；可以设置为vi或emacsset-window-option -g utf8 on         # 开启窗口的UTF-8支持set-window-option -g mode-mouse on   # 窗口切换后让人可以用鼠标上下滑动显示历史输出---窗口切分快捷键(没设置成功)bind \ split-window -h                      # 使用 \ 将窗口竖切bind - split-window -v                      # 使用 - 将窗口横切bind K confirm-before -p &quot;kill-window #W? (y/n)&quot; kill-window    # 使用大写 K 来关闭窗口bind &#39;&quot;&#39; choose-window                      # 双引号选择窗口---Pane之间切换的快捷键bind h select-pane -L                       # 定位到左边窗口的快捷键bind j select-pane -D                       # 定位到上边窗口的快捷键bind k select-pane -U                       # 定位到下方窗口的快捷键bind l select-pane -R                       # 定位到右边窗口的快捷键---设置window属性setw -g window-status-current-bg redsetw -g window-status-current-fg whitesetw -g window-status-current-attr brightsetw -g window-status-attr brightset-option -g window-status-format &#39;#I #W&#39;set-option -g window-status-current-format &#39; #I #W &#39;setw -g window-status-current-bg bluesetw -g window-status-current-fg green不使用prefix键，使用Ctrl和左右方向键方便切换窗口bind-key -n &quot;C-Left&quot; select-window -t :-bind-key -n &quot;C-Right&quot; select-window -t :+​```### tmux session 使用介绍​```运行tmux并开启一个新的会话tmux显示所有会话tmux ls新建会话并指定会话名称（建议制定会话名称，以便了解该会话用途）tmux new -s &lt;session-name&gt;新建会话（不指定会话名称）tmux new接入上一个会话tmux a接入指定名称的会话tmux a -t &lt;session-name&gt;断开当前会话（还可以使用快捷键：control+b，再按d）tmux detach关闭指定会话tmux kill-session -t session-name关闭除指定会话外的所有会话tmux kill-session -a -t session-name在会话中切换control+b，再按s 显示会话列表，再进行会话切换销毁所有会话并停止tmuxtmux kill-serverG复制粘贴Ctrl+b   [          //进入复制模式空格+方向键      //选择回车                  //  确认Ctrl+b  [           //粘贴​```### 需要注意的几点​```1）进入tmux面板后，一定要先按ctrl+b，然后松开，再按其他的组合键才生效。2）常用到的几个组合键：ctrl+b ?            显示快捷键帮助ctrl+b 空格键       采用下一个内置布局，这个很有意思，在多屏时，用这个就会将多有屏幕竖着展示ctrl+b !            把当前窗口变为新窗口ctrl+b  &quot;           模向分隔窗口ctrl+b %            纵向分隔窗口ctrl+b q            显示分隔窗口的编号ctrl+b o            跳到下一个分隔窗口。多屏之间的切换ctrl+b 上下键      上一个及下一个分隔窗口ctrl+b C-方向键    调整分隔窗口大小ctrl+b &amp;           确认后退出当前tmuxctrl+b [           复制模式，即将当前屏幕移到上一个的位置上，其他所有窗口都向前移动一个。ctrl+b c           创建新窗口ctrl+b n           选择下一个窗口ctrl+b l           最后使用的窗口ctrl+b p           选择前一个窗口ctrl+b w           以菜单方式显示及选择窗口ctrl+b s           以菜单方式显示和选择会话。这个常用到，可以选择进入哪个tmuxctrl+b t           显示时钟。然后按enter键后就会恢复到shell终端状态ctrl+b d           脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话​```### tmux的常规运维命令​```1）安装命令：　[root@---title: tmux-初探date: 2018-12-07 13:59:25tags:  - tmux  - 骚操作---### Linux终端复用神器-tmux初探​```Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。是BSD实现的Screen替代品，相对于Screen，它更加先进：支持屏幕切分，而且具备丰富的命令行参数，使其可以灵活、动态的进行各种布局和操作。​```废话不多说来个效果图![tmux](https://i.loli.net/2018/12/14/5c139f4ab6ad2.jpg)### Tmux的使用场景​```1）可以某个程序在执行时一直是输出状态，需要结合nohup、&amp;来放在后台执行，并且ctrl+c结束。这时可以打开一个Tmux窗口，在该窗口里执行这个程序，用来保证该程序一直在执行中，只要Tmux这个窗口不关闭2）公司需要备份数据库时，数据量巨大，备份两三天弄不完，这时不小心关闭了终端窗口或误操作就前功尽弃了，使用Tmux会话运行命令或任务，就不用担心这些问题。3）下班后，你需要断开ssh或关闭电脑，将运行的命令或任务放置后台运行。4）关闭终端,再次打开时原终端里面的任务进程依然不会中断​```&lt;!--more--&gt;### Tmux功能：​```-  提供了强劲的、易于使用的命令行界面。-  可横向和纵向分割窗口。-  窗格可以自由移动和调整大小，或直接利用四个预设布局之一。-  支持 UTF-8 编码及 256 色终端。-  可在多个缓冲区进行复制和粘贴。-  可通过交互式菜单来选择窗口、会话及客户端。-  支持跨窗口搜索。-  支持自动及手动锁定窗口。​```### Tmux安装​```yum -y install tmux​```### Tmux个性化配置​```此类配置可以在命令行模式中输入show-options -g查询tmux加上下列参数,实现个性化设置set-option -g base-index 1                        # 窗口的初始序号；默认为0，这里设置为1set-option -g display-time 5000                   # 提示信息的持续时间；设置足够的时间以避免看不清提示，单位为毫秒set-option -g repeat-time 1000                    # 控制台激活后的持续时间；设置合适的时间以避免每次操作都要先激活控制台，单位为毫秒set-option -g status-keys vi                      # 操作状态栏时的默认键盘布局；可以设置为vi或emacsset-option -g status-utf8 on                      # 开启状态栏的UTF-8支持---set-option -g status-bg blueset-option -g status-fg &#39;#bbbbbb&#39;set-option -g status-left-fg greenset-option -g status-left-bg blueset-option -g status-right-fg greenset-option -g status-right-bg blueset-option -g status-left-length 10               # 状态栏左方的内容长度；set-option -g status-right-length 15              # 状态栏右方的内容长度；建议把更多的空间留给状态栏左方（用于列出当前窗口）set-option -g status-left &#39;[#(whoami)]&#39;           # 状态栏左方的内容set-option -g status-right &#39;[#(date +&quot; %m-%d %H:%M &quot;)]&#39;     # 状态栏右方的内容；这里的设置将得到类似23:59的显示set-option -g status-justify &quot;centre&quot;             # 窗口列表居中显示set-option -g default-terminal &quot;screen-256color&quot;  # 支持256色显示分割窗口边界的颜色set-option -g pane-active-border-fg &#39;#55ff55&#39;set-option -g pane-border-fg &#39;#555555&#39;---此类设置可以在命令行模式中输入show-window-options -g查询set-window-option -g mode-keys vi    # 复制模式中的默认键盘布局；可以设置为vi或emacsset-window-option -g utf8 on         # 开启窗口的UTF-8支持set-window-option -g mode-mouse on   # 窗口切换后让人可以用鼠标上下滑动显示历史输出---窗口切分快捷键(没设置成功)bind \ split-window -h                      # 使用 \ 将窗口竖切bind - split-window -v                      # 使用 - 将窗口横切bind K confirm-before -p &quot;kill-window #W? (y/n)&quot; kill-window    # 使用大写 K 来关闭窗口bind &#39;&quot;&#39; choose-window                      # 双引号选择窗口---Pane之间切换的快捷键bind h select-pane -L                       # 定位到左边窗口的快捷键bind j select-pane -D                       # 定位到上边窗口的快捷键bind k select-pane -U                       # 定位到下方窗口的快捷键bind l select-pane -R                       # 定位到右边窗口的快捷键---设置window属性setw -g window-status-current-bg redsetw -g window-status-current-fg whitesetw -g window-status-current-attr brightsetw -g window-status-attr brightset-option -g window-status-format &#39;#I #W&#39;set-option -g window-status-current-format &#39; #I #W &#39;setw -g window-status-current-bg bluesetw -g window-status-current-fg green不使用prefix键，使用Ctrl和左右方向键方便切换窗口bind-key -n &quot;C-Left&quot; select-window -t :-bind-key -n &quot;C-Right&quot; select-window -t :+​```### tmux session 使用介绍​```运行tmux并开启一个新的会话tmux显示所有会话tmux ls新建会话并指定会话名称（建议制定会话名称，以便了解该会话用途）tmux new -s &lt;session-name&gt;新建会话（不指定会话名称）tmux new接入上一个会话tmux a接入指定名称的会话tmux a -t &lt;session-name&gt;断开当前会话（还可以使用快捷键：control+b，再按d）tmux detach关闭指定会话tmux kill-session -t session-name关闭除指定会话外的所有会话tmux kill-session -a -t session-name在会话中切换control+b，再按s 显示会话列表，再进行会话切换销毁所有会话并停止tmuxtmux kill-serverG复制粘贴Ctrl+b   [          //进入复制模式空格+方向键      //选择回车                  //  确认Ctrl+b  [           //粘贴​```### 需要注意的几点​```1）进入tmux面板后，一定要先按ctrl+b，然后松开，再按其他的组合键才生效。2）常用到的几个组合键：ctrl+b ?            显示快捷键帮助ctrl+b 空格键       采用下一个内置布局，这个很有意思，在多屏时，用这个就会将多有屏幕竖着展示ctrl+b !            把当前窗口变为新窗口ctrl+b  &quot;           模向分隔窗口ctrl+b %            纵向分隔窗口ctrl+b q            显示分隔窗口的编号ctrl+b o            跳到下一个分隔窗口。多屏之间的切换ctrl+b 上下键      上一个及下一个分隔窗口ctrl+b C-方向键    调整分隔窗口大小ctrl+b &amp;           确认后退出当前tmuxctrl+b [           复制模式，即将当前屏幕移到上一个的位置上，其他所有窗口都向前移动一个。ctrl+b c           创建新窗口ctrl+b n           选择下一个窗口ctrl+b l           最后使用的窗口ctrl+b p           选择前一个窗口ctrl+b w           以菜单方式显示及选择窗口ctrl+b s           以菜单方式显示和选择会话。这个常用到，可以选择进入哪个tmuxctrl+b t           显示时钟。然后按enter键后就会恢复到shell终端状态ctrl+b d           脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话​```### tmux的常规运维命令​```1）安装命令：　[root@1000phone ~]# yum -y install tmux　　2）默认创建一个会话，以数字命名。（不推荐）[root@1000phone ~]# tmux　　3）新建会话，比如新创建一个会话以&quot;ccc&quot;命名[root@1000phone ~]# tmux new -s ccc加上参数-d，表示在后台新建会话root@1000phone:~# tmux new -s 1000phone -droot@1000phone:~# tmux ls1000phone: 1 windows (created Tue Oct  2 19:22:32 2018) [135x35]4）查看创建得所有会话[root@1000phone ~]# tmux ls0: 1 windows (created Wed Aug 30 17:58:20 2017) [112x22](attached)    #这里的attached表示该会话是当前会话1000phone: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]ccc: 1 windows (created Wed Aug 30 17:01:05 2017) [112x22]5）登录一个已知会话。即从终端环境进入会话。第一个参数a也可以写成attach。后面的aaa是会话名称。[root@1000phone ~]# tmux a -t 1000phone 　　6）退出会话不是关闭：登到某一个会话后，依次按键ctrl-b + d，这样就会退化该会话，但不会关闭会话。如果直接ctrl + d，就会在退出会话的通话也关闭了该会话！7）关闭会话（销毁会话）[root@1000phone ~]# tmux ls1000phone: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]bbb: 1 windows (created Wed Aug 30 19:02:09 2017) [112x22][root@1000phone ~]# tmux kill-session -t bbb[root@1000phone ~]# tmux ls1000phone: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]8）重命名会话[root@1000phone ~]# tmux ls  tigerfive: 1 windows (created Sun Sep 30 10:17:00 2018) [136x29] (attached)[root@1000phone ~]# tmux rename -t tigerfive 1000phone[root@Centos6 ~]# tmux ls1000phone: 1 windows (created Sun Sep 30 10:17:00 2018) [136x29] (attached)​``` ~]# yum -y install tmux　　2）默认创建一个会话，以数字命名。（不推荐）[root@1000phone ~]# tmux　　3）新建会话，比如新创建一个会话以&quot;ccc&quot;命名[root@1000phone ~]# tmux new -s ccc加上参数-d，表示在后台新建会话root@1000phone:~# tmux new -s 1000phone -droot@1000phone:~# tmux ls1000phone: 1 windows (created Tue Oct  2 19:22:32 2018) [135x35]4）查看创建得所有会话[root@1000phone ~]# tmux ls0: 1 windows (created Wed Aug 30 17:58:20 2017) [112x22](attached)    #这里的attached表示该会话是当前会话aaa: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]ccc: 1 windows (created Wed Aug 30 17:01:05 2017) [112x22]5）登录一个已知会话。即从终端环境进入会话。第一个参数a也可以写成attach。后面的aaa是会话名称。[root@1000phone ~]# tmux a -t aaa 　　6）退出会话不是关闭：登到某一个会话后，依次按键ctrl-b + d，这样就会退化该会话，但不会关闭会话。如果直接ctrl + d，就会在退出会话的通话也关闭了该会话！7）关闭会话（销毁会话）[root@1000phone ~]# tmux lsaaa: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]bbb: 1 windows (created Wed Aug 30 19:02:09 2017) [112x22][root@1000phone ~]# tmux kill-session -t bbb[root@1000phone ~]# tmux lsaaa: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]8）重命名会话[root@1000phone ~]# tmux ls  wangshibo: 1 windows (created Sun Sep 30 10:17:00 2018) [136x29] (attached)[root@1000phone ~]# tmux rename -t wangshibo kevin[root@1000phone ~]# tmux lskevin: 1 windows (created Sun Sep 30 10:17:00 2018) [136x29] (attached)​```</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix源码安装</title>
      <link href="2019/08/05/jian-kong/zabbix-yuan-ma-an-zhuang/"/>
      <url>2019/08/05/jian-kong/zabbix-yuan-ma-an-zhuang/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="Zabbix源码安装"><a href="#Zabbix源码安装" class="headerlink" title="Zabbix源码安装"></a>Zabbix源码安装</h3><h4 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1:前期准备"></a>1:前期准备</h4><p> 注意安装zabbix需要lnmp环境可以使用脚本安装lnmp</p><p>这里我进行源码安装一步步的操作</p><p>建议使用脚本进行 用源码安装比较慢</p><h5 id="1-关闭防火墙和selinux-建议可以实行放行策略"><a href="#1-关闭防火墙和selinux-建议可以实行放行策略" class="headerlink" title="(1) 关闭防火墙和selinux 建议可以实行放行策略"></a>(1) 关闭防火墙和selinux 建议可以实行放行策略</h5><h5 id="2-创建安装目录"><a href="#2-创建安装目录" class="headerlink" title="(2)创建安装目录"></a>(2)创建安装目录</h5><pre class=" language-shell"><code class="language-shell">   mkdir -pv /cyylog/{mysql-5.7,nginx-1.16,php-7.2,zabbix-4.4}   mkdir -pv /cyylog/mysql-5.7/data   ln -s /cyylog/mysql-5.7 /cyylog/mysql   ln -s /cyylog/nginx-1.16 /cyylog/nginx   ln -s /cyylog/php-7.2 /cyylog/php   ln -s /cyylog/zabbix-4.4 /cyylog/zabbix</code></pre><h5 id="3-创建用户"><a href="#3-创建用户" class="headerlink" title="(3)创建用户"></a>(3)创建用户</h5><pre class=" language-shell"><code class="language-shell">   useradd -s /sbin/nologin mysql   useradd -s /sbin/nologin nginx   useradd -s /sbin/nologin zabbix</code></pre><p>也可执行脚本</p><h4 id="2-安装mysql"><a href="#2-安装mysql" class="headerlink" title="2:安装mysql"></a>2:安装mysql</h4><h5 id="1-下载mysql源码包"><a href="#1-下载mysql源码包" class="headerlink" title="(1)下载mysql源码包"></a>(1)下载mysql源码包</h5><pre class=" language-shell"><code class="language-shell">wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.29.tar.gzwget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-boost-5.7.29.tar.gz</code></pre><h5 id="2-使用yum安装依赖包"><a href="#2-使用yum安装依赖包" class="headerlink" title="(2) 使用yum安装依赖包"></a><strong>(2)</strong> 使用yum安装依赖包</h5><pre class=" language-shell"><code class="language-shell">yum install -y cmake gcc gcc-c++ openssl-devel ncurses-devel</code></pre><h5 id="3-解压并进入进行安装"><a href="#3-解压并进入进行安装" class="headerlink" title="(3) 解压并进入进行安装"></a><strong>(3)</strong> 解压并进入进行安装</h5><pre class=" language-shell"><code class="language-shell">tar xvf mysql-5.7.29.tar.gztar xvf mysql-boost-5.7.29.tar.gz -C /cyylog/配置cmake \-DCMAKE_INSTALL_PREFIX=/cyylog/mysql-5.7 \-DMYSQL_DATADIR=/cyylog/mysql-5.7/data \-DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_unicode_ci \-DWITH_READLINE=1 \-DWITH_SSL=system \-DWITH_EMBEDDED_SERVER=1 \-DENABLED_LOCAL_INFILE=1 \-DDEFAULT_COLLATION=utf8_general_ci \-DWITH_MYISAM_STORAGE_ENGINE=1 \-DWITH_INNOBASE_STORAGE_ENGINE=1 \-DWITH_DEBUG=0 \-DWITH_BOOST=/cyylog/mysql-5.7.29/boost/boost_1_59_0编译且安装 make & make install</code></pre><h5 id="4-创建需要的文件及更改属主和属组"><a href="#4-创建需要的文件及更改属主和属组" class="headerlink" title="(4) 创建需要的文件及更改属主和属组"></a><strong>(4)</strong> 创建需要的文件及更改属主和属组</h5><pre class=" language-shell"><code class="language-shell">mkdir -pv /cyylog/mysql/logtouch /cyylog/mysql/log/mariadb.logtouch /cyylog/mysql/log/mariadb.pidchown -R /cyylog/{mysql-5.7,mysql-5.7.29,mysql}</code></pre><h5 id="5-初始化数据"><a href="#5-初始化数据" class="headerlink" title="(5) 初始化数据"></a><strong>(5)</strong> 初始化数据</h5><pre class=" language-shell"><code class="language-shell">修改配置文件 vim /etc/my.cnf[mysqld]datadir=/cyylog/mysql/data #数据存储的地方socket=/cyylog/mysql/mysql.sock #sock文件的路径skip-grant-tables #跳过登录认证user=mysqlexplicit_defaults_for_timestamp=true[mysqld_safe]log-error=/cyylog/mysql/log/mariadb.log #错误日志存放的地方pid-file=/cyylog/mysql/log/mariadb.pid</code></pre><h5 id="6-添加至环境变量"><a href="#6-添加至环境变量" class="headerlink" title="(6) 添加至环境变量"></a><strong>(6)</strong> 添加至环境变量</h5><pre class=" language-shell"><code class="language-shell">vim /etc/profile 修改末尾添加两行export PATH=$PATH:/cyylog/mysql/support-filesexport PATH=$PATH:/cyylog/mysql/bin保存退出刷新环境变量 source /etc/profile/</code></pre><h5 id="7-初始化启动mysql"><a href="#7-初始化启动mysql" class="headerlink" title="(7) 初始化启动mysql"></a><strong>(7)</strong> 初始化启动mysql</h5><pre class=" language-shell"><code class="language-shell">mysqld --initialize --user=mysql --basedir=/cyylog/mysql --datadir=/cyylog/mysql/datamysql.server startln -s /cyylog/mysql/mysql.sock /tmp/</code></pre><h5 id="8-下载zabbix源码包并进行解压"><a href="#8-下载zabbix源码包并进行解压" class="headerlink" title="(8) 下载zabbix源码包并进行解压"></a><strong>(8)</strong> 下载zabbix源码包并进行解压</h5><pre class=" language-shell"><code class="language-shell">wget https://sourceforge.net/projects/zabbix/files/ZABBIX%20Latest%20Stable/4.4.5/zabbix-4.4.5.tar.gztar xvf zabbix-4.4.5.tar.gzcd zabbix-4.4.5/database/mysql登录mysql   命令为 mysql -u root 进入后执行以下命令use mysql;create database zabbix default character set utf8;update mysql.user set authentication_string=password('修改的密码') where user='root';use zabbix;source schema.sql;source images.sql;source data.sql;quit;   最后恢复密码登录mysql 修改文件vim /etc/my.cnf去掉 skip-grant-tables保存退出重启mysql服务 mysql.sercer restart添加lib文件echo “/cyylog/mysql/lib” > /etc/ld.so.conf.d/mysql.confldconfig -v</code></pre><h4 id="3-安装nginx"><a href="#3-安装nginx" class="headerlink" title="3:安装nginx"></a>3:安装nginx</h4><h5 id="1-下载-nginx-并解压"><a href="#1-下载-nginx-并解压" class="headerlink" title="(1) 下载 nginx  并解压"></a>(1) 下载 nginx  并解压</h5><pre class=" language-shell"><code class="language-shell">wget http://nginx.org/download/nginx-1.16.1.tar.gztar xvf nginx-1.16.1.tar.gz</code></pre><h5 id="2-编译安装并添加环境变量"><a href="#2-编译安装并添加环境变量" class="headerlink" title="(2) 编译安装并添加环境变量"></a><strong>(2)</strong> 编译安装并添加环境变量</h5><pre class=" language-shell"><code class="language-shell">cd nginx-1.16.1./configure --prefix=/cyylog/nginx-1.16 --user=nginx --group=nginx --without-select_module --without-poll_module --with-http_ssl_module --with-pcre --with-debugmake make install 添加变量vim /etc/profile 追加一行export PATH=$PATH://cyylog/nginx/sbin保存退出刷新变量source /etc/profile</code></pre><h5 id="3-更改-nginx-的属主和属组以及修改配置文件"><a href="#3-更改-nginx-的属主和属组以及修改配置文件" class="headerlink" title="(3)更改 nginx 的属主和属组以及修改配置文件"></a><strong>(3)</strong>更改 nginx 的属主和属组以及修改配置文件</h5><pre class=" language-shell"><code class="language-shell">chown nginx:nginx -R /cyylog/nginx-1.16修改配置文件vim /cyylog/nginx/conf/nginx.conf修改启动用户 user nginx;启动nginx  nginx</code></pre><h4 id="4-安装php"><a href="#4-安装php" class="headerlink" title="4:安装php"></a>4:安装php</h4><h5 id="1-下载php源码并井进行解压"><a href="#1-下载php源码并井进行解压" class="headerlink" title="(1) 下载php源码并井进行解压"></a><strong>(1)</strong> <strong>下载php源码并井进行解压</strong></h5><pre class=" language-shell"><code class="language-shell">wget https://www.php.net/distributions/php-7.2.27.tar.gztar xvf php-7.2.27.tar.gz</code></pre><p><strong>(2)</strong> <strong>安装及解决依赖</strong></p><pre class=" language-shell"><code class="language-shell">yum install -y libxml2-devel openssl-devel net-snmp net-snmp-devel libcurl-devel libjpeg-devel libpng-devel libicu-devel openldap-devel bzip2 bzip2-devel freetype-devel gmp-devel readline-devel libxslt-devel fontconfigcd php-7.2.27./configure --prefix=/cyylog/php-7.2 --with-mysqli=/cyylog/mysql/bin/mysql_config --enable-inline-optimization --enable-fpm --enable-soap --enable-pcntl --enable-xml --with-libxml-dir --with-xmlrpc --with-openssl --with-mhash --with-pcre-regex --with-sqlite3 --with-zlib --enable-bcmath --with-iconv --with-bz2 --enable-calendar --with-curl --with-cdb --enable-dom --enable-exif --enable-fileinfo --enable-filter --with-pcre-dir --enable-ftp --with-gd --with-openssl-dir --with-jpeg-dir --with-png-dir --with-freetype-dir --with-gettext --with-gmp --with-mhash --enable-json --enable-mbstring --disable-mbregex --disable-mbregex-backtrack --with-libmbfl --with-onig --enable-pdo --with-pdo-mysql --with-zlib-dir --with-pdo-sqlite --with-readline --enable-session --enable-shmop --enable-simplexml --enable-sockets --enable-sysvmsg --enable-sysvsem --enable-sysvshm --enable-wddx --with-libxml-dir --with-xsl --enable-zip --enable-mysqlnd-compression-support --with-pear --without-pear make make install</code></pre><h5 id="3-拷贝服务和配置文件及属主和属组"><a href="#3-拷贝服务和配置文件及属主和属组" class="headerlink" title="(3) 拷贝服务和配置文件及属主和属组"></a><strong>(3)</strong> 拷贝服务和配置文件及属主和属组</h5><pre class=" language-shell"><code class="language-shell">cp /root/php-7.2.27/sapi/fpm/php-fpm.service /usr/lib/systemd/system/php-fpm.servicecp /cyylog/php-7.2/etc/{php-fpm.conf.default,php-fpm.conf}cp /cyylog/php-7.2/etc/php-fpm.d/www.conf{.default,}cp php.ini-production /cyylog/php-7.2/lib/php.inichown nginx:nginx -R /cyylog/php-7.2</code></pre><p><strong>(4)</strong> <strong>修改配置文件并启动</strong></p><pre class=" language-shell"><code class="language-shell">#### 修改php.ini配置文件vim /cyylog/php/lib/php.ini 修改四行post_max_size = 16Mmax_execution_time = 300max_input_time = 300date.timezone = PRC#### 启动php服务systemctl start php-fpm.service && systemctl enable php-fpm.service#### 修改nginx.conf文件是nginx支持phpvim /cyylog/nginx/conf/nginx.conf 修改如下 location ~ \.php$ {            root           /cyylog/nginx/html;            fastcgi_pass   127.0.0.1:9000;            fastcgi_index  index.php;            fastcgi_param  SCRIPT_FILENAME  /cyylog/nginx/html$fastcgi_script_name;            include        fastcgi_params;        }#### 编写测试php文件 vim /cyylog/nginx/html/index.php          <?php phpinfo(); ?>#### 重启nginx服务 nginx -s reload    重启nginx服务 nginx -s reload</code></pre><h4 id="5-安装zabbix"><a href="#5-安装zabbix" class="headerlink" title="5:安装zabbix"></a>5:安装zabbix</h4><h5 id="1-安装依赖以及编译安装"><a href="#1-安装依赖以及编译安装" class="headerlink" title="(1) 安装依赖以及编译安装"></a><strong>(1)</strong> 安装依赖以及编译安装</h5><pre class=" language-shell"><code class="language-shell">yum localinstall -y libevent-devel-2.0.21-4.el7.x86_64.rpmyum install unixODBC-devel mysql-devel net-snmp-devel libxml2-devel libcurl-devel libevent-devel -y配置cd zabbix-4.4.5./configure --prefix=/cyylog/zabbix-4.4 --enable-server --enable-agent --with-mysql=/cyylog/mysql/bin/mysql_config --enable-ipv6 --with-netsnmp --with-libcurl --with-libxml2make make install</code></pre><p>(2) 配置环境变量</p><pre class=" language-shell"><code class="language-shell">vim /etc/profile 追加一行export PATH=$PATH://cyylog/zabbix/sbin#### 保存退出 刷新 source /etc/profile</code></pre><p>(3) 修改配置文件</p><pre class=" language-shell"><code class="language-shell">vim /cyylog/zabbix/etc/zabbix_server.conf  ##修改如下DBUser=rootDBPassword=beimi123拷贝zabbix至nginx的目录下cp -R frontends/php/* /cyylog/nginx/html/重启nginx服务  nginx -s reload</code></pre><p>访问页面ok就行</p><p>注意连接数据库那个步骤需要将服务器ip改为127.0.0.1 不能使用localhost</p><p>否则会报错</p><p>接下会有个配置文件无法安装需手动下载下来传到ngin目录下</p><p>最后完成</p><p>登录账户为 admin 密码zabbix</p><p>登录后界面为</p><p><img src="C:%5CUsers%5CCyy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200523132054294.png" alt="image-20200523132054294"></p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx性能优化</title>
      <link href="2019/08/05/linux/nginx/nginx-xing-neng-you-hua/"/>
      <url>2019/08/05/linux/nginx/nginx-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><img src="https://p6-tt.byteimg.com/large/pgc-image/95d788eda3ed45b58b6e982192a7a650" alt="img"></p><p>当我需要进行性能优化时，说明我们服务器无法满足日益增长的业务。性能优化是一个比较大的课题，需要从以下几个方面进行探讨</p><ul><li>当前系统结构瓶颈</li><li>了解业务模式</li><li>性能与安全</li></ul><h4 id="1、当前系统结构瓶颈"><a href="#1、当前系统结构瓶颈" class="headerlink" title="1、当前系统结构瓶颈"></a>1、当前系统结构瓶颈</h4><p>首先需要了解的是当前系统瓶颈，用的是什么，跑的是什么业务。里面的服务是什么样子，每个服务最大支持多少并发。比如针对nginx而言，我们处理静态资源效率最高的瓶颈是多大？能支持多少qps访问请求？怎么得出系统当前的结构瓶颈？</p><p>可以通过查看当前cpu负荷，内存使用率，进程使用率来做简单判断。还可以通过操作系统的一些工具来判断当前系统性能瓶颈，如分析对应的日志，查看请求数量。也可以通过nginx http_stub_status_module模块来查看对应的连接数，总握手次数，总请求数。也可以对线上进行压力测试，来了解当前的系统能性能，并发数，做好性能评估。</p><h4 id="2、了解业务模式"><a href="#2、了解业务模式" class="headerlink" title="2、了解业务模式"></a>2、了解业务模式</h4><p>虽然我们是在做性能优化，但还是要熟悉业务，最终目的都是为业务服务的。我们要了解每一个接口业务类型是什么样的业务，比如电子商务抢购模式，这种情况平时流量会很小，但是到了抢购时间，流量一下子就会猛涨。也要了解系统层级结构，每一层在中间层做的是代理还是动静分离，还是后台进行直接服务。需要我们对业务接入层和系统层次要有一个梳理</p><h4 id="3、性能与安全"><a href="#3、性能与安全" class="headerlink" title="3、性能与安全"></a>3、性能与安全</h4><p>性能与安全也是一个需要考虑的因素，往往大家注重性能忽略安全或注重安全又忽略性能。比如说我们在设计防火墙时，如果规则过于全面肯定会对性能方面有影响。如果对性能过于注重在安全方面肯定会留下很大隐患。所以大家要评估好两者的关系，把握好两者的孰重孰轻，以及整体的相关性。权衡好对应的点。</p><h4 id="4、系统与nginx性能优化"><a href="#4、系统与nginx性能优化" class="headerlink" title="4、系统与nginx性能优化"></a>4、系统与nginx性能优化</h4><p>大家对相关的系统瓶颈及现状有了一定的了解之后，就可以根据影响性能方面做一个全体的评估和优化。</p><ul><li>网络（网络流量、是否有丢包，网络的稳定性都会影响用户请求）</li><li>系统（系统负载、饱和、内存使用率、系统的稳定性、硬件磁盘是否有损坏）</li><li>服务（连接优化、内核性能优化、http服务请求优化都可以在nginx中根据业务来进行设置）</li><li>程序（接口性能、处理请求速度、每个程序的执行效率）</li><li>数据库、底层服务</li></ul><p>上面列举出来每一级都会有关联，也会影响整体性能，这里主要关注的是nginx服务这一层。</p><h5 id="1、文件句柄"><a href="#1、文件句柄" class="headerlink" title="1、文件句柄"></a>1、文件句柄</h5><p>在linux/unix操作系统中一切皆文件，我们的设备是文件，文件是文件，文件夹也是文件。当我们用户每发起一次请求，就会产生一个文件句柄。文件句柄可以简单的理解为文件句柄就是一个索引。文件句柄就会随着请求量的增多,进程调用频繁增加，那么产生的文件句柄也就会越多。</p><p>系统默认对文件句柄是有限制的，不可能会让一个进程无限制的调用句柄。因为系统资源是有限的，所以我们需要限制每一个服务能够使用多大的文件句柄。操作系统默认使用的文件句柄是1024个句柄。</p><h5 id="2、设置方式"><a href="#2、设置方式" class="headerlink" title="2、设置方式"></a>2、设置方式</h5><ul><li>系统全局性修改</li><li>用户局部性修改</li><li>进程局部性修改</li></ul><h5 id="3、系统全局性修该和用户局部性修改"><a href="#3、系统全局性修该和用户局部性修改" class="headerlink" title="3、系统全局性修该和用户局部性修改"></a>3、系统全局性修该和用户局部性修改</h5><pre><code>[root@server ~]#vim /etc/security/limits.conf</code></pre><p>在文件最下面找到</p><pre><code>#*               soft    core            0#*               hard    rss             10000#@student        hard    nproc           20#@faculty        soft    nproc           20#@faculty        hard    nproc           50#ftp             hard    nproc           0#@student        -       maxlogins       4#root只是针对root这个用户来限制，soft只是发提醒，操作系统不会强制限制,一般的站点设置为一万左右就ok了root soft nofile 65535root hard nofile 65535# *代表通配符 所有的用户*    soft nofile 25535*    hard nofile 25535</code></pre><p>可以看到root和<em>，root代表是root用户，</em>代表的是所有用户，后面的数字就是文件句柄大小。大家可以根据个人业务来进行设置。</p><h5 id="4、进程局部性修改"><a href="#4、进程局部性修改" class="headerlink" title="4、进程局部性修改"></a>4、进程局部性修改</h5><pre><code>[root@server ~]#vim /etc/nginx/nginx.confuser  nginx;worker_processes  1;  error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;worker_rlimit_nofile 65535; #进程限制events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$http_user_agent&#39; &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &#39;                      &#39;&quot;$args&quot; &quot;$request_uri&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;     #tcp_nopush     on;     keepalive_timeout  65;     #gzip  on;     include /etc/nginx/conf.d/*.conf;}</code></pre><p>worker_rlimit_nofile 是在进程上面进行限制。</p><h5 id="5、cpu的亲和配置"><a href="#5、cpu的亲和配置" class="headerlink" title="5、cpu的亲和配置"></a>5、cpu的亲和配置</h5><p>cpu的亲和能够使nginx对于不同的work工作进程绑定到不同的cpu上面去。就能够减少在work间不断切换cpu，把进程通常不会在处理器之间频繁迁移，进程迁移的频率小，来减少性能损耗。nginx 亲和配置</p><p>查看物理cpu</p><pre><code>[root@server ~]#cat /proc/cpuinfo|grep &quot;physical id&quot;|sort |uniq|wc -l</code></pre><p>查看cpu核心数</p><pre><code>[root@server ~]#cat /proc/cpuinfo|grep &quot;cpu cores&quot;|uniq</code></pre><p>查看cpu使用率</p><pre><code>[root@server ~]#top  回车后按 1</code></pre><h5 id="6、配置worker-processes"><a href="#6、配置worker-processes" class="headerlink" title="6、配置worker_processes"></a>6、配置worker_processes</h5><pre><code>[root@server ~]#vim /etc/nginx/nginx.conf</code></pre><p>将刚才查看到自己cpu * cpu核心就是worker_processes</p><pre><code>worker_processes 2; #根据自己cpu核心数配置</code></pre><h5 id="7、cpu亲和配置"><a href="#7、cpu亲和配置" class="headerlink" title="7、cpu亲和配置"></a>7、cpu亲和配置</h5><p>假如小菜的配置是2cpu，每个cpu是8核。配置如下</p><pre><code>worker_processes 16;worker_cpu_affinity 1010101010101010 0101010101010101;</code></pre><p>配置完成后可以通过下面命令查看nginx进程配置在哪个核上</p><pre><code>[root@server ~]#ps -eo pid,args,psr |grep [n]ginx</code></pre><p>在nginx 1.9版本之后，就帮我们自动绑定了cpu;</p><pre><code>worker_cpu_affinity auto;</code></pre><h4 id="5、nginx通用配置优化"><a href="#5、nginx通用配置优化" class="headerlink" title="5、nginx通用配置优化"></a>5、nginx通用配置优化</h4><pre><code>[root@server ~]#vim /etc/nginx/nginx.conf#将nginx进程设置为普通用户，为了安全考虑user nginx; #当前启动的worker进程，官方建议是与系统核心数一直worker_processes 2;#方式一， 第一个work进程绑定第一个cpu核心，第二个work进程绑定到第二个cpu核心，依次内推 直到弟16个#wokrer_cpu_affinity 0000000000000000 0000000000000001 0000000000000010 0000000000000100 ... 1000000000000000#方式二，当 worker_processes 2 时，表明 第一work进程可以绑定第 2 4 6 8 10 12 14 16 核心，那么第二work进程就绑定 奇数核心#worker_cpu_affinity 1010101010101010 0101010101010101;#方式三，就是自动分配绑定worker_cpu_affinity auto;#日志配置成warnerror_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid;#针对 nginx 句柄的文件限制worker_rlimit_nofile 35535;#事件模型events {    #使用epoll内核模型    user epoll;    #每一个进程可以处理多少个连接，如果是多核可以将连接数调高 worker_processes * 1024    worker_connections 10240;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    charset utf-8;  #设置字符集    #设置日志输出格式，根据自己的情况设置    log_format  main  &#39;$http_user_agent&#39; &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &#39;                      &#39;&quot;$args&quot; &quot;$request_uri&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;   #对静态资源的处理比较有效    #tcp_nopush     on;   #如果做静态资源服务器可以打开    #tcp_nodeny     on;   #当nginx做动态的服务时可以选择打开    keepalive_timeout  65;     ########    #Gzip module    gzip  on;    #文件压缩默认可以打开    gzip_disable &quot;MSIE [1-6]\.&quot;; #对于有些浏览器不能识别压缩，需要过滤如ie6    gzip_http_version 1.1;    include /etc/nginx/conf.d/*.conf;}#查看 核心绑定的nginx work进程[root@server ~]#ps -eo pid,args,psr | grep [n]ginx</code></pre><h4 id="6、ab接口压力测试工具"><a href="#6、ab接口压力测试工具" class="headerlink" title="6、ab接口压力测试工具"></a>6、ab接口压力测试工具</h4><p>ab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。</p><pre><code># 安装工具[root@server ~]#yum install httpd-tools# 使用[root@server ~]#ab -n 2000 -c 2 http://127.0.0.1/index.html-n 总的请求数-c 并发数-k 是否开启长连接</code></pre><h5 id="1、参数选项"><a href="#1、参数选项" class="headerlink" title="1、参数选项"></a>1、参数选项</h5><pre><code>-n：即requests，用于指定压力测试总共的执行次数-c：即concurrency，用于指定的并发数-t：即timelimit，等待响应的最大时间(单位：秒)-b：即windowsize，TCP发送/接收的缓冲大小(单位：字节)-p：即postfile，发送POST请求时需要上传的文件，此外还必须设置-T参数-u：即putfile，发送PUT请求时需要上传的文件，此外还必须设置-T参数-T：即content-type，用于设置Content-Type请求头信息，例如：application/x-www-form-urlencoded，默认值为text/plain-v：即verbosity，指定打印帮助信息的冗余级别-w：以HTML表格形式打印结果-i：使用HEAD请求代替GET请求-x：插入字符串作为table标签的属性-y：插入字符串作为tr标签的属性-z：插入字符串作为td标签的属性-C：添加cookie信息，例如：&quot;Apache=1234&quot;(可以重复该参数选项以添加多个)-H：添加任意的请求头，例如：&quot;Accept-Encoding: gzip&quot;，请求头将会添加在现有的多个请求头之后(可以重复该参数选项以添加多个)-A：添加一个基本的网络认证信息，用户名和密码之间用英文冒号隔开-P：添加一个基本的代理认证信息，用户名和密码之间用英文冒号隔开-X：指定使用的和端口号，例如:&quot;126.10.10.3:88&quot;-V：打印版本号并退出-k：使用HTTP的KeepAlive特性-d：不显示百分比-S：不显示预估和警告信息-g：输出结果信息到gnuplot格式的文件中-e：输出结果信息到CSV格式的文件中-r：指定接收到错误信息时不退出程序-H：显示用法信息，其实就是ab -help</code></pre><h5 id="2、内容解释"><a href="#2、内容解释" class="headerlink" title="2、内容解释"></a>2、内容解释</h5><pre><code>Server Software:        nginx/1.10.2 (服务器软件名称及版本信息)Server Hostname:        192.168.1.106(服务器主机名)Server Port:            80 (服务器端口)Document Path:          /index1.html. (供测试的URL路径)Document Length:        3721 bytes (供测试的URL返回的文档大小)Concurrency Level:      1000 (并发数)Time taken for tests:   2.327 seconds (压力测试消耗的总时间)Complete requests:      5000 (的总次数)Failed requests:        688 (失败的请求数)Write errors:           0 (网络连接写入错误数)Total transferred:      17402975 bytes (传输的总数据量)HTML transferred:       16275725 bytes (HTML文档的总数据量)Requests per second:    2148.98 [#/sec] (mean) (平均每秒的请求数) 这个是非常重要的参数数值，服务器的吞吐量 Time per request:       465.338 [ms] (mean) (所有并发用户(这里是1000)都请求一次的平均时间)Time  request:          0.247 [ms] (mean, across all concurrent requests) (单个用户请求一次的平均时间)Transfer rate:          7304.41 [Kbytes/sec] received 每秒获取的数据长度 (传输速率，单位：KB/s)...Percentage of the requests served within a certain time (ms)  50%    347  ## 50%的请求在347ms内返回   66%    401  ## 60%的请求在401ms内返回   75%    431  80%    516  90%    600  95%    846  98%   1571  99%   1593 100%   1619 (longest request)</code></pre><h5 id="3、示例演示"><a href="#3、示例演示" class="headerlink" title="3、示例演示"></a>3、示例演示</h5><pre><code>[root@server ~]#ab -n 50 -c 20 http://walidream.com/sub_module</code></pre><p>输出内容</p><pre><code>Server Software:        nginx/1.14.1Server Hostname:        walidream.comServer Port:            80Document Path:          /sub_moduleDocument Length:        169 bytesConcurrency Level:      20Time taken for tests:   0.005 secondsComplete requests:      50Failed requests:        0Write errors:           0Non-2xx responses:      50Total transferred:      14900 bytesHTML transferred:       8450 bytesRequests per second:    9746.59 [#/sec] (mean)Time per request:       2.052 [ms] (mean)Time per request:       0.103 [ms] (mean, across all concurrent requests)Transfer rate:          2836.41 [Kbytes/sec] receivedConnection Times (ms)              min  mean[+/-sd] median   maxConnect:        0    0   0.1      0       1Processing:     1    1   0.3      1       2Waiting:        0    1   0.2      1       1Total:          1    2   0.3      2       2Percentage of the requests served within a certain time (ms)  50%      2  66%      2  75%      2  80%      2  90%      2  95%      2  98%      2  99%      2 100%      2 (longest request)</code></pre><h5 id="5、注意事项"><a href="#5、注意事项" class="headerlink" title="5、注意事项"></a>5、注意事项</h5><p>● 测试机与被测试机要分开</p><p>● 不要对线上的服务器做压力测试</p><p>● 观察测试工具ab所在机器，以及被测试的前端机的CPU、内存、网络等都不超过最高限度的75%</p><h5 id="6、ab性能指标"><a href="#6、ab性能指标" class="headerlink" title="6、ab性能指标"></a>6、ab性能指标</h5><h6 id="1、吞吐率（Requests-per-second）"><a href="#1、吞吐率（Requests-per-second）" class="headerlink" title="1、吞吐率（Requests per second）"></a>1、吞吐率（Requests per second）</h6><p>服务器并发处理能力的量化描述，单位是reqs/s，指的是在某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。记住：吞吐率是基于并发用户数的。这句话代表了两个含义：</p><pre><code>● 吞吐率和并发用户数相关● 不同的并发用户数下，吞吐率一般是不同的</code></pre><p>计算公式：总请求数/处理完成这些请求数所花费的时间，即</p><pre><code>Request per second=Complete requests/Time taken for tests</code></pre><p>必须要说明的是，这个数值表示当前机器的整体性能，值越大越好</p><h6 id="2、并发连接数（The-number-of-concurrent-connections）"><a href="#2、并发连接数（The-number-of-concurrent-connections）" class="headerlink" title="2、并发连接数（The number of concurrent connections）"></a>2、并发连接数（The number of concurrent connections）</h6><p>并发连接数指的是某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。</p><h6 id="3、并发用户数（Concurrency-Level）"><a href="#3、并发用户数（Concurrency-Level）" class="headerlink" title="3、并发用户数（Concurrency Level）"></a>3、并发用户数（Concurrency Level）</h6><p>要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。在HTTP/1.1下，IE7支持两个并发连接，IE8支持6个并发连接，FireFox3支持4个并发连接，所以相应的，我们的并发用户数就得除以这个基数。</p><h6 id="4-用户平均请求等待时间（Time-per-request）"><a href="#4-用户平均请求等待时间（Time-per-request）" class="headerlink" title="4.用户平均请求等待时间（Time per request）"></a>4.用户平均请求等待时间（Time per request）</h6><p>计算公式：处理完成所有请求数所花费的时间/（总请求数/并发用户数），即：</p><pre><code>Time per request=Time taken for tests/（Complete requests/Concurrency Level）</code></pre><h6 id="5-服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）"><a href="#5-服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）" class="headerlink" title="5.服务器平均请求等待时间（Time per request:across all concurrent requests）"></a>5.服务器平均请求等待时间（Time per request:across all concurrent requests）</h6><p>计算公式：处理完成所有请求数所花费的时间/总请求数，即：</p><pre><code>Time taken for/testsComplete requests</code></pre><p>可以看到，它是吞吐率的倒数。同时，它也等于用户平均请求等待时间/并发用户数，即</p><pre><code>Time per request/Concurrency Level</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zabbix邮箱报警设置</title>
      <link href="2019/07/05/jian-kong/zabbix-you-jian-bao-jing/"/>
      <url>2019/07/05/jian-kong/zabbix-you-jian-bao-jing/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="Zabbix-邮件报警"><a href="#Zabbix-邮件报警" class="headerlink" title="Zabbix 邮件报警"></a>Zabbix 邮件报警</h3><h4 id="前期准备工作："><a href="#前期准备工作：" class="headerlink" title="前期准备工作："></a>前期准备工作：</h4><p>电脑登录网易邮箱配置，把自己的授权码看一下，并写入配置文件</p><h5 id="server端安装配置邮件服务器"><a href="#server端安装配置邮件服务器" class="headerlink" title="server端安装配置邮件服务器"></a><strong>server端安装配置邮件服务器</strong></h5><pre class=" language-shell"><code class="language-shell">[root@master ~]# yum -y install mailx[root@master ~]# mailx -V12.5 7/5/10</code></pre><h5 id="配置公网邮箱信息：发邮件："><a href="#配置公网邮箱信息：发邮件：" class="headerlink" title="配置公网邮箱信息：发邮件："></a><strong>配置公网邮箱信息</strong>：发邮件：</h5><pre class=" language-shell"><code class="language-shell">[root@master ~]#  vim /etc/mail.rc    #追加以下内容set from=cyylog@163.com    #（邮箱地址） set smtp=smtp.163.com    #smtp服务器） 发邮件服务器 ---163默认set smtp-auth-user=cyylog@163.com    #(用户名) set smtp-auth-password=Password    #（邮箱密码）授权之后的密码set smtp-auth=login            #默认######    测试[root@master ~]# echo "test mail from zabbix.server.com" |mail -s "test mail" cyylog@163.com</code></pre><h6 id="然后163邮箱就会收到信息"><a href="#然后163邮箱就会收到信息" class="headerlink" title="然后163邮箱就会收到信息"></a>然后163邮箱就会收到信息</h6><p><img src="https://s1.ax1x.com/2020/05/23/Yv2C6g.png" alt="Yv2C6g.png"></p><h4 id="报警媒体的配置"><a href="#报警媒体的配置" class="headerlink" title="报警媒体的配置:"></a>报警媒体的配置:</h4><p>首先需要配置 Zabbix 的邮件功能。<br>点击 管理-&gt;报警媒介类型-&gt;创建媒体类型</p><p><img src="https://s1.ax1x.com/2020/05/23/YvWEWV.png" alt="YvWEWV.png"></p><p><strong>然后在页面中填入你的报警媒介类型信息,例如下图所示:</strong><br><strong>注：脚本名称任意，存放于<code>/usr/lib/zabbix/alertscripts</code> (生产上的测试服放这：<code>s /usr/local/zabbix/share/zabbix/alertscripts）</code></strong> </p><p>名称：sendmail //名称任意<br>类型：脚本<br>脚本名称：sendmail.sh<br>脚本参数： //一定要写，否则可能发送不成功<br>{ALERT.SENDTO} //照填，收件人变量<br>{ALERT.SUBJECT} //照填，邮件主题变量，变量值来源于‘动作’中的‘默认接收人’<br>{ALERT.MESSAGE} //照填，邮件正文变量，变量值来源于‘动作’中的‘默认信息’</p><p><strong>配置完成后,不要忘记点击存档,保存你的配置。</strong></p><p><img src="https://s1.ax1x.com/2020/05/23/YvWRmQ.png" alt="YvWRmQ.png"></p><h6 id="修改zabbix服务端配置文件＆编写脚本："><a href="#修改zabbix服务端配置文件＆编写脚本：" class="headerlink" title="修改zabbix服务端配置文件＆编写脚本："></a>修改zabbix服务端配置文件＆编写脚本：</h6><pre class=" language-shell"><code class="language-shell"># 查看指定脚本的存储路径:[root@master ~]# vim /etc/zabbix/zabbix_server.confAlertScriptsPath=/usr/lib/zabbix/alertscripts编写邮件脚本:[root@master alertscripts]# cd /usr/lib/zabbix/alertscripts[root@master alertscripts]# vim sendmail.sh #!/bin/sh #export.UTF-8 -----字符集可以删除掉#send mailmessages=echo $3 | tr '\r\n' '\n'subject=echo $2 | tr '\r\n' '\n'echo "${messages}" | mail -s "${subject}" $1 >>/tmp/mailx.log 2>&1修改权限：[root@master alertscripts]# chmod u+x sendmail.sh && chown zabbix.zabbix sendmail.sh</code></pre><p>创建的脚本名称要和定义的脚本名称一样</p><p><strong>修改admin用户的报警媒介：</strong><br>用户默认是没有设置报警媒介的，设置后就可以接收报警消息了。</p><p><img src="https://s1.ax1x.com/2020/05/23/YvIrM6.png" alt="YvIrM6.png"></p><p><img src="https://s1.ax1x.com/2020/05/23/YvoeQx.png" alt="YvoeQx.png"></p><h6 id="触发器的配置"><a href="#触发器的配置" class="headerlink" title="触发器的配置:"></a><strong>触发器的配置:</strong></h6><p>接下来,点击配置-&gt;主机</p><p>我们给 agent-19 这台主机增加一个触发器。点击 agent-19 这一行中的“触发器”,然后再点击创建触发器。<br>该页各配置项含义如下:<br>名称:填入触发器的名字<br>表达式:用于配置触发器的触发条件,点击添加按钮有条件选项。 —-键值<br>多重事件产生:如果选中,则问题如果持续多重的发生则每次都触发,否则只触发一次<br>点击表达式右侧的添加按钮:</p><p><img src="https://s1.ax1x.com/2020/05/23/YvT75Q.png" alt="YvT75Q.png"></p><p>再点击项目右侧的选择,选择我们之前配置过的“web.server.online.monitor”,并设置触发的阀值,如下图所示</p><p><img src="https://s1.ax1x.com/2020/05/23/YvTL2n.png" alt="YvTL2n.png"></p><p>Zabbix 会自动生成表达式。接下来根据情况选择事件的严重性。配置完毕后,点击存档保存。</p><p><img src="https://s1.ax1x.com/2020/05/23/YvTxbT.png" alt="YvTxbT.png"></p><p><strong>动作的配置</strong>:<br>点击:配置-&gt;动作-&gt;事件源下拉菜单中选择触发器-&gt;创建动作<br>可以在内容中使用 Zabbix 内置宏,邮件发出时会自动将宏替换成对应的值。 </p><p>名称：<br>任意写</p><p>默认接收人：</p><pre><code>故障级别：{TRIGGER.STATUS}。服务器：【{HOSTNAME1} 】 发生：{TRIGGER.NAME} 故障！ 注：默认接收人：相当于邮件的主题默认信息：邮件的主题告警主机：{HOSTNAME1} 告警时间：{EVENT.DATE} {EVENT.TIME}告警等级：{TRIGGER.SEVERITY} 告警信息：{TRIGGER.NAME}告警项目：{TRIGGER.KEY1} 问题详情：{ITEM.NAME}：{ITEM.VALUE}当前状态：{TRIGGER.STATUS}：{ITEM.VALUE1} 事件ID：{EVENT.ID}</code></pre><p>恢复邮件：<br>恢复主题：</p><pre><code>服务器：【{HOSTNAME1}】故障已恢复。故障原因：{TRIGGER.NAME} 恢复信息：恢复邮件的正文。当故障恢复正常后也发邮件通知一下。 </code></pre><p><img src="https://s1.ax1x.com/2020/05/23/Yv7iG9.png" alt="Yv7iG9.png"></p><p>点击:操作-&gt;编辑：</p><p><img src="https://s1.ax1x.com/2020/05/23/Yv7kx1.png" alt="Yv7kx1.png"></p><p>发送间隔：60秒<br>步骤：发送10次发送到：admin用户<br>仅使用：sendmail方式发送 —-脚本。 方式可以自行设置，根据实际工作要求</p><p><img src="https://s1.ax1x.com/2020/05/23/Yv7QGd.png" alt="Yv7QGd.png"></p><p>需要特别解释一下的是“步骤”部分的配置。所谓步骤是指报警可以有多个步骤,做不同的报警。例如,自从 1 到 3,就是指报警的步骤有三个。步骤持续时间就是一定时间后如果监控人员仍未响应报警就进入下一个报警步骤。<br>例如,发邮件给你报警,如果60 秒后你没响应,那就发 jabber 信息提醒你。如果 60 秒后还没响应,那就发短信给你。要是还没响应,就没有然后了。你可以形象的把它理解为 Zabbix 的一哭二闹三上吊。<br>到此,一个邮件报警功能就配置完毕了。如果你想立即看到结果,可以修改触发器的条件,将条件的阀值设置为 N&gt;0.0003。你马上就会收到 Zabbix 发来的报警邮件了。</p><h4 id="补充：邮件美化"><a href="#补充：邮件美化" class="headerlink" title="补充：邮件美化"></a>补充：邮件美化</h4><p>（修改默认信息）</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span>  <span class="token attr-name">bordercolor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>black<span class="token punctuation">"</span></span> <span class="token attr-name">cellspacing</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0px<span class="token punctuation">"</span></span> <span class="token attr-name">cellpadding</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4px<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>告警主机<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">bgcolor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#FF3333<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{HOSTNAME1}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>告警时间<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>{EVENT.DATE} {EVENT.TIME}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>告警等级<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>{TRIGGER.SEVERITY}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>告警信息<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>{TRIGGER.NAME}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>告警项目<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>{TRIGGER.KEY1}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>问题详情<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">bgcolor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#FF3333<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{ITEM.NAME}:<span class="token entity" title="&nbsp;">&amp;nbsp;</span>{ITEM.VALUE}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>当前状态<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>{TRIGGER.STATUS}:<span class="token entity" title="&nbsp;">&amp;nbsp;</span>{ITEM.VALUE1}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>事件ID<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>{EVENT.ID}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL部署之源码安装</title>
      <link href="2019/05/27/sql/mysql-bu-shu-zhi-yuan-ma-an-zhuang/"/>
      <url>2019/05/27/sql/mysql-bu-shu-zhi-yuan-ma-an-zhuang/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="所需要的依赖及安装MySQL的包"><a href="#所需要的依赖及安装MySQL的包" class="headerlink" title="所需要的依赖及安装MySQL的包"></a>所需要的依赖及安装MySQL的包</h4><pre class=" language-shell"><code class="language-shell"># yum -y update# yum -y groupinstall "Development Tools"# yum -y install gcc gcc-c++ ncurses ncurses-devel bison libgcrypt perl make cmake# wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-boost-5.7.24.tar.gz</code></pre><h4 id="在系统中添加运行mysqld进程的用户mysql"><a href="#在系统中添加运行mysqld进程的用户mysql" class="headerlink" title="在系统中添加运行mysqld进程的用户mysql"></a>在系统中添加运行mysqld进程的用户mysql</h4><pre class=" language-shell"><code class="language-shell">[root@mysql_source ~]# groupadd mysql[root@mysql_source ~]# useradd -M -g mysql -s /sbin/nologin mysql</code></pre><h4 id="在系统中添加自定义MySQL数据库目录及其他必要目录"><a href="#在系统中添加自定义MySQL数据库目录及其他必要目录" class="headerlink" title="在系统中添加自定义MySQL数据库目录及其他必要目录"></a>在系统中添加自定义MySQL数据库目录及其他必要目录</h4><pre class=" language-shell"><code class="language-shell">[root@mysql_source ~]# mkdir -p /usr/local/mysqld/{data,mysql,log,tmp}[root@mysql_source ~]# chown -R mysql:mysql /usr/local/mysqld/*</code></pre><h4 id="将mysql-boost-5-7-24-tar-gz解压到当前目录-并执行部署操作"><a href="#将mysql-boost-5-7-24-tar-gz解压到当前目录-并执行部署操作" class="headerlink" title="将mysql-boost-5.7.24.tar.gz解压到当前目录,并执行部署操作"></a>将mysql-boost-5.7.24.tar.gz解压到当前目录,并执行部署操作</h4><pre class=" language-shell"><code class="language-shell">[root@mysql_source ~]# tar xf mysql-boost-5.7.24.tar.gz[root@mysql_source ~]# cd mysql-5.7.24[root@mysql_source mysql-5.7.24]# $ cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysqld/mysql \-DMYSQL_DATADIR=/usr/local/mysqld/data \-DWITH_BOOST=/root/mysql-5.7.24/boost \-DDEFAULT_CHARSET=utf8......-- Configuring done-- Generating done-- Build files have been written to: /root/mysql-5.7.24[root@mysql_source mysql-5.7.24]# echo $?0[root@mysql_source mysql-5.7.24]# make -j `lscpu | awk 'NR==4{ print $2 }'`......[100%] Built target udf_example[root@mysql_source mysql-5.7.24]# echo $?0[root@mysql_source mysql-5.7.24]# make install......-- Installing: /usr/local/mysqld/mysql/support-files/mysql.server[root@mysql_source mysql-5.7.24]# echo $?0[root@mysql_source mysql-5.7.24]#Congratulations Complete!</code></pre><h4 id="初始化MySQL安装配置"><a href="#初始化MySQL安装配置" class="headerlink" title="初始化MySQL安装配置"></a>初始化MySQL安装配置</h4><h5 id="1-提升MySQL命令为系统级别命令"><a href="#1-提升MySQL命令为系统级别命令" class="headerlink" title="1.提升MySQL命令为系统级别命令"></a>1.提升MySQL命令为系统级别命令</h5><pre class=" language-shell"><code class="language-shell">[root@mysql_source ~]# echo "export PATH=$PATH:/usr/local/mysqld/mysql/bin" >>/etc/profile[root@mysql_source ~]# source /etc/profile</code></pre><h5 id="2-拷贝默认配置文件至-etc-my-cnf中"><a href="#2-拷贝默认配置文件至-etc-my-cnf中" class="headerlink" title="2.拷贝默认配置文件至/etc/my.cnf中"></a>2.拷贝默认配置文件至/etc/my.cnf中</h5><pre class=" language-shell"><code class="language-shell">[root@mysql_source mysql]# chown -R mysql.mysql /usr/local/mysqld/*[root@mysql_source ~]# cd /usr/local/mysqld/mysql/mysql-test/include[root@mysql_source include]# cp /etc/{my.cnf,my.cnf.bak}[root@mysql_source include]# cp default_mysqld.cnf /etc/my.cnfcp：是否覆盖"/etc/my.cnf"？ y[root@mysql_source include]# vim /etc/my.cnf[mysqld]basedir = /usr/local/mysqld/mysqldatadir = /usr/local/mysqld/datatmpdir = /usr/local/mysqld/tmpsocket = /usr/local/mysqld/tmp/mysql.sockpid_file = /usr/local/mysqld/tmp/mysqld.pidlog_error = /usr/local/mysqld/log/mysql_error.logslow_query_log_file = /usr/local/mysqld/log/slow_warn.logserver_id = 11user = mysqlport = 3306bind-address = 0.0.0.0character-set-server = utf8default_storage_engine = InnoDB</code></pre><h5 id="3-执行数据库服务初始化操作"><a href="#3-执行数据库服务初始化操作" class="headerlink" title="3.执行数据库服务初始化操作"></a>3.执行数据库服务初始化操作</h5><pre class=" language-shell"><code class="language-shell">[root@mysql_source mysql]# mysqld --defaults-file=/etc/my.cnf --initialize --user='mysql'[root@mysql_source mysql]#</code></pre><h5 id="4-启动mysqld服务"><a href="#4-启动mysqld服务" class="headerlink" title="4.启动mysqld服务"></a>4.启动mysqld服务</h5><pre class=" language-shell"><code class="language-shell">[root@mysql_source mysql]# mysqld_safe --defaults-file=/etc/my.cnf &[1] 257052018-12-28T09:19:35.334751Z mysqld_safe Logging to '/usr/local/mysqld/log/mysql_error.log'.2018-12-28T09:19:35.379829Z mysqld_safe Starting mysqld daemon with databases from /usr/local/mysqld/data</code></pre><h5 id="5-设置mysql-socket软链接到mysql命令指定的目录中"><a href="#5-设置mysql-socket软链接到mysql命令指定的目录中" class="headerlink" title="5.设置mysql.socket软链接到mysql命令指定的目录中"></a>5.设置mysql.socket软链接到mysql命令指定的目录中</h5><pre class=" language-shell"><code class="language-shell">[root@mysql_source ～]# ln -s /usr/local/mysqld/tmp/mysql.sock /tmp/mysql.sock</code></pre><p>6.配置mysqld服务的管理工具</p><pre class=" language-shell"><code class="language-shell">[root@mysql_source support-files]# cd /usr/local/mysqld/mysql/support-files[root@mysql_source support-files]# cp mysql.server /etc/init.d/mysqld[root@mysql_source support-files]# chkconfig --add mysqld[root@mysql_source support-files]# chkconfig mysqld on</code></pre><h4 id="登录数据库并进行更改密码"><a href="#登录数据库并进行更改密码" class="headerlink" title="登录数据库并进行更改密码"></a>登录数据库并进行更改密码</h4><pre class=" language-shell"><code class="language-shell">[root@mysql_source mysql]# grep "password" /usr/local/mysqld/log/mysql_error.log2018-12-28T09:18:34.214401Z 1 [Note] A temporary password is generated for root@localhost: ejhszb2:m3wJ[root@mysql_source tmp]# mysql -uroot -p"ejhszb2:m3wJ"mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.24-logCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql> alter user 'root'@'localhost' identified by "(Cyylog..1228)";平常中常用的MySQL部署参数:<参考使用>    -DCMAKE_INSTALL_PREFIX=/usr/local/mysqld/mysql \    -DMYSQL_DATADIR=/usr/local/mysqld/data \    -DDOWNLOAD_BOOST=1 \    -DWITH_BOOST=/root/mysql-5.7.24/boost \    -DSYSCONFDIR=/etc \    -DWITH_INNOBASE_STORAGE_ENGINE=1 \    -DWITH_PARTITION_STORAGE_ENGINE=1 \    -DWITH_FEDERATED_STORAGE_ENGINE=1 \    -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \    -DWITH_MYISAM_STORAGE_ENGINE=1 \    -DENABLED_LOCAL_INFILE=1 \    -DENABLE_DTRACE=0 \    -DDEFAULT_CHARSET=utf8 \    -DDEFAULT_COLLATION=utf8_general_ci \    -DWITH_EMBEDDED_SERVER=1</code></pre><h4 id="绕过验证密码登录-修改密码"><a href="#绕过验证密码登录-修改密码" class="headerlink" title="绕过验证密码登录 修改密码"></a>绕过验证密码登录 修改密码</h4><pre class=" language-shell"><code class="language-shell">[root@mysql ~]# vim /etc/my.cnf[mysqld]skip-grant-tables=1[root@mysql ~]# systemctl restart mysqld[root@mysql ~]# mysql -urootWelcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.24 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql> alter user 'root'@'localhost' identified by "(Cyylog..1229)";ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statementmysql> show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.00 sec)mysql> use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql> show tables;..................| user                      |+---------------------------+31 rows in set (0.00 sec)mysql> select User,Host,authentication_string from user;+---------------+-----------+-------------------------------------------+| User          | Host      | authentication_string                     |+---------------+-----------+-------------------------------------------+| root          | localhost | *C4571A0C807D96143700250EC4BA41780025A97F || mysql.session | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || mysql.sys     | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |+---------------+-----------+-------------------------------------------+3 rows in set (0.00 sec)mysql> update user set authentication_string=password('(Cyylog@@1229)') where user='root';Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 1[root@mysql ~]# vim /etc/my.cnf[mysqld]#skip-grant-tables=1[root@mysql ~]# systemctl restart mysqld[root@mysql ~]# mysql -uroot -p"(Cyylog@@1229)"mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.24 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql></code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx平滑升级</title>
      <link href="2019/04/27/linux/nginx/nginx-ping-hua-sheng-ji/"/>
      <url>2019/04/27/linux/nginx/nginx-ping-hua-sheng-ji/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h5 id="Nginx-平滑升级"><a href="#Nginx-平滑升级" class="headerlink" title="Nginx 平滑升级"></a>Nginx 平滑升级</h5><h6 id="1、查看现有的-nginx-编译参数"><a href="#1、查看现有的-nginx-编译参数" class="headerlink" title="1、查看现有的 nginx 编译参数"></a>1、查看现有的 nginx 编译参数</h6><pre class=" language-shell"><code class="language-shell">[root@web ~]#/usr/local/nginx/sbin/nginx -V</code></pre><p>按照原来的编译参数安装 nginx 的方法进行安装，<strong>只需要到 make，千万不要 make install</strong></p><h6 id="2、编译新的-nginx-源码包"><a href="#2、编译新的-nginx-源码包" class="headerlink" title="2、编译新的 nginx 源码包"></a>2、编译新的 nginx 源码包</h6><p>编译新Nginx源码，安装路径需与旧版一致 (详细过程可参见：Nginx编译安装与配置使用)</p><pre class=" language-shell"><code class="language-shell">[root@web ~]#./configure --prefix=/usr/local/nginx-1.14.0 --user=www --group=www --with-http_ssl_module --with-openssl=/path/to/openssl_src[root@web ~]#make</code></pre><h6 id="3、备份原-nginx-二进制文件"><a href="#3、备份原-nginx-二进制文件" class="headerlink" title="3、备份原 nginx 二进制文件"></a>3、备份原 nginx 二进制文件</h6><p>备份二进制文件和 nginx 的配置文件（期间nginx不会停止服务）</p><pre class=" language-shell"><code class="language-shell">[root@web ~]#mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx_$(date +%F)</code></pre><p>4、复制新的nginx二进制文件，进入新的nginx源码包</p><pre class=" language-shell"><code class="language-shell">[root@web ~]#cp /usr/local/nginx-1.14.0/objs/nginx /usr/local/nginx/sbin/</code></pre><p>5、测试新版本的nginx是否正常</p><pre class=" language-shell"><code class="language-shell">[root@web ~]#/usr/local/nginx/sbin/nginx -t</code></pre><p>6、给nginx发送平滑迁移信号（若不清楚pid路径，请查看nginx配置文件）</p><pre class=" language-shell"><code class="language-shell">[root@web ~]#kill -USR2 cat /var/run/nginx.pid</code></pre><p>7、查看nginx pid，会出现一个nginx.pid.oldbin</p><pre class=" language-shell"><code class="language-shell">[root@web ~]#ll /var/run/nginx.pid*</code></pre><p>8、从容关闭旧的Nginx进程</p><pre class=" language-shell"><code class="language-shell">[root@web ~]#kill -WINCH cat /var/run/nginx.pid.oldbin</code></pre><p>9、此时不重载配置启动旧的工作进程</p><pre class=" language-shell"><code class="language-shell">[root@web ~]#kill -HUP cat /var/run/nginx.pid.oldbin</code></pre><p>10、结束工作进程，完成此次升级</p><pre class=" language-shell"><code class="language-shell">[root@web ~]#kill -QUIT cat /var/run/nginx.pid.oldbin</code></pre><p>11、验证Nginx是否升级成功</p><pre class=" language-shell"><code class="language-shell">[root@web ~]#usr/local/nginx/sbin/nginx -V</code></pre><h5 id="升级实战"><a href="#升级实战" class="headerlink" title="升级实战"></a>升级实战</h5><h6 id="1、安装配置1-6版本的-nginx"><a href="#1、安装配置1-6版本的-nginx" class="headerlink" title="1、安装配置1.6版本的 nginx"></a>1、安装配置1.6版本的 nginx</h6><pre class=" language-shell"><code class="language-shell">[root@web ~]# yum install -y gcc gcc-c++ pcre-devel openssl-devel zlib-devel[root@web ~]# tar zxvf nginx-1.6.0.tar.gz -C /usr/src/[root@web ~]# cd /usr/src/nginx-1.6.0/[root@web nginx-1.6.0]# ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_stub_status_module[root@web nginx-1.6.0]# make [root@web nginx-1.6.0]# make install[root@web nginx-1.6.0]# ln -s /usr/local/nginx/sbin/* /usr/sbin/[root@web nginx-1.6.0]# useradd -M -s /sbin/nologin nginx [root@web nginx-1.6.0]# nginx [root@web nginx-1.6.0]# netstat -anput | grep nginx tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 19008/nginx: master</code></pre><h6 id="2、查看-nginx-版本"><a href="#2、查看-nginx-版本" class="headerlink" title="2、查看 nginx 版本"></a>2、查看 nginx 版本</h6><pre class=" language-shell"><code class="language-shell">[root@web nginx-1.6.0]# nginx -vnginx version: nginx/1.6.0</code></pre><h6 id="3、查看-nginx-现有安装的模块"><a href="#3、查看-nginx-现有安装的模块" class="headerlink" title="3、查看 nginx 现有安装的模块"></a>3、查看 nginx 现有安装的模块</h6><pre class=" language-shell"><code class="language-shell">[root@web nginx-1.6.0]# nginx -Vnginx version: nginx/1.6.0built by gcc 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) configure arguments: --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_stub_status_module</code></pre><h6 id="4、访问验证"><a href="#4、访问验证" class="headerlink" title="4、访问验证"></a>4、访问验证</h6><pre class=" language-shell"><code class="language-shell">[root@web nginx-1.6.0]# echo "nginx1.6.0" > /usr/local/nginx/html/index.html[root@web nginx-1.6.0]# elinks 192.168.20.167</code></pre><p><a href="https://imgchr.com/i/GFh7KH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/28/GFh7KH.md.png" alt="GFh7KH.md.png"></a></p><h6 id="5、升级-nginx"><a href="#5、升级-nginx" class="headerlink" title="5、升级 nginx"></a>5、升级 nginx</h6><p>将 nginx 版本进行升级 并在不影响业务的情况下添加 SSL 和 pcre 模块</p><pre class=" language-shell"><code class="language-shell">[root@web ~]# tar zxvf nginx-1.11.2.tar.gz -C /usr/src/[root@web ~]# cd /usr/src/nginx-1.11.2/[root@web nginx-1.11.2]# ./configure --prefix=/usr/local/nginx --user=nginx --group=ngiinx --with-http_stub_status_module --with-http_ssl_module --with-pcre[root@web nginx-1.11.2]# make[root@web nginx-1.11.2]# cd[root@web ~]# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx_old [root@web ~]# cp /usr/src/nginx-1.11.2/objs/nginx /usr/local/nginx/sbin/[root@web ~]# mv /usr/local/nginx/conf/nginx.conf /usr/local/nginx/conf/nginx.conf.old[root@Centos ~]# cp /usr/src/nginx-1.11.2/conf/nginx.conf /usr/local/nginx/conf/nginx.conf[root@web ~]# kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`[root@web ~]# ls /usr/local/nginx/logs/access.log error.log nginx.pid[root@web ~]# ps aux | grep nginx root 19008 0.0 0.0 24324 944 ? Ss 14:07 0:00 nginx: master process nginxnginx 19009 0.0 0.1 26832 1744 ? S 14:07 0:00 nginx: worker processroot 53194 0.0 0.0 112660 976 pts/0 R+ 14:36 0:00 grep --color=auto ngin</code></pre><h6 id="6、验证-nginx-是否升级成功"><a href="#6、验证-nginx-是否升级成功" class="headerlink" title="6、验证 nginx 是否升级成功"></a>6、验证 nginx 是否升级成功</h6><p><img src="https://s1.ax1x.com/2020/03/28/GFhgbR.png" alt="GFhgbR.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka入门</title>
      <link href="2019/04/26/sql/kafka-ru-men/"/>
      <url>2019/04/26/sql/kafka-ru-men/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="KAFKA-消息中间件"><a href="#KAFKA-消息中间件" class="headerlink" title="KAFKA 消息中间件"></a>KAFKA 消息中间件</h1><h2 id="1、认识kafka"><a href="#1、认识kafka" class="headerlink" title="1、认识kafka"></a><strong>1、认识kafka</strong></h2><h3 id="1-1-kafka简介"><a href="#1-1-kafka简介" class="headerlink" title="1.1 kafka简介"></a><strong>1.1 kafka简介</strong></h3><p>Kafka 是一个分布式流媒体平台</p><p>kafka官网：<a href="http://kafka.apache.org/" target="_blank" rel="noopener">http://kafka.apache.org/</a></p><p>（1）流媒体平台有三个关键功能：</p><ul><li><strong>发布和订阅记录流</strong>，类似于消息队列或企业消息传递系统。</li><li>以<strong>容错的持久方式存储记录流</strong>。</li><li>记录发生时处理流。</li></ul><p>（2）Kafka通常用于两大类应用：</p><ul><li>构建可在<strong>系统或应用程序之间</strong>可靠获取数据的实时流数据管道</li><li>构建转换或响应数据流的实时流应用程序</li></ul><p>要了解Kafka如何做这些事情，让我们深入探讨Kafka的能力。</p><p>（3）首先是几个概念：</p><ul><li>Kafka作为一个集群运行在一个或多个可跨多个<strong>数据中心的服务器</strong>上。</li><li>Kafka集群以称为 <strong>topics主题</strong> 的类别存储记录流。</li><li>每条记录都包含<strong>一个键，一个值和一个时间戳</strong>。</li></ul><p>（4）Kafka有四个核心API：</p><ul><li><strong>Producer API（生产者API）</strong>允许应用程序<strong>发布</strong>记录流至一个或多个kafka的<strong>topics（主题）</strong>。</li><li><strong>Consumer API（消费者API）</strong>允许应用程序<strong>订阅一个或多个topics（主题）</strong>，并处理所产生的对他们记录的数据流。</li><li><strong>Streams API（流API）</strong>允许应用程序充当<strong>流处理器</strong>，从一个或多个<strong>topics（主题）</strong>消耗的输入流，并产生一个输出流至一个或多个输出的topics（主题），<strong>有效地变换所述输入流，以输出流</strong>。</li><li><strong>Connector API（连接器API）</strong>允许构建和运行kafka <strong>topics（主题）连接到现有的应用程序或数据系统中重用生产者或消费者</strong>。例如，关系数据库的连接器可能捕获对表的每个更改。</li></ul><p><img src="https://s1.ax1x.com/2020/04/26/J632xH.png" alt="J632xH.png"></p><p>　　在Kafka中，<strong>客户端和服务器之间的通信</strong>是通过简单，高性能，语言无关的<strong>TCP协议</strong>完成的。此协议已版本化并保持与旧版本的向后兼容性。Kafka提供Java客户端，但客户端有多种语言版本。</p><h3 id="1-2-Topics主题-和-partitions分区"><a href="#1-2-Topics主题-和-partitions分区" class="headerlink" title="1.2 Topics主题 和 partitions分区"></a><strong>1.2 Topics主题 和 partitions分区</strong></h3><p>我们首先深入了解 Kafka 为记录流提供的核心抽象 - 主题topics</p><p>　　<strong>一个Topic可以认为是一类消息，每个topic将被分成多个partition(区)</strong>,每个partition在存储层面是append log文件</p><p>　　<strong>主题是发布记录的类别或订阅源名称</strong>。Kafka的主题总是多用户; 也就是说，一个主题可以有零个，一个或多个消费者订阅写入它的数据。</p><p>　　对于<strong>每个主题</strong>，Kafka群集都维护一个如下所示的<strong>分区</strong>日志：</p><p><img src="https://s1.ax1x.com/2020/04/26/J63fsA.png" alt="J63fsA.png"></p><p>　　<strong>每个分区都是一个有序的，不可变的记录序列</strong>，不断附加到结构化的提交日志中。分区中的记录每个都分配了<strong>一个称为偏移的顺序ID号</strong>，它唯一地标识分区中的每个记录。</p><p>　　<strong>Kafka集群持久保存所有已发布的记录 - 无论是否已使用 - 使用可配置的保留期</strong>。例如，如果保留策略设置为两天，则在发布记录后的两天内，它可供使用，之后将被丢弃以释放空间。<strong>Kafka的性能在数据大小方面实际上是恒定的，因此长时间存储数据不是问题。</strong></p><p><img src="https://s1.ax1x.com/2020/04/26/J63IdP.png" alt="J63IdP.png"></p><p>　　实际上，基<strong>于每个消费者保留的唯一元数据是该消费者在日志中的偏移或位置</strong>。这种偏移由消费者控制：通常消费者在读取记录时会线性地提高其偏移量，但事实上，由于该位置由消费者控制，因此它可以按照自己喜欢的任何顺序消费记录。例如，消费者可以重置为较旧的偏移量来重新处理过去的数据，或者跳到最近的记录并从“现在”开始消费。</p><p>　　这些功能组合意味着Kafka 消费者consumers 非常cheap - 他们可以来来往往对集群或其他消费者没有太大影响。例如，您可以使用我们的命令行工具“tail”任何主题的内容，而无需更改任何现有使用者所消耗的内容。</p><p>　　<strong>日志中的分区有多种用途</strong>。首先，它们允许日志扩展到超出适合单个服务器的大小。每个单独的分区必须适合托管它的服务器，但<strong>主题可能有许多分区</strong>，因此它可以处理任意数量的数据。其次，它们充当了并行性的单位 - 更多的是它。</p><h3 id="1-3-Distribution-分配"><a href="#1-3-Distribution-分配" class="headerlink" title="1.3 Distribution 分配"></a><strong>1.3 Distribution</strong> <strong>分配</strong></h3><p>　　一个Topic的多个partitions,被分布在kafka集群中的多个server上;每个server(kafka实例)负责partitions中消息的读写操作;此外kafka还可以配置partitions需要备份的个数(replicas),每个partition将会被备份到多台机器上,以提高可用性.</p><p>　　基于replicated方案,那么就意味着需要对多个备份进行调度;每个partition都有一个server为”leader”;leader负责所有的读写操作,如果leader失效,那么将会有其他follower来接管(成为新的leader);follower只是单调的和leader跟进,同步消息即可..由此可见作为leader的server承载了全部的请求压力,因此从集群的整体考虑,有多少个partitions就意味着有多少个”leader”,kafka会将”leader”均衡的分散在每个实例上,来确保整体的性能稳定。</p><h3 id="1-4-Producers生产者-和-Consumers消费者"><a href="#1-4-Producers生产者-和-Consumers消费者" class="headerlink" title="1.4 Producers生产者 和 Consumers消费者"></a><strong>1.4 Producers生产者 和 Consumers消费者</strong></h3><h4 id="1-4-1-Producers生产者"><a href="#1-4-1-Producers生产者" class="headerlink" title="1.4.1 Producers生产者"></a><strong>1.4.1 Producers生产者</strong></h4><p>　　Producers 将数据<strong>发布到指定的topics 主题</strong>。同时Producer 也能决定将此消息归属于哪个partition;比如基于”round-robin”方式或者通过其他的一些算法等。</p><h4 id="1-4-2-Consumers"><a href="#1-4-2-Consumers" class="headerlink" title="1.4.2 Consumers"></a><strong>1.4.2</strong> <strong>Consumers</strong></h4><ul><li>本质上kafka只支持Topic.<strong>每个consumer属于一个consumer group</strong>;反过来说,每个group中可以有多个consumer.发送到Topic的消息,只会<strong>被订阅此Topic的每个group中的一个consumer消费</strong>。</li><li>如果所有使用者实例具有相同的使用者组，则记录将有效地在使用者实例上进行<strong>负载平衡</strong>。</li><li>如果所有消费者实例具有不同的消费者组，则每个记录将<strong>广播到所有消费者进程</strong>。</li></ul><p><img src="https://s1.ax1x.com/2020/04/26/J63oIf.png" alt="J63oIf.png"></p><p>　　分析：两个服务器Kafka群集，托管四个分区（P0-P3），包含两个使用者组。消费者组A有两个消费者实例，B组有四个消费者实例。</p><p>　　在Kafka中实现消费consumption 的方式是通过在消费者实例上划分日志中的<strong>分区</strong>，以便每个实例在任何时间点都是分配的“公平份额”的独占消费者。维护组中成员资格的过程由Kafka协议动态处理。如果新实例加入该组，他们将从该组的其他成员接管一些分区; 如果实例死亡，其分区将分发给其余实例。</p><p>　　<strong>Kafka仅提供分区内记录的总订单</strong>，而不是主题中不同分区之间的记录。对于大多数应用程序而言，按分区排序与按键分区数据的能力相结合就足够了。但是，如果您需要对记录进行总订单，则可以使用仅包含一个分区的主题来实现，但这将意味着每个使用者组只有一个使用者进程。</p><h3 id="1-5-Consumers-kafka确保"><a href="#1-5-Consumers-kafka确保" class="headerlink" title="1.5 Consumers kafka确保"></a><strong>1.5 Consumers kafka确保</strong></h3><ul><li><strong>发送到partitions中的消息将会按照它接收的顺序追加到日志中</strong>。也就是说，如果记录M1由与记录M2相同的生成者发送，并且首先发送M1，则M1将具有比M2更低的偏移并且在日志中更早出现。</li><li>消费者实例按照它们存储在日志中的顺序查看记录。对于消费者而言,<strong>它们消费消息的顺序和日志中消息顺序一致</strong>。</li><li>如果Topic的”replicationfactor”为N,那么允许N-1个kafka实例失效，我们将容忍最多N-1个服务器故障，而不会丢失任何提交到日志的记录。</li></ul><h3 id="1-6-kafka-作为消息系统"><a href="#1-6-kafka-作为消息系统" class="headerlink" title="1.6 kafka**作为消息系统**"></a><strong>1.6 kafka**</strong>作为消息系统**</h3><p>Kafka的流概念与传统的企业邮件系统相比如何？</p><p>（1）传统消息系统</p><p>　　消息传统上有两种模型：queuing排队 and publish-subscribe发布 - 订阅。在队列中，消费者池可以从服务器读取并且每个记录转到其中一个; 在发布 - 订阅中，记录被广播给所有消费者。这两种模型中的每一种都有优点和缺点。排队的优势在于它允许您在多个消费者实例上划分数据处理，从而可以扩展您的处理。不幸的是，一旦一个进程读取它已经消失的数据，队列就不是多用户。发布 - 订阅允许您将数据广播到多个进程，但由于每条消息都发送给每个订阅者，因此无法进行扩展处理。</p><p>kafka的消费者群体概念概括了这两个概念。与队列一样，使用者组允许您将处理划分为一组进程（使用者组的成员）。与发布 - 订阅一样，Kafka允许您向多个消费者组广播消息。</p><p>（2）kafka 的优势</p><p>　　<strong>Kafka模型的优势在于每个主题都具有这些属性</strong> - 它可以扩展处理并且也是多用户 - 不需要选择其中一个。</p><p>　　与传统的消息系统相比，Kafka具有<strong>更强的订购保证</strong>。</p><p>　　传统队列在服务器上按顺序保留记录，如果多个消费者从队列中消耗，则服务器按照存储顺序分发记录。但是，虽然服务器按顺序分发记录，但是记录是异步传递给消费者的，因此它们可能会在不同的消费者处出现故障。这实际上意味着在存在并行消耗的情况下丢失记录的顺序。消息传递系统通常通过具有“独占消费者”概念来解决这个问题，该概念只允许一个进程从队列中消耗，但当然这意味着处理中没有并行性。</p><p>　　<strong>kafka做得更好。通过在主题中具有并行性概念 - 分区 - ，Kafka能够在消费者流程池中提供订购保证和负载平衡</strong>。这是通过将主题中的分区分配给使用者组中的使用者来实现的，以便每个分区仅由该组中的一个使用者使用。通过这样做，我们确保使用者是该分区的唯一读者并按顺序使用数据。由于有许多分区，这仍然可以平衡许多消费者实例的负载。但请注意，消费者组中的消费者实例不能超过分区。</p><h3 id="1-7-kafka作为存储系统"><a href="#1-7-kafka作为存储系统" class="headerlink" title="1.7 kafka作为存储系统"></a><strong>1.7 kafka作为存储系统</strong></h3><ul><li>任何允许发布与消费消息分离的消息的消息队列实际上充当了正在进行的消息的存储系统。Kafka的不同之处在于它是<strong>一个非常好的存储系统</strong>。</li><li><strong>写入Kafka的数据将写入磁盘并进行复制以实现容错</strong>。Kafka允许生产者等待确认，以便在完全复制之前写入不被认为是完整的，并且即使写入的服务器失败也保证写入仍然存在。</li><li><strong>磁盘结构Kafka很好地使用了规模</strong> - 无论服务器上有50 KB还是50 TB的持久数据，Kafka都会执行相同的操作。</li><li>由于认真对待存储并允许客户端控制其读取位置，您可以将<strong>Kafka视为一种专用于高性能，低延迟提交日志存储，复制和传播的专用分布式文件系统</strong>。</li><li>有关Kafka的提交日志存储和复制设计的详细信息，请阅读<a href="https://kafka.apache.org/documentation/#design" target="_blank" rel="noopener">此</a>页面。</li></ul><h3 id="1-8-kafka用于流处理"><a href="#1-8-kafka用于流处理" class="headerlink" title="1.8 kafka用于流处理"></a><strong>1.8 kafka用于流处理</strong></h3><ul><li>仅仅读取，写入和存储数据流是不够的，目的是实现<strong>流的实时处理</strong>。</li><li>在Kafka中，流处理器是指<strong>从输入主题获取连续数据流，对此输入执行某些处理以及生成连续数据流以输出主题的任何内容</strong>。</li><li>例如，零售应用程序可能会接收销售和发货的输入流，并输出重新排序流和根据此数据计算的价格调整。</li><li>可以使用生产者和消费者API直接进行简单处理。但是，对于更复杂的转换，Kafka提供了完全集成的Streams API。这允许构建执行非平凡处理的应用程序，这些应用程序可以计算流的聚合或将流连接在一起。</li><li>此工具有助于解决此类应用程序面临的难题：处理无序数据，在代码更改时重新处理输入，执行有状态计算等。</li><li>流API构建在Kafka提供的核心原语上：它使用生产者和消费者API进行输入，使用Kafka进行有状态存储，并在流处理器实例之间使用相同的组机制来实现容错。</li></ul><h2 id="2、kafka使用场景"><a href="#2、kafka使用场景" class="headerlink" title="2、kafka使用场景"></a><strong>2、kafka使用场景</strong></h2><h3 id="2-1-消息Messaging"><a href="#2-1-消息Messaging" class="headerlink" title="2.1 消息Messaging"></a><strong>2.1 消息Messaging</strong></h3><p>　　<strong>Kafka可以替代更传统的消息代理</strong>。消息代理的使用有多种原因（将处理与数据生成器分离，缓冲未处理的消息等）。<strong>与大多数消息传递系统相比，Kafka具有更好的吞吐量，内置分区，复制和容错功能</strong>，这使其成为大规模消息处理应用程序的理想解决方案。</p><p>　　根据经验，消息传递的使用通常相对较低，但可能需要较低的端到端延迟，并且通常取决于Kafka提供的强大的耐用性保证。</p><p>　　在这个领域，Kafka可与传统的消息传递系统（如<a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ</a>或 <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>）相媲美。</p><h3 id="2-2-网站活动跟踪"><a href="#2-2-网站活动跟踪" class="headerlink" title="2.2 网站活动跟踪"></a><strong>2.2 网站活动跟踪</strong></h3><p>　　Kafka的原始用例是能够将用户活动跟踪管道重建为一组实时发布 - 订阅源。这意味着站点活动（页面查看，搜索或用户可能采取的其他操作）将发布到中心主题，每个活动类型包含一个主题。这些源可用于订购一系列用例，<strong>包括实时处理，实时监控以及加载到Hadoop或离线数据仓库系统以进行脱机处理和报告</strong>。</p><p>　　活动跟踪通常非常高，因为为每个用户页面视图生成了许多活动消息。</p><h3 id="2-3-度量Metrics"><a href="#2-3-度量Metrics" class="headerlink" title="2.3 度量Metrics"></a><strong>2.3 度量Metrics</strong></h3><p>　　<strong>Kafka通常用于运营监控数据</strong>。这涉及从分布式应用程序聚合统计信息以生成操作数据的集中式提要。</p><h3 id="2-4-日志聚合"><a href="#2-4-日志聚合" class="headerlink" title="2.4 日志聚合"></a><strong>2.4 日志聚合</strong></h3><p>　　许多人使用Kafka作为日志聚合解决方案的替代品。日志聚合通常从服务器收集物理日志文件，并将它们放在中央位置（可能是文件服务器或HDFS）进行处理。<strong>Kafka抽象出文件的细节，并将日志或事件数据作为消息流更清晰地抽象出来</strong>。这允许更低延迟的处理并更容易支持多个数据源和分布式数据消耗。与Scribe或Flume等以日志为中心的系统相比，<strong>Kafka提供了同样出色的性能，由于复制而具有更强的耐用性保证，以及更低的端到端延迟。</strong></p><h3 id="2-5-流处理"><a href="#2-5-流处理" class="headerlink" title="2.5 流处理"></a><strong>2.5 流处理</strong></h3><p>　　许多Kafka用户在处理由多个阶段组成的管道时处理数据，<strong>其中原始输入数据从Kafka主题中消费，然后聚合，丰富或以其他方式转换为新主题以供进一步消费或后续处理</strong>。</p><p>　　例如，用于推荐新闻文章的处理管道可以从RSS订阅源抓取文章内容并将其发布到“文章”主题; 进一步处理可能会对此内容进行规范化或重复数据删除，并将已清理的文章内容发布到新主题; 最终处理阶段可能会尝试向用户推荐此内容。此类处理管道基于各个主题创建实时数据流的图形。从0.10.0.0开始，这是一个轻量级但功能强大的流处理库，名为<a href="http://kafka.apache.org/documentation/streams" target="_blank" rel="noopener">Kafka Streams</a> 在Apache Kafka中可用于执行如上所述的此类数据处理。除了Kafka Streams之外，其他开源流处理工具包括<a href="https://storm.apache.org/" target="_blank" rel="noopener">Apache Storm</a>和 <a href="http://samza.apache.org/" target="_blank" rel="noopener">Apache Samza</a>。</p><h3 id="2-6-Event-Sourcing"><a href="#2-6-Event-Sourcing" class="headerlink" title="2.6 Event Sourcing"></a><strong>2.6 Event Sourcing</strong></h3><p>　　Event Sourcing是一种应用程序设计风格，其中状态更改记录为按时间排序的记录序列。Kafka对非常大的存储日志数据的支持使其成为以这种风格构建的应用程序的出色后端。</p><h3 id="2-7-提交日志"><a href="#2-7-提交日志" class="headerlink" title="2.7 提交日志"></a><strong>2.7 提交日志</strong></h3><p>　　<strong>Kafka可以作为分布式系统的一种外部提交日志</strong>。该日志有助于在节点之间复制数据，并充当故障节点恢复其数据的重新同步机制。Kafka中的日志压缩功能有助于支持此用法。在这种用法中，Kafka类似于<a href="https://bookkeeper.apache.org/" target="_blank" rel="noopener">Apache BookKeeper</a>项目。</p><h2 id="3、kafka安装"><a href="#3、kafka安装" class="headerlink" title="3、kafka安装"></a><strong>3、kafka安装</strong></h2><h3 id="3-1-下载安装"><a href="#3-1-下载安装" class="headerlink" title="3.1 下载安装"></a><strong>3.1 下载安装</strong></h3><p>到官网<a href="http://kafka.apache.org/downloads.html" target="_blank" rel="noopener">http://kafka.apache.org/downloads.html</a>下载想要的版本；我这里下载的最新稳定版2.1.0</p><p>注：由于Kafka控制台脚本对于基于Unix和Windows的平台是不同的，因此在Windows平台上使用bin\windows\ 而不是bin/ 将脚本扩展名更改为.bat。</p><pre><code>[root@along ~]# wget http://mirrors.shu.edu.cn/apache/kafka/2.1.0/kafka_2.11-2.1.0.tgz[root@along ~]# tar -C /data/ -xvf kafka_2.11-2.1.0.tgz[root@along ~]# cd /data/kafka_2.11-2.1.0/</code></pre><p>　　</p><h3 id="3-2-配置启动zookeeper"><a href="#3-2-配置启动zookeeper" class="headerlink" title="3.2 配置启动zookeeper"></a><strong>3.2 配置启动zookeeper</strong></h3><p>　　kafka正常运行，必须配置zookeeper，否则无论是kafka集群还是客户端的生存者和消费者都无法正常的工作的；所以需要配置启动zookeeper服务。</p><p>（1）zookeeper需要java环境</p><pre><code>[root@along ~]# yum -y install java-1.8.0</code></pre><p>（2）这里kafka下载包已经包括zookeeper服务，所以只需修改配置文件，启动即可。</p><p>如果需要下载指定zookeeper版本；可以单独去zookeeper官网<a href="http://mirrors.shu.edu.cn/apache/zookeeper/" target="_blank" rel="noopener">http://mirrors.shu.edu.cn/apache/zookeeper/</a>下载指定版本。</p><pre><code>[root@along ~]# cd /data/kafka_2.11-2.1.0/[root@along kafka_2.11-2.1.0]# grep &quot;^[^#]&quot; config/zookeeper.properties dataDir=/tmp/zookeeper        #数据存储目录clientPort=2181               #zookeeper端口maxClientCnxns=0</code></pre><p>注：可自行添加修改zookeeper配置</p><h3 id="3-3-配置kafka"><a href="#3-3-配置kafka" class="headerlink" title="3.3 配置kafka"></a><strong>3.3 配置kafka</strong></h3><p>（1）修改配置文件</p><pre><code>[root@along kafka_2.11-2.1.0]# grep &quot;^[^#]&quot; config/server.properties broker.id=0 listeners=PLAINTEXT://localhost:9092num.network.threads=3 num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=/tmp/kafka-logsnum.partitions=1num.recovery.threads.per.data.dir=1offsets.topic.replication.factor=1transaction.state.log.replication.factor=1transaction.state.log.min.isr=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000zookeeper.connect=localhost:2181zookeeper.connection.timeout.ms=6000group.initial.rebalance.delay.ms=0</code></pre><p>注：可根据自己需求修改配置文件</p><ul><li>broker.id：唯一标识ID</li><li>listeners=PLAINTEXT://localhost:9092：kafka服务监听地址和端口</li><li>log.dirs：日志存储目录</li><li>zookeeper.connect：指定zookeeper服务</li></ul><p>（2）配置环境变量</p><pre><code>[root@along ~]# vim /etc/profile.d/kafka.shexport KAFKA_HOME=&quot;/data/kafka_2.11-2.1.0&quot;export PATH=&quot;${KAFKA_HOME}/bin:$PATH&quot;[root@along ~]# source /etc/profile.d/kafka.sh</code></pre><p>　　</p><p>（3）配置服务启动脚本</p><pre class=" language-shell"><code class="language-shell">[root@along ~]# vim /etc/init.d/kafka#!/bin/sh## chkconfig: 345 99 01# description: Kafka## File : Kafka## Description: Starts and stops the Kafka server# source /etc/rc.d/init.d/functions KAFKA_HOME=/data/kafka_2.11-2.1.0KAFKA_USER=rootexport LOG_DIR=/tmp/kafka-logs [ -e /etc/sysconfig/kafka ] && . /etc/sysconfig/kafka # See how we were called.case "$1" in  start)    echo -n "Starting Kafka:"    /sbin/runuser -s /bin/sh $KAFKA_USER -c "nohup $KAFKA_HOME/bin/kafka-server-start.sh $KAFKA_HOME/config/server.properties > $LOG_DIR/server.out 2> $LOG_DIR/server.err &"    echo " done."    exit 0    ;;  stop)    echo -n "Stopping Kafka: "    /sbin/runuser -s /bin/sh $KAFKA_USER  -c "ps -ef | grep kafka.Kafka | grep -v grep | awk '{print \$2}' | xargs kill"    echo " done."    exit 0    ;;  hardstop)    echo -n "Stopping (hard) Kafka: "    /sbin/runuser -s /bin/sh $KAFKA_USER  -c "ps -ef | grep kafka.Kafka | grep -v grep | awk '{print \$2}' | xargs kill -9"    echo " done."    exit 0    ;;  status)    c_pid=`ps -ef | grep kafka.Kafka | grep -v grep | awk '{print $2}'`    if [ "$c_pid" = "" ] ; then      echo "Stopped"      exit 3    else      echo "Running $c_pid"      exit 0    fi    ;;  restart)    stop    start    ;;  *)    echo "Usage: kafka {start|stop|hardstop|status|restart}"    exit 1    ;;esac</code></pre><p>　chmod +x kafka </p><p>​    chkconfig –add kafka  添加到服务器中</p><p>​    chkconfig kafka on 设置开机自动启动　</p><h3 id="3-4-启动kafka服务"><a href="#3-4-启动kafka服务" class="headerlink" title="3.4 启动kafka服务"></a><strong>3.4 启动kafka服务</strong></h3><p>（1）后台启动zookeeper服务</p><pre class=" language-shell"><code class="language-shell">[root@along ~]# nohup zookeeper-server-start.sh /data/kafka_2.11-2.1.0/config/zookeeper.properties &</code></pre><p>（2）启动kafka服务</p><pre class=" language-shell"><code class="language-shell">[root@along ~]# service kafka startStarting kafka (via systemctl):                            [  OK  ][root@along ~]# service kafka statusRunning 86018[root@along ~]# ss -nutlNetid State      Recv-Q Send-Q     Local Address:Port                    Peer Address:Port                              tcp   LISTEN     0      50                    :::9092                              :::*                 tcp   LISTEN     0      50                    :::2181                              :::*</code></pre><p>　　</p><h2 id="4、kafka使用简单入门"><a href="#4、kafka使用简单入门" class="headerlink" title="4、kafka使用简单入门"></a><strong>4、kafka使用简单入门</strong></h2><h3 id="4-1-创建主题topics"><a href="#4-1-创建主题topics" class="headerlink" title="4.1 创建主题topics"></a><strong>4.1 创建主题topics</strong></h3><p>创建一个名为“along”的主题，它只包含一个分区，只有一个副本：</p><pre class=" language-shell"><code class="language-shell">[root@along ~]# kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic along Created topic "along".</code></pre><p>如果我们运行list topic命令，我们现在可以看到该主题：</p><pre class=" language-shell"><code class="language-shell">[root@along ~]# kafka-topics.sh --list --zookeeper localhost:2181 along</code></pre><p>　　</p><h3 id="4-2-发送一些消息"><a href="#4-2-发送一些消息" class="headerlink" title="4.2 发送一些消息"></a><strong>4.2 发送一些消息</strong></h3><p>Kafka附带一个命令行客户端，它将从文件或标准输入中获取输入，并将其作为消息发送到Kafka集群。默认情况下，每行将作为单独的消息发送。</p><p>运行生产者，然后在控制台中键入一些消息以发送到服务器。</p><pre><code>[root@along ~]# kafka-console-producer.sh --broker-list localhost:9092 --topic along&gt;This is a message&gt;This is another message</code></pre><p>　　</p><h3 id="4-3-启动消费者"><a href="#4-3-启动消费者" class="headerlink" title="4.3 启动消费者"></a><strong>4.3 启动消费者</strong></h3><p>Kafka还有一个命令行使用者，它会将消息转储到标准输出。</p><pre><code>[root@along ~]# kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic along --from-beginning This is a message This is another message</code></pre><p>所有命令行工具都有其他选项; 运行不带参数的命令将显示更详细地记录它们的使用信息。</p><h2 id="5、设置多代理kafka群集"><a href="#5、设置多代理kafka群集" class="headerlink" title="5、设置多代理kafka群集"></a><strong>5、设置多代理kafka群集</strong></h2><p>　　到目前为止，我们一直在与一个broker运行，但这并不好玩。对于Kafka，单个代理只是一个大小为1的集群，因此除了启动一些代理实例之外没有太多变化。但是为了感受它，让我们将我们的集群扩展到三个节点（仍然在我们的本地机器上）。</p><h3 id="5-1-准备配置文件"><a href="#5-1-准备配置文件" class="headerlink" title="5.1 准备配置文件"></a><strong>5.1 准备配置文件</strong></h3><pre class=" language-shell"><code class="language-shell">[root@along kafka_2.11-2.1.0]# cd /data/kafka_2.11-2.1.0/[root@along kafka_2.11-2.1.0]# cp config/server.properties config/server-1.properties[root@along kafka_2.11-2.1.0]# cp config/server.properties config/server-2.properties[root@along kafka_2.11-2.1.0]# vim config/server-1.properties    broker.id=1    listeners=PLAINTEXT://:9093log.dirs=/tmp/kafka-logs-1[root@along kafka_2.11-2.1.0]# vim config/server-2.propertiesbroker.id=2listeners=PLAINTEXT://:9094log.dirs=/tmp/kafka-logs-2</code></pre><p>注：该<strong>broker.id</strong> 属性是群集中每个节点的<strong>唯一</strong>且永久的名称。我们必须覆盖端口和日志目录，因为我们在同一台机器上运行这些，并且我们希望让所有代理尝试在同一端口上注册或覆盖彼此的数据。</p><h3 id="5-2-开启集群另2个kafka服务"><a href="#5-2-开启集群另2个kafka服务" class="headerlink" title="5.2 开启集群另2个kafka服务"></a><strong>5.2 开启集群另2个kafka服务</strong></h3><pre><code>[root@along ~]# nohup kafka-server-start.sh /data/kafka_2.11-2.1.0/config/server-1.properties &amp;[root@along ~]# nohup kafka-server-start.sh /data/kafka_2.11-2.1.0/config/server-2.properties &amp;[root@along ~]# ss -nutlNetid State      Recv-Q Send-Q     Local Address:Port                    Peer Address:Port                          tcp   LISTEN     0      50      ::ffff:127.0.0.1:9092                              :::*                 tcp   LISTEN     0      50      ::ffff:127.0.0.1:9093                              :::*                                tcp   LISTEN     0      50      ::ffff:127.0.0.1:9094                              :::*</code></pre><p>　　</p><h3 id="5-3-在集群中进行操作"><a href="#5-3-在集群中进行操作" class="headerlink" title="5.3 在集群中进行操作"></a><strong>5.3 在集群中进行操作</strong></h3><p>（1）现在创建一个复制因子为3的新主题my-replicated-topic</p><pre><code>[root@along ~]# kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic Created topic &quot;my-replicated-topic&quot;.</code></pre><p>　　</p><p>（2）在一个集群中，运行“describe topics”命令查看哪个broker正在做什么</p><pre><code>[root@along ~]# kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic Topic:my-replicated-topic   PartitionCount:1    ReplicationFactor:3 Configs:Topic: my-replicated-topic  Partition: 0    Leader: 2   Replicas: 2,0,1 Isr: 2,0,1</code></pre><p>注释：第一行给出了所有分区的摘要，每个附加行提供有关一个分区的信息。由于我们只有一个分区用于此主题，因此只有一行。</p><ul><li>“leader”是负责给定分区的所有读取和写入的节点。每个节点将成为随机选择的分区部分的领导者。</li><li>“replicas”是复制此分区日志的节点列表，无论它们是否为领导者，或者即使它们当前处于活动状态。</li><li>“isr”是“同步”复制品的集合。这是副本列表的子集，该列表当前处于活跃状态并且已经被领导者捕获。</li></ul><p>请注意，Leader: 2，在我的示例中，节点2 是该主题的唯一分区的Leader。</p><p>（3）可以在我们创建的原始主题上运行相同的命令，以查看它的位置</p><pre><code>[root@along ~]# kafka-topics.sh --describe --zookeeper localhost:2181 --topic along Topic:along PartitionCount:1    ReplicationFactor:1 Configs:   Topic: along    Partition: 0    Leader: 0   Replicas: 0 Isr: 0</code></pre><p>　　</p><p>（4）向我们的新主题发布一些消息：</p><pre><code>[root@along ~]# kafka-console-producer.sh --broker-list localhost:9092 --topic my-replicated-topic&gt;my test message 1&gt;my test message 2&gt;^C</code></pre><p>　　</p><p>（5）现在让我们使用这些消息：</p><pre><code>[root@along ~]# kafka-console-consumer.sh --bootstrap-server localhost:9092 --from-beginning --topic my-replicated-topicmy test message 1my test message 2</code></pre><p>　　</p><h3 id="5-4-测试集群的容错性"><a href="#5-4-测试集群的容错性" class="headerlink" title="5.4 测试集群的容错性"></a><strong>5.4 测试集群的容错性</strong></h3><p>（1）现在让我们测试一下容错性。Broker 2 充当leader 所以让我们杀了它：</p><pre><code>[root@along ~]# ps aux | grep server-2.properties |awk &#39;{print $2}&#39;106737[root@along ~]# kill -9 106737[root@along ~]# ss -nutltcp   LISTEN     0      50      ::ffff:127.0.0.1:9092                              :::*                       tcp   LISTEN     0      50      ::ffff:127.0.0.1:9093                              :::*</code></pre><p>　　</p><p>（2）leader 已切换到其中一个从属节点，节点2不再位于同步副本集中：</p><pre><code>[root@along ~]# kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic Topic:my-replicated-topic   PartitionCount:1    ReplicationFactor:3 Configs:    Topic: my-replicated-topic  Partition: 0    Leader: 0   Replicas: 2,0,1 Isr: 0,1</code></pre><p>　　</p><p>（3）即使最初接受写入的leader 已经失败，这些消息仍可供消费：</p><pre><code>[root@along ~]# kafka-console-consumer.sh --bootstrap-server localhost:9092 --from-beginning --topic my-replicated-topicmy test message 1my test message 2</code></pre><p>　　</p><h2 id="6、-使用Kafka-Connect导入-导出数据"><a href="#6、-使用Kafka-Connect导入-导出数据" class="headerlink" title="6、**使用Kafka Connect导入/导出数据**"></a><strong>6、**</strong>使用Kafka Connect导入/导出数据**</h2><p>　　从控制台写入数据并将其写回控制台是一个方便的起点，但有时候可能希望使用<strong>其他来源的数据或将数据从Kafka导出到其他系统</strong>。对于许多系统，您可以<strong>使用Kafka Connect导入或导出数据</strong>，而不是编写自定义集成代码。</p><p>　　<strong>Kafka Connect是Kafka附带的工具，用于向Kafka导入和导出数据</strong>。它是一个可扩展的工具，运行连接器，实现与外部系统交互的自定义逻辑。在本快速入门中，我们将了解如何使用简单的连接器运行Kafka Connect，这些连接器将数据从文件导入Kafka主题并将数据从Kafka主题导出到文件。</p><p>（1）首先创建一些种子数据进行测试：</p><pre><code>[root@along ~]# echo -e &quot;foo\nbar&quot; &gt; test.txt</code></pre><p>或者在Windows上：</p><pre><code>&gt; echo foo&gt; test.txt&gt; echo bar&gt;&gt; test.txt</code></pre><p>　　</p><p>（2）接下来，<strong>启动两个以独立模式运行的连接器</strong>，这意味着它们在单个本地专用进程中运行。提供三个配置文件作为参数。</p><ul><li>第一个始终是Kafka Connect流程的配置，包含常见配置，例如要连接的Kafka代理和数据的序列化格式。</li><li>其余配置文件均指定要创建的连接器。这些文件包括唯一的连接器名称，要实例化的连接器类以及连接器所需的任何其他配置。</li></ul><pre><code>[root@along ~]# connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties[2019-01-16 16:16:31,884] INFO Kafka Connect standalone worker initializing ... (org.apache.kafka.connect.cli.ConnectStandalone:67)[2019-01-16 16:16:31,903] INFO WorkerInfo values:... ...</code></pre><p>　　注：Kafka附带的这些示例配置文件使用您之前启动的默认本地群集配置并创建两个连接器：第一个是源连接器，它从输入文件读取行并生成每个Kafka主题，第二个是宿连接器从Kafka主题读取消息并将每个消息生成为输出文件中的一行。</p><p>（3）验证是否导入成功（另起终端）</p><p>在启动过程中，您将看到许多日志消息，包括一些指示正在实例化连接器的日志消息。</p><p>① 一旦Kafka Connect进程启动，源连接器应该开始从test.txt主题读取行并将其生成到主题connect-test，并且接收器连接器应该开始从主题读取消息connect-test 并将它们写入文件test.sink.txt。我们可以通过检查输出文件的内容来验证数据是否已通过整个管道传递：</p><pre><code>[root@along ~]# cat test.sink.txtfoobar</code></pre><p>　　</p><p>② 请注意，数据存储在Kafka主题中connect-test，因此我们还可以运行控制台使用者来查看主题中的数据（或使用自定义使用者代码来处理它）：</p><pre><code>[root@along ~]# kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic connect-test --from-beginning{&quot;schema&quot;:{&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false},&quot;payload&quot;:&quot;foo&quot;}{&quot;schema&quot;:{&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false},&quot;payload&quot;:&quot;bar&quot;}</code></pre><p>　　</p><p>（4）继续追加数据，验证</p><pre><code>[root@along ~]# echo Another line&gt;&gt; test.txt   [root@along ~]# cat test.sink.txtfoobarAnother line[root@along ~]# kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic connect-test --from-beginning{&quot;schema&quot;:{&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false},&quot;payload&quot;:&quot;foo&quot;}{&quot;schema&quot;:{&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false},&quot;payload&quot;:&quot;bar&quot;}{&quot;schema&quot;:{&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false},&quot;payload&quot;:&quot;Another line&quot;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka集群搭建</title>
      <link href="2019/04/26/sql/kafka-ji-qun-da-jian/"/>
      <url>2019/04/26/sql/kafka-ji-qun-da-jian/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="常用Message-Queue对比"><a href="#常用Message-Queue对比" class="headerlink" title="常用Message Queue对比"></a>常用Message Queue对比</h3><p><strong>RabbitMQ</strong></p><pre><code>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</code></pre><p><strong>Redis</strong></p><pre><code>Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</code></pre><p><strong>ZeroMQ</strong></p><pre><code>ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm 0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模块）。</code></pre><p><strong>ActiveMQ</strong></p><pre><code>ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。</code></pre><p><strong>Kafka/Jafka</strong></p><pre><code>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统</code></pre><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>producer： 消息生产者，发布消息到 kafka 集群的终端或服务。<br>broker： kafka 集群中包含的服务器。<br>topic：每条发布到 kafka 集群的消息属于的类别，即 kafka 是面向 topic 的。<br>partition： partition 是物理上的概念，每个 topic 包含一个或多个 partition。kafka 分配的单位是 partition。<br>consumer： 从 kafka 集群中消费消息的终端或服务。<br>Consumer group： high-level consumer API 中，每个 consumer 都属于一个 consumer group，每条消息只能被 consumer group 中的一个 Consumer 消费，但可以被多个 consumer group 消费。<br>replica： partition 的副本，保障 partition 的高可用。<br>leader： replica 中的一个角色， producer 和 consumer 只跟 leader 交互。<br>follower： replica 中的一个角色，从 leader 中复制数据。<br>controller： kafka 集群中的其中一个服务器，用来进行 leader election 以及 各种 failover。<br>zookeeper： kafka 通过 zookeeper 来存储集群的 meta 信息</p><h3 id="单实例Kafka"><a href="#单实例Kafka" class="headerlink" title="单实例Kafka"></a>单实例Kafka</h3><p>前提条件：安装JDK、设置JAVA_HOME、PATH环境变量。</p><p>wget <a href="http://mirrors.hust.edu.cn/apache/kafka/1.1.0/kafka_2.12-1.1.0.tgz" target="_blank" rel="noopener">http://mirrors.hust.edu.cn/apache/kafka/1.1.0/kafka_2.12-1.1.0.tgz</a></p><h4 id="1-Terminal-A"><a href="#1-Terminal-A" class="headerlink" title="(1) Terminal A"></a>(1) Terminal A</h4><pre class=" language-shell"><code class="language-shell">[root@sdopenswan-jp ~]# lsconfigserver.sh  kafka_2.12-0.10.2.1.tgz[root@sdopenswan-jp ~]# tar xfz kafka_2.12-0.10.2.1.tgz[root@sdopenswan-jp ~]# lsconfigserver.sh  kafka_2.12-0.10.2.1  kafka_2.12-0.10.2.1.tgz[root@sdopenswan-jp ~]# cd kafka_2.12-0.10.2.1[root@sdopenswan-jp kafka_2.12-0.10.2.1]# vim config/zookeeper.properties[root@sdopenswan-jp kafka_2.12-0.10.2.1]# grep -Pv "^#" config/zookeeper.propertiesdataDir=zkdata1clientPort=2181maxClientCnxns=0[root@sdopenswan-jp kafka_2.12-0.10.2.1]# bin/zookeeper-server-start.sh config/zookeeper.properties &      #启动zookeeper[root@sdopenswan-jp kafka_2.12-0.10.2.1]# lsbin  config  libs  LICENSE  logs  NOTICE  site-docs  zkdata1[root@sdopenswan-jp kafka_2.12-0.10.2.1]# ls zkdata1/version-2[root@sdopenswan-jp kafka_2.12-0.10.2.1]# vim config/server.properties[root@sdopenswan-jp kafka_2.12-0.10.2.1]# grep -Pv "^($|#)" config/server.propertiesbroker.id=0listeners=PLAINTEXT://:9092num.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=kfkdata1num.partitions=1num.recovery.threads.per.data.dir=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000zookeeper.connect=localhost:2181zookeeper.connection.timeout.ms=6000[root@sdopenswan-jp kafka_2.12-0.10.2.1]# bin/kafka-server-start.sh config/server.properties[root@sdopenswan-jp kafka_2.12-0.10.2.1]# lsbin  config  kfkdata1  libs  LICENSE  logs  NOTICE  site-docs  zkdata1[root@sdopenswan-jp kafka_2.12-0.10.2.1]# ls kfkdata1/cleaner-offset-checkpoint  meta.properties  recovery-point-offset-checkpoint  replication-offset-checkpoint[root@sdopenswan-jp kafka_2.12-0.10.2.1]# jps3538 Jps2964 QuorumPeerMain3214 Kafka[root@sdopenswan-jp kafka_2.12-0.10.2.1]#</code></pre><p>Kafka 占tcp 9092 端口，而zookeeper占 tcp 2181端口</p><h4 id="2-Terminal-B-创建-一个topic"><a href="#2-Terminal-B-创建-一个topic" class="headerlink" title="(2) Terminal B   创建 一个topic"></a>(2) Terminal B   创建 一个topic</h4><pre class=" language-shell"><code class="language-shell">[root@sdopenswan-jp kafka_2.12-0.10.2.1]# bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partition 1 --topic myfirst-topicWARNING: Due to limitations in metric names, topics with a period ('.') or underscore ('_') could collide. To avoid issues it is best to use either, but not both.Created topic "myfirst_topic".[root@sdopenswan-jp kafka_2.12-0.10.2.1]# ls kfkdata1/cleaner-offset-checkpoint  meta.properties  myfirst_topic-0  recovery-point-offset-checkpoint  replication-offset-checkpoint[root@sdopenswan-jp kafka_2.12-0.10.2.1]# ls kfkdata1/myfirst-topic-0/00000000000000000000.index  00000000000000000000.log  00000000000000000000.timeindex[root@sdopenswan-jp kafka_2.12-0.10.2.1]#[root@sdopenswan-jp kafka_2.12-0.10.2.1]# bin/kafka-topics.sh --list --zookeeper localhost:2181myfirst-topic[root@sdopenswan-jp kafka_2.12-0.10.2.1]# bin/kafka-console-producer.sh --topic myfirst-topic --broker-list localhost:9092hello world !hello kafka myfirst_topic </code></pre><h4 id="3-Terminal-C-consumer端连接到zookeeper-读取信息"><a href="#3-Terminal-C-consumer端连接到zookeeper-读取信息" class="headerlink" title="(3) Terminal C  # consumer端连接到zookeeper 读取信息"></a>(3) Terminal C  # consumer端连接到zookeeper 读取信息</h4><pre class=" language-shell"><code class="language-shell">[root@sdopenswan-jp kafka_2.12-0.10.2.1]# bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic myfirst_topic --from-beginningUsing the ConsoleConsumer with old consumer is deprecated and will be removed in a future major release. Consider using the new consumer by passing [bootstrap-server] instead of [zookeeper].hello world !hello kafka myfirst_topic</code></pre><h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><h4 id="Zookeeper配置"><a href="#Zookeeper配置" class="headerlink" title="Zookeeper配置"></a>Zookeeper配置</h4><p>1)  在zoo.cfg中追加以下内容：</p><pre class=" language-shell"><code class="language-shell">server.n=ip:portA:portB#n是服务器标识号（1~255）#ip是服务器ip地址#portA是与leader进行信息交换的端口#portB是在leader宕机后，进行leader选举所用的端口例：server.1=200.31.157.116:20881:30881server.2=200.31.157.116:20882:30882server.3=200.31.157.117:20881:30881tickTime：毫秒级的基本时间单位，其他时间如心跳/超时等都为该单位时间的整数倍。initLimit：tickTime的倍数，表示leader选举结束后，followers与leader同步需要的时间，leader的数据非常多或followers比较多时，该值应适当大一些。syncLimit：tickTime的倍数，表示follower和observer与leader交互时的最大等待时间，是在与leader同步完毕之后，正常请求转发或ping等消息交互时的超时时间。clientPort：监听客户端连接的服务端口，若一台服务器上安装多个ZooKeeper server，则需要设置不同的端口号。dataDir：内存数据库快照地址，事务日志地址（除非由dataLogDir另行指定）。</code></pre><p>2)  在$dataDir下新建文件myid，并写入服务器标识号</p><pre class=" language-shell"><code class="language-shell">#/tmp/zookeeper为dataDircd /tmp/zookeeper/vim myid#在myid中添加服务器标识号</code></pre><h4 id="Kafka配置"><a href="#Kafka配置" class="headerlink" title="Kafka配置"></a>Kafka配置</h4><p>在配置文件server.properties修改如下内容：</p><pre class=" language-shell"><code class="language-shell">#broker.id是broker的标识，具有唯一性broker.id=0#端口号默认为9092port=9092#host.name位kafka所在机器的iphost.name=10.18.42.251#设置zookeeper，可连接多个zookeeper服务器zookeeper.connect=200.31.157.116:2182,200.31.157.116:2183,200.31.157.117:2182</code></pre><h3 id="多实例Kafka"><a href="#多实例Kafka" class="headerlink" title="多实例Kafka"></a>多实例Kafka</h3><h4 id="1-配置并启动zookeeper"><a href="#1-配置并启动zookeeper" class="headerlink" title="(1)配置并启动zookeeper"></a>(1)配置并启动zookeeper</h4><pre class=" language-shell"><code class="language-shell">[root@sdopenswan-jp kafka_2.12-0.10.2.1]# vim config/zookeeper.properties[root@sdopenswan-jp kafka_2.12-0.10.2.1]# grep -Pv "^#" config/zookeeper.propertiesdataDir=zkdata1clientPort=2181maxClientCnxns=0tickTime=2000initLimit=5syncLimit=2server.0=172.16.1.16:2888:3888server.1=172.16.2.59:2888:3888server.2=172.16.0.198:2888:3888[root@sdopenswan-jp kafka_2.12-0.10.2.1]# echo 0 > zkdata1/myid[root@sdredis01-jp kafka_2.12-0.10.2.1]# vim config/zookeeper.properties[root@sdredis01-jp kafka_2.12-0.10.2.1]# grep -Pv "^#" config/zookeeper.propertiesdataDir=zkdata1clientPort=2181maxClientCnxns=0tickTime=2000initLimit=5syncLimit=2server.0=172.16.1.16:2888:3888server.1=172.16.2.59:2888:3888server.2=172.16.0.198:2888:3888[root@sdredis01-jp kafka_2.12-0.10.2.1]# lsbin  config  libs  LICENSE  NOTICE  site-docs[root@sdredis01-jp kafka_2.12-0.10.2.1]# mkdir zkdata1[root@sdredis01-jp kafka_2.12-0.10.2.1]# echo 1 >  zkdata1/myid[root@sdredis01-jp kafka_2.12-0.10.2.1]#[root@sdredis02-jp kafka_2.12-0.10.2.1]# vim config/zookeeper.properties[root@sdredis02-jp kafka_2.12-0.10.2.1]# grep -Pv "^#" config/zookeeper.propertiesdataDir=zkdata1clientPort=2181maxClientCnxns=0tickTime=2000initLimit=5syncLimit=2server.0=172.16.1.16:2888:3888server.1=172.16.2.59:2888:3888server.2=172.16.0.198:2888:3888[root@sdredis02-jp kafka_2.12-0.10.2.1]# mkdir zkdata1[root@sdredis02-jp kafka_2.12-0.10.2.1]# echo 2 > zkdata1/myid[root@sdredis02-jp kafka_2.12-0.10.2.1]#[root@sdopenswan-jp kafka_2.12-0.10.2.1]#  bin/zookeeper-server-start.sh config/zookeeper.properties &[root@sdredis01-jp kafka_2.12-0.10.2.1]# bin/zookeeper-server-start.sh config/zookeeper.properties &[root@sdredis02-jp kafka_2.12-0.10.2.1]# bin/zookeeper-server-start.sh config/zookeeper.properties &</code></pre><h4 id="2-配置并启动kafka"><a href="#2-配置并启动kafka" class="headerlink" title="(2)配置并启动kafka"></a>(2)配置并启动kafka</h4><pre class=" language-shell"><code class="language-shell">[root@sdopenswan-jp kafka_2.12-0.10.2.1]# vim config/server.properties[root@sdopenswan-jp kafka_2.12-0.10.2.1]# grep -Pv "^($|#)" config/server.propertiesbroker.id=0listeners=PLAINTEXT://:9092num.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=kfklognum.partitions=3num.recovery.threads.per.data.dir=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000zookeeper.connect=172.16.1.16:2181,172.16.2.59:2181,172.16.0.198:2181zookeeper.connection.timeout.ms=6000[root@sdopenswan-jp kafka_2.12-0.10.2.1]# vim config/consumer.properties[root@sdopenswan-jp kafka_2.12-0.10.2.1]# grep -Pv "^($|#)" config/consumer.propertieszookeeper.connect=172.16.1.16:2181,172.16.2.59:2181,172.16.0.198:2181zookeeper.connection.timeout.ms=6000group.id=test-consumer-group[root@sdopenswan-jp kafka_2.12-0.10.2.1]# vim config/producer.properties[root@sdopenswan-jp kafka_2.12-0.10.2.1]# grep -Pv "^($|#)" config/producer.propertiesbootstrap.servers=172.16.1.16:9092,172.16.2.59:9092,172.16.0.198:9092compression.type=none[root@sdopenswan-jp kafka_2.12-0.10.2.1]#[root@sdredis01-jp kafka_2.12-0.10.2.1]# vim config/server.properties[root@sdredis01-jp kafka_2.12-0.10.2.1]# grep -Pv "^($|#)" config/server.propertiesbroker.id=1listeners=PLAINTEXT://:9092num.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=kfklognum.partitions=3num.recovery.threads.per.data.dir=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000zookeeper.connect=172.16.1.16:2181,172.16.2.59:2181,172.16.0.198:2181zookeeper.connection.timeout.ms=6000[root@sdredis01-jp kafka_2.12-0.10.2.1]# vim config/consumer.properties[root@sdredis01-jp kafka_2.12-0.10.2.1]# grep -Pv "^($|#)" config/consumer.propertieszookeeper.connect=172.16.1.16:2181,172.16.2.59:2181,172.16.0.198:2181zookeeper.connection.timeout.ms=6000group.id=test-consumer-group[root@sdredis01-jp kafka_2.12-0.10.2.1]# vim config/producer.properties[root@sdredis01-jp kafka_2.12-0.10.2.1]# grep -Pv "^($|#)" config/producer.propertiesbootstrap.servers=172.16.1.16:9092,172.16.2.59:9092,172.16.0.198:9092compression.type=none[root@sdredis01-jp kafka_2.12-0.10.2.1]#[root@sdredis02-jp kafka_2.12-0.10.2.1]# vim config/server.properties[root@sdredis02-jp kafka_2.12-0.10.2.1]# grep -Pv "^($|#)" config/server.propertiesbroker.id=2listeners=PLAINTEXT://:9092num.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=kfklognum.partitions=3num.recovery.threads.per.data.dir=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000zookeeper.connect=172.16.1.16:2181,172.16.2.59:2181,172.16.0.198:2181zookeeper.connection.timeout.ms=6000[root@sdredis02-jp kafka_2.12-0.10.2.1]# vim config/consumer.properties[root@sdredis02-jp kafka_2.12-0.10.2.1]# grep -Pv "^($|#)" config/consumer.propertieszookeeper.connect=172.16.1.16:2181,172.16.2.59:2181,172.16.0.198:2181zookeeper.connection.timeout.ms=6000group.id=test-consumer-group[root@sdredis02-jp kafka_2.12-0.10.2.1]# vim config/producer.properties[root@sdredis02-jp kafka_2.12-0.10.2.1]# grep -Pv "^($|#)" config/producer.propertiesbootstrap.servers=172.16.1.16:9092,172.16.2.59:9092,172.16.0.198:9092compression.type=none[root@sdredis02-jp kafka_2.12-0.10.2.1]#</code></pre><p>三台机器分别启动  bin/kafka-server-start.sh config/server.properties &amp;</p><h4 id="3-测试"><a href="#3-测试" class="headerlink" title="(3)测试"></a>(3)测试</h4><pre class=" language-shell"><code class="language-shell">[root@sdredis02-jp kafka_2.12-0.10.2.1]# bin/kafka-topics.sh --create --zookeeper 172.16.0.198:2181  --replication-factor 3 --partitions 1 --topic yc01_topicWARNING: Due to limitations in metric names, topics with a period ('.') or underscore ('_') could collide. To avoid issues it is best to use either, but not both.Created topic "yc01_topic".[root@sdredis02-jp kafka_2.12-0.10.2.1]# bin/kafka-topics.sh --list --zookeeper 172.16.0.198:2181myfirst_topicyc01_topic[root@sdredis02-jp kafka_2.12-0.10.2.1]# bin/kafka-topics.sh --describe --zookeeper 172.16.0.198:2181Topic:myfirst_topic    PartitionCount:1    ReplicationFactor:1    Configs:    Topic: myfirst_topic    Partition: 0    Leader: 0    Replicas: 0    Isr: 0Topic:yc01_topic    PartitionCount:1    ReplicationFactor:3    Configs:    Topic: yc01_topic    Partition: 0    Leader: 1    Replicas: 1,2,0    Isr: 1,2,0[root@sdredis02-jp kafka_2.12-0.10.2.1]#[root@sdredis01-jp kafka_2.12-0.10.2.1]# bin/kafka-console-producer.sh --broker-list 172.16.1.16:9092,172.16.2.59:9092,172.16.0.198:9092 --topic yc01_topichello multi instance kafka[root@sdredis02-jp kafka_2.12-0.10.2.1]# bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic yc01_topic --from-beginningUsing the ConsoleConsumer with old consumer is deprecated and will be removed in a future major release. Consider using the new consumer by passing [bootstrap-server] instead of [zookeeper].hello multi instance kafka</code></pre><h4 id="4-查看zookeeper状态"><a href="#4-查看zookeeper状态" class="headerlink" title="(4)查看zookeeper状态"></a>(4)查看zookeeper状态</h4><pre class=" language-shell"><code class="language-shell">[root@sdopenswan-jp kafka_2.12-0.10.2.1]# echo stat|nc 127.0.0.1 2181Zookeeper version: 3.4.9-1757313, built on 08/23/2016 06:50 GMTClients: /127.0.0.1:46010[0](queued=0,recved=1,sent=0) /172.16.0.198:53940[1](queued=0,recved=875,sent=875)Latency min/avg/max: 0/0/4Received: 890Sent: 889Connections: 2Outstanding: 0Zxid: 0x100000060Mode: leaderNode count: 33[root@sdopenswan-jp kafka_2.12-0.10.2.1]#[root@sdredis01-jp kafka_2.12-0.10.2.1]# echo stat|nc 127.0.0.1 2181Zookeeper version: 3.4.9-1757313, built on 08/23/2016 06:50 GMTClients: /127.0.0.1:53466[0](queued=0,recved=1,sent=0)Latency min/avg/max: 0/0/0Received: 2Sent: 1Connections: 1Outstanding: 0Zxid: 0x10000005dMode: followerNode count: 33[root@sdredis02-jp kafka_2.12-0.10.2.1]# echo stat|nc 127.0.0.1 2181Zookeeper version: 3.4.9-1757313, built on 08/23/2016 06:50 GMTClients: /172.16.2.59:53354[1](queued=0,recved=952,sent=952) /172.16.1.16:53038[1](queued=0,recved=1018,sent=1023) /127.0.0.1:49478[0](queued=0,recved=1,sent=0)Latency min/avg/max: 0/0/15Received: 2566Sent: 2572Connections: 3Outstanding: 0Zxid: 0x100000060Mode: followerNode count: 33[root@sdredis02-jp kafka_2.12-0.10.2.1]#</code></pre><h4 id="5-常用命令总结"><a href="#5-常用命令总结" class="headerlink" title="(5)常用命令总结"></a>(5)常用命令总结</h4><pre class=" language-shell"><code class="language-shell">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 2 --partitions 4 --topic testbin/kafka-topics.sh --describe --zookeeper bin/kafka-console-producer.sh --broker-list localhost:9092 --topic testbin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic testbin/kafka-console-producer.sh --broker-list localhost:9092 --topic test --producer.config config/producer.propertiesbin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --new-consumer --from-beginning --consumer.config config/consumer.propertiesbin/kafka-consumer-groups.sh --new-consumer --bootstrap-server localhost:9092 --listbin/kafka-run-class.sh kafka.tools.ConsumerOffsetChecker --zkconnect localhost:2181 --group testbin/kafka-consumer-groups.sh --new-consumer --bootstrap-server localhost:9092 --describe --group test-consumer-groupbin/kafka-preferred-replica-election.sh --zookeeper zk_host:port/chrootbin/kafka-producer-perf-test.sh --topic test --num-records 100 --record-size 1 --throughput 100  --producer-props bootstrap.servers=localhost:9092</code></pre><p>用户在客户端可以通过 telnet 或 nc 向 ZooKeeper 提交相应的命令</p><ol><li>可以通过命令：echo stat|nc 127.0.0.1 2181 来查看哪个节点被选择作为follower或者leader</li><li>使用echo ruok|nc 127.0.0.1 2181 测试是否启动了该Server，若回复imok表示已经启动。</li><li>echo dump| nc 127.0.0.1 2181 ,列出未经处理的会话和临时节点。</li><li>echo kill | nc 127.0.0.1 2181 ,关掉server</li><li>echo conf | nc 127.0.0.1 2181 ,输出相关服务配置的详细信息。</li><li>echo cons | nc 127.0.0.1 2181 ,列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息。</li><li>echo envi |nc 127.0.0.1 2181 ,输出关于服务环境的详细信息（区别于 conf 命令）。</li><li>echo reqs | nc 127.0.0.1 2181 ,列出未经处理的请求。</li><li>echo wchs | nc 127.0.0.1 2181 ,列出服务器 watch 的详细信息。</li><li>echo wchc | nc 127.0.0.1 2181 ,通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表。</li><li>echo wchp | nc 127.0.0.1 2181 ,通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径</li></ol><h3 id="补充新实验过程-参考"><a href="#补充新实验过程-参考" class="headerlink" title="补充新实验过程(参考)"></a>补充新实验过程(参考)</h3><p>teacher配置如下：</p><pre class=" language-shell"><code class="language-shell">[root@teacher ~]# vim /etc/profile[root@teacher ~]# source /etc/profile[root@teacher ~]# echo $JAVA_HOME/usr/java/latest[root@teacher ~]# which java/usr/java/latest/bin/java[root@teacher ~]# java -versionjava version "1.8.0_162"Java(TM) SE Runtime Environment (build 1.8.0_162-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)[root@teacher ~]#[root@teacher ~]# scp /etc/profile node2:/etc/profile                                                                                100% 1859   549.7KB/s   00:00    [root@teacher ~]# scp /etc/profile node3:/etc/profile                                                                                100% 1859   448.7KB/s   00:00    [root@teacher ~]#[root@teacher ~]# tar xf kafka_2.12-1.1.0.tgz  -C /usr/local/[root@teacher opt]# cd /usr/local/[root@teacher local]# ln -s kafka_2.12-1.1.0/ kafka[root@teacher local]# lsbin  etc  games  include  kafka  kafka_2.12-1.1.0  lib  lib64  libexec  logstash  php  sbin  share  src  zabbix[root@teacher local]# cd kafka[root@teacher kafka]# mkdir zkdata[root@teacher kafka]# mkdir kfklog[root@teacher kafka]# echo 0 > zkdata/myid[root@teacher kafka]# vim config/zookeeper.properties [root@teacher kafka]# grep -Pv "^(#|$)" config/zookeeper.propertiesdataDir=zkdataclientPort=2181maxClientCnxns=0tickTime=2000initLimit=5syncLimit=2server.0=192.168.233.102:2888:3888server.1=192.168.233.103:2888:3888server.2=192.168.233.104:2888:3888[root@teacher kafka]# vim config/server.properties [root@teacher kafka]# grep -Pv "^(#|$)" config/server.properties broker.id=0listeners=PLAINTEXT://:9092advertised.listeners=PLAINTEXT://192.168.233.102:9092num.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=kfklognum.partitions=3num.recovery.threads.per.data.dir=1offsets.topic.replication.factor=1transaction.state.log.replication.factor=1transaction.state.log.min.isr=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000zookeeper.connect=192.168.233.102:2181,192.168.233.103:2181,192.168.233.104:2181zookeeper.connection.timeout.ms=6000group.initial.rebalance.delay.ms=0[root@teacher kafka]# vim config/consumer.properties [root@teacher kafka]# grep -Pv "^(#|$)" config/consumer.properties bootstrap.servers=192.168.233.102:9092,192.168.233.103:9092,192.168.233.104:9092zookeeper.connect=192.168.233.102:2181,192.168.233.103:2181,192.168.233.104:2181group.id=test-consumer-group[root@teacher kafka]# vim config/producer.properties [root@teacher kafka]# grep -Pv "^(#|$)" config/producer.properties bootstrap.servers=192.168.233.102:9092,192.168.233.103:9092,192.168.233.104:9092compression.type=none[root@teacher ~]# cd /usr/local/[root@teacher local]# scp -r kafkakafka/             kafka_2.12-1.1.0/  [root@teacher local]# scp -r kafka_2.12-1.1.0 node2:/usr/local/</code></pre><p>node2配置如下：</p><pre class=" language-shell"><code class="language-shell">[root@node2 ~]# java -version java version "1.8.0_162"Java(TM) SE Runtime Environment (build 1.8.0_162-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)[root@node2 ~]# source /etc/profile[root@node2 ~]# echo $JAVA_HOME/usr/java/latest[root@node2 ~]# which java/usr/java/latest/bin/java[root@node2 ~]# tail -3  /etc/hosts192.168.233.102 teacher192.168.233.103 node2192.168.233.104 node3[root@node2 ~]# cd /usr/local/[root@node2 local]# ln -s kafka_2.12-1.1.0 kafka[root@node2 local]# cd kafka[root@node2 kafka]# echo 1 > zkdata/myid [root@node2 kafka]# vim config/server.properties [root@node2 kafka]# vim config/consumer.properties [root@node2 kafka]# vim config/producer.properties [root@node2 kafka]# grep -Pv "^(#|$)" config/zookeeper.properties dataDir=zkdataclientPort=2181maxClientCnxns=0tickTime=2000initLimit=5syncLimit=2server.0=192.168.233.102:2888:3888server.1=192.168.233.103:2888:3888server.2=192.168.233.104:2888:3888[root@node2 kafka]# grep -Pv "^(#|$)" config/server.properties broker.id=1listeners=PLAINTEXT://:9092advertised.listeners=PLAINTEXT://192.168.233.103:9092num.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=kfklognum.partitions=3num.recovery.threads.per.data.dir=1offsets.topic.replication.factor=1transaction.state.log.replication.factor=1transaction.state.log.min.isr=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000zookeeper.connect=192.168.233.102:2181,192.168.233.103:2181,192.168.233.104:2181zookeeper.connection.timeout.ms=6000group.initial.rebalance.delay.ms=0[root@node2 kafka]# grep -Pv "^(#|$)" config/consumer.properties bootstrap.servers=192.168.233.102:9092,192.168.233.103:9092,192.168.233.104:9092zookeeper.connect=192.168.233.102:2181,192.168.233.103:2181,192.168.233.104:2181group.id=test-consumer-group[root@node2 kafka]# grep -Pv "^(#|$)" config/producer.properties bootstrap.servers=192.168.233.102:9092,192.168.233.103:9092,192.168.233.104:9092compression.type=none[root@node2 kafka]#</code></pre><p>node3配置如下：</p><pre class=" language-shell"><code class="language-shell">[root@node3 ~]# cd /usr/local/[root@node3 local]# ln -s kafka_2.12-1.1.0 kafka[root@node3 local]# lsbin  etc  games  include  kafka  kafka_2.12-1.1.0  lib  lib64  libexec  sbin  share  src[root@node3 local]# cd kafka[root@node3 kafka]# lsbin  config  kfklog  libs  LICENSE  NOTICE  site-docs  zkdata[root@node3 kafka]# echo 2 > zkdata/myid [root@node3 kafka]# vim config/server.properties [root@node3 kafka]# grep -Pv "^(#|$)" config/zookeeper.properties dataDir=zkdataclientPort=2181maxClientCnxns=0tickTime=2000initLimit=5syncLimit=2server.0=192.168.233.102:2888:3888server.1=192.168.233.103:2888:3888server.2=192.168.233.104:2888:3888[root@node3 kafka]# grep -Pv "^(#|$)" config/server.properties broker.id=2listeners=PLAINTEXT://:9092advertised.listeners=PLAINTEXT://192.168.233.104:9092num.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=kfklognum.partitions=3num.recovery.threads.per.data.dir=1offsets.topic.replication.factor=1transaction.state.log.replication.factor=1transaction.state.log.min.isr=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000zookeeper.connect=192.168.233.102:2181,192.168.233.103:2181,192.168.233.104:2181zookeeper.connection.timeout.ms=6000group.initial.rebalance.delay.ms=0[root@node3 kafka]# grep -Pv "^(#|$)" config/consumer.properties bootstrap.servers=192.168.233.102:9092,192.168.233.103:9092,192.168.233.104:9092zookeeper.connect=192.168.233.102:2181,192.168.233.103:2181,192.168.233.104:2181group.id=test-consumer-group[root@node3 kafka]# grep -Pv "^(#|$)" config/producer.properties bootstrap.servers=192.168.233.102:9092,192.168.233.103:9092,192.168.233.104:9092compression.type=none[root@node3 kafka]# </code></pre><p>启动zookeeper</p><pre class=" language-shell"><code class="language-shell">[root@teacher kafka]# bin/zookeeper-server-start.sh config/zookeeper.properties & [root@node2 kafka]# bin/zookeeper-server-start.sh config/zookeeper.properties &[root@node3 kafka]# bin/zookeeper-server-start.sh config/zookeeper.properties &</code></pre><p>启动kafka</p><pre class=" language-shell"><code class="language-shell">[root@teacher kafka]# bin/kafka-server-start.sh config/server.properties &[root@node2 kafka]#  bin/kafka-server-start.sh config/server.properties &[root@node3 kafka]#  bin/kafka-server-start.sh config/server.properties &</code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible-roles</title>
      <link href="2019/04/18/linux/ansible-roles/"/>
      <url>2019/04/18/linux/ansible-roles/</url>
      
        <content type="html"><![CDATA[<h2 id="ansible-roles"><a href="#ansible-roles" class="headerlink" title="ansible-roles"></a>ansible-roles</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>roles则是在ansible中，playbooks的目录组织结构。<br>而模块化之后，成为roles的组织结构，易读，代码可重用，层次清晰。</p><h3 id="2-目标"><a href="#2-目标" class="headerlink" title="2.目标"></a>2.目标</h3><p>通过role远程部署nginx并配置</p><h3 id="3-目录结构"><a href="#3-目录结构" class="headerlink" title="3.目录结构"></a>3.目录结构</h3><p>[<img src="https://s1.ax1x.com/2020/09/28/0VbuwT.md.png" alt="0VbuwT.md.png"></p><pre><code>files/：存储由copy或script等模块调用的文件；tasks/：此目录中至少应该有一个名为main.yml的文件，用于定义各task；其它的文件需要由main.yml进行“包含”调用；handlers/：此目录中至少应该有一个名为main.yml的文件，用于定义各handler；其它的文件需要由main.yml进行“包含”调用；vars/：此目录中至少应该有一个名为main.yml的文件，用于定义各variable；其它的文件需要由main.yml进行“包含”调用；templates/：存储由template模块调用的模板文本；meta/：此目录中至少应该有一个名为main.yml的文件，定义当前角色的特殊设定及其依赖关系；其它的文件需要由main.yml进行“包含”调用；default/：此目录中至少应该有一个名为main.yml的文件，用于设定默认变量；</code></pre><p>准备目录结构</p><pre><code>mkdir roles/nginx/{files,handlers,tasks,templates,vars} -ptouch roles/site.yaml roles/nginx/{handlers,tasks,vars}/main.yamlecho tiger &gt; roles/nginx/files/index.htmlyum install -y nginx &amp;&amp; cp /etc/nginx/nginx.conf roles/nginx/templates/nginx.conf.j2</code></pre><h3 id="4-编写任务"><a href="#4-编写任务" class="headerlink" title="4.编写任务"></a>4.编写任务</h3><pre><code>vim roles/nginx/tasks/main.yaml---- name: install nginx packge  yum: name={{ item }} state=latest  with_items:  - epel-release  - nginx- name: copy index.html  copy: src=index.html dest=/usr/share/nginx/html/index.html- name: copy nginx.conf template  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf  notify: restart nginx- name: make sure nginx service running  service: name=nginx state=started enabled=yes</code></pre><h3 id="5-准备配置文件"><a href="#5-准备配置文件" class="headerlink" title="5.准备配置文件"></a>5.准备配置文件</h3><pre><code>vim roles/nginx/templates/nginx.conf.j2worker_processes  {{ ansible_processor_cores }};   //调用内部已知变量worker_connections {{ worker_connections }};    //自定义变量</code></pre><h3 id="6-编写变量"><a href="#6-编写变量" class="headerlink" title="6.编写变量"></a>6.编写变量</h3><pre><code>vim roles/nginx/vars/main.yamlworker_connections: 10240</code></pre><h3 id="7-编写处理程序"><a href="#7-编写处理程序" class="headerlink" title="7.编写处理程序"></a>7.编写处理程序</h3><pre><code>vim roles/nginx/handlers/main.yaml---- name: restart nginx  service: name=nginx state=restarted</code></pre><h3 id="8-编写剧本"><a href="#8-编写剧本" class="headerlink" title="8.编写剧本"></a>8.编写剧本</h3><pre><code>vim roles/site.yaml- hosts: host4  roles:  - nginx</code></pre><h3 id="9-实施"><a href="#9-实施" class="headerlink" title="9.实施"></a>9.实施</h3><pre><code>ansible-playbook site.yaml --syntax-check  //测试ansible-playbook site.yaml    //实施剧本</code></pre><p>验证hosts</p><p><a href="https://imgchr.com/i/0VbwkD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/28/0VbwkD.png" alt="0VbwkD.png"></a></p><p>引用变量案例：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># tree </span><span class="token keyword">.</span>├── site.yml├── templates│   └── order.j2└── vars    └── main.yml2 directories, 3 files</code></pre><p>总调度yml文件：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cat site.yml </span>---- hosts: 192.168.19.154  user: root  vars:  - PROJECT: <span class="token string">"JAVA"</span>    SWITCH: <span class="token string">"ON"</span>    DBPORT: <span class="token string">"8080"</span>  tasks:  - name: create<span class="token punctuation">{</span><span class="token punctuation">{</span> PROJECT <span class="token punctuation">}</span><span class="token punctuation">}</span>directory    file: path<span class="token operator">=</span>/data/<span class="token punctuation">{</span><span class="token punctuation">{</span> PROJECT <span class="token punctuation">}</span><span class="token punctuation">}</span> state<span class="token operator">=</span>directory  - name: template transfor java    template: src<span class="token operator">=</span>order.j2 dest<span class="token operator">=</span>/data/<span class="token punctuation">{</span><span class="token punctuation">{</span> PROJECT <span class="token punctuation">}</span><span class="token punctuation">}</span>/order.conf</code></pre><p>注意:这里 - role: template 和 - template 是一样的！</p><p>其他yml文件，如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cat templates/order.j2 </span>project: <span class="token punctuation">{</span><span class="token punctuation">{</span> PROJECT <span class="token punctuation">}</span><span class="token punctuation">}</span>switch: <span class="token punctuation">{</span><span class="token punctuation">{</span> SWITCH <span class="token punctuation">}</span><span class="token punctuation">}</span>dbport: <span class="token punctuation">{</span><span class="token punctuation">{</span> DBPORT <span class="token punctuation">}</span><span class="token punctuation">}</span>测试：<span class="token comment" spellcheck="true"># ansible-playbook templates.yml --syntax-check</span>playbook: templates.yml执行：PLAY <span class="token punctuation">[</span>192.168.19.154<span class="token punctuation">]</span> **********************************************************TASK <span class="token punctuation">[</span>Gathering Facts<span class="token punctuation">]</span> *********************************************************ok: <span class="token punctuation">[</span>192.168.19.154<span class="token punctuation">]</span>TASK <span class="token punctuation">[</span>createJAVAdirectory<span class="token punctuation">]</span> *****************************************************changed: <span class="token punctuation">[</span>192.168.19.154<span class="token punctuation">]</span>TASK <span class="token punctuation">[</span>template transfor java<span class="token punctuation">]</span> **************************************************changed: <span class="token punctuation">[</span>192.168.19.154<span class="token punctuation">]</span>PLAY RECAP *********************************************************************192.168.19.154             <span class="token keyword">:</span> ok<span class="token operator">=</span>3    changed<span class="token operator">=</span>2    unreachable<span class="token operator">=</span>0    failed<span class="token operator">=</span>0 <span class="token comment" spellcheck="true">#cat /data/JAVA/order.conf</span>project: JAVAswitch: ONdbport: 8080</code></pre>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible</title>
      <link href="2019/04/16/linux/ansible/"/>
      <url>2019/04/16/linux/ansible/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="自动化运维工具—ansible详解"><a href="#自动化运维工具—ansible详解" class="headerlink" title="自动化运维工具—ansible详解"></a>自动化运维工具—ansible详解</h1><h2 id="一、ansible-简介"><a href="#一、ansible-简介" class="headerlink" title="一、ansible 简介"></a>一、ansible 简介</h2><h3 id="1、ansible-是什么？"><a href="#1、ansible-是什么？" class="headerlink" title="1、ansible 是什么？"></a>1、ansible 是什么？</h3><p>　　ansible是目前最受运维欢迎的自动化运维工具，基于Python开发，集合了众多运维工具（SaltStack puppet、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。<br> 　　ansible是基于 paramiko 开发的,并且基于模块化工作，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。ansible不需要在远程主机上安装client/agents，因为它们是基于ssh来和远程主机通讯的。ansible目前已经已经被红帽官方收购，是自动化运维工具中大家认可度最高的，并且上手容易，学习简单。是每位运维工程师必须掌握的技能之一。</p><h3 id="2、ansible-特点"><a href="#2、ansible-特点" class="headerlink" title="2、ansible 特点"></a>2、ansible 特点</h3><ol><li>部署简单，只需在主控端部署Ansible环境，被控端无需做任何操作；</li><li>默认使用SSH协议对设备进行管理；</li><li>有大量常规运维操作模块，可实现日常绝大部分操作；</li><li>配置简单、功能强大、扩展性强；</li><li>支持API及自定义模块，可通过Python轻松扩展；</li><li>通过Playbooks来定制强大的配置、状态管理；</li><li>轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；</li><li>提供一个功能强大、操作性强的Web管理界面和REST API接口——AWX平台。</li></ol><h3 id="3、ansible-架构图"><a href="#3、ansible-架构图" class="headerlink" title="3、ansible 架构图"></a>3、ansible 架构图</h3><p><img src="https://s1.ax1x.com/2020/04/17/JEZyQO.png" alt="JEZyQO.png"></p><blockquote><p><code>Ansible</code>：Ansible核心程序。<br><code>HostInventory</code>：记录由Ansible管理的主机信息，包括端口、密码、ip等。<br><code>Playbooks</code>：“剧本”YAML格式文件，多个任务定义在一个文件中，定义主机需要调用哪些模块来完成的功能。<br><code>CoreModules</code>：<strong>核心模块</strong>，主要操作是通过调用核心模块来完成管理任务。<br><code>CustomModules</code>：自定义模块，完成核心模块无法完成的功能，支持多种语言。<br><code>ConnectionPlugins</code>：连接插件，Ansible和Host通信使用</p></blockquote><h2 id="二、ansible-任务执行"><a href="#二、ansible-任务执行" class="headerlink" title="二、ansible 任务执行"></a>二、ansible 任务执行</h2><h3 id="1、ansible-任务执行模式"><a href="#1、ansible-任务执行模式" class="headerlink" title="1、ansible 任务执行模式"></a>1、ansible 任务执行模式</h3><p>　　Ansible 系统由控制主机对被管节点的操作方式可分为两类，即<code>ad-hoc</code>和<code>playbook</code>：</p><ul><li>ad-hoc模式(点对点模式)<br>使用单个模块，支持批量执行单条命令。ad-hoc 命令是一种可以快速输入的命令，而且不需要保存起来的命令。<strong>就相当于bash中的一句话shell。</strong></li><li>playbook模式(剧本模式)<br>是Ansible主要管理方式，也是Ansible功能强大的关键所在。<strong>playbook通过多个task集合完成一类功能</strong>，如Web服务的安装部署、数据库服务器的批量备份等。可以简单地把playbook理解为通过组合多条ad-hoc操作的配置文件。</li></ul><h3 id="2、ansible-执行流程"><a href="#2、ansible-执行流程" class="headerlink" title="2、ansible 执行流程"></a>2、ansible 执行流程</h3><p> 　　简单理解就是Ansible在运行时， 首先读取<code>ansible.cfg</code>中的配置， 根据规则获取<code>Inventory</code>中的管理主机列表， 并行的在这些主机中执行配置的任务， 最后等待执行返回的结果。</p><h3 id="3、ansible-命令执行过程"><a href="#3、ansible-命令执行过程" class="headerlink" title="3、ansible 命令执行过程"></a>3、ansible 命令执行过程</h3><p><img src="https://s1.ax1x.com/2020/04/17/JEZ2eH.png" alt="JEZ2eH.png"></p><ol><li>加载自己的配置文件，默认<code>/etc/ansible/ansible.cfg</code>；</li><li>查找对应的主机配置文件，找到要执行的主机或者组；</li><li>加载自己对应的模块文件，如 command；</li><li>通过ansible将模块或命令生成对应的临时py文件(python脚本)， 并将该文件传输至远程服务器；</li><li>对应执行用户的家目录的<code>.ansible/tmp/XXX/XXX.PY</code>文件；</li><li>给文件 +x 执行权限；</li><li>执行并返回结果；</li><li>删除临时py文件，<code>sleep 0</code>退出；</li></ol><h2 id="三、ansible-配置详解"><a href="#三、ansible-配置详解" class="headerlink" title="三、ansible 配置详解"></a>三、ansible 配置详解</h2><h3 id="1、ansible-安装方式"><a href="#1、ansible-安装方式" class="headerlink" title="1、ansible 安装方式"></a>1、ansible 安装方式</h3><p>　　ansible安装常用两种方式，<code>yum 安装</code> 和 <code>pip 程序安装</code>。下面我们来详细介绍一下这两种安装方式。</p><h3 id="2、使用-pip（python的包管理模块）安装"><a href="#2、使用-pip（python的包管理模块）安装" class="headerlink" title="2、使用 pip（python的包管理模块）安装"></a>2、使用 pip（python的包管理模块）安装</h3><p>　　首先，我们需要安装一个<code>python-pip</code>包，安装完成以后，则直接使用<code>pip</code>命令来安装我们的包，具体操作过程如下：</p><pre><code>    yum install python-pip    pip install ansible</code></pre><h3 id="4、使用-yum-安装"><a href="#4、使用-yum-安装" class="headerlink" title="4、使用 yum 安装"></a>4、使用 yum 安装</h3><p>　　yum 安装是我们很熟悉的安装方式了。我们需要先安装一个<code>epel-release</code>包，然后再安装我们的 ansible 即可。</p><pre><code>    yum install epel-release -y    yum install ansible –y</code></pre><h3 id="5、ansible-程序结构"><a href="#5、ansible-程序结构" class="headerlink" title="5、ansible 程序结构"></a>5、ansible 程序结构</h3><p>安装目录如下(yum安装)：<br> 　   配置文件目录：/etc/ansible/<br>　　执行文件目录：/usr/bin/<br>　　Lib库依赖目录：/usr/lib/pythonX.X/site-packages/ansible/<br>　　Help文档目录：/usr/share/doc/ansible-X.X.X/<br>　　Man文档目录：/usr/share/man/man1/</p><h3 id="6、ansible配置文件查找顺序"><a href="#6、ansible配置文件查找顺序" class="headerlink" title="6、ansible配置文件查找顺序"></a>6、ansible配置文件查找顺序</h3><p>　　ansible与我们其他的服务在这一点上有很大不同，这里的配置文件查找是从多个地方找的，顺序如下：</p><ol><li>检查环境变量<code>ANSIBLE_CONFIG</code>指向的路径文件(export ANSIBLE_CONFIG=/etc/ansible.cfg)；</li><li><code>~/.ansible.cfg</code>，检查当前目录下的ansible.cfg配置文件；</li><li><code>/etc/ansible.cfg</code>检查etc目录的配置文件。</li></ol><h3 id="7、ansible配置文件"><a href="#7、ansible配置文件" class="headerlink" title="7、ansible配置文件"></a>7、ansible配置文件</h3><p>　　ansible 的配置文件为<code>/etc/ansible/ansible.cfg</code>，ansible 有许多参数，下面我们列出一些常见的参数：</p><pre><code>    inventory = /etc/ansible/hosts #这个参数表示资源清单inventory文件的位置    library = /usr/share/ansible   #指向存放Ansible模块的目录，支持多个目录方式，只要用冒号（：）隔开就可以    forks = 5       #并发连接数，默认为5    sudo_user = root        #设置默认执行命令的用户    remote_port = 22        #指定连接被管节点的管理端口，默认为22端口，建议修改，能够更加安全    host_key_checking = False #设置是否检查SSH主机的密钥，值为True/False。关闭后第一次连接不会提示配置实例    timeout = 60        #设置SSH连接的超时时间，单位为秒    log_path = /var/log/ansible.log     #指定一个存储ansible日志的文件（默认不记录日志）</code></pre><h3 id="8、ansuble主机清单"><a href="#8、ansuble主机清单" class="headerlink" title="8、ansuble主机清单"></a>8、ansuble主机清单</h3><p>　　在配置文件中，我们提到了资源清单，这个清单就是我们的主机清单，里面保存的是一些 ansible 需要连接管理的主机列表。我们可以来看看他的定义方式：</p><pre><code>1、 直接指明主机地址或主机名：    # green.example.com    # blue.example.com    # 192.168.100.1    # 192.168.100.102、 定义一个主机组[组名]把地址或主机名加进去    [mysql_test]    192.168.253.159    192.168.253.160    192.168.253.153</code></pre><p>　　需要注意的是，这里的组成员可以使用通配符来匹配，这样对于一些标准化的管理来说就很轻松方便了。<br> 　　我们可以根据实际情况来配置我们的主机列表，具体操作如下：</p><pre><code>[root@server ~]# vim /etc/ansible/hosts    [web]    192.168.37.122    192.168.37.133</code></pre><h2 id="四、ansible-常用命令"><a href="#四、ansible-常用命令" class="headerlink" title="四、ansible 常用命令"></a>四、ansible 常用命令</h2><h3 id="1、ansible-命令集"><a href="#1、ansible-命令集" class="headerlink" title="1、ansible 命令集"></a>1、ansible 命令集</h3><blockquote><p><code>/usr/bin/ansible</code>　　Ansibe AD-Hoc 临时命令执行工具，常用于临时命令的执行<br><code>/usr/bin/ansible-doc</code> 　　Ansible 模块功能查看工具<br><code>/usr/bin/ansible-galaxy</code>　　下载/上传优秀代码或Roles模块 的官网平台，基于网络的<br><code>/usr/bin/ansible-playbook</code>　　Ansible 定制自动化的任务集编排工具<br><code>/usr/bin/ansible-pull</code>　　Ansible远程执行命令的工具，拉取配置而非推送配置（使用较少，海量机器时使用，对运维的架构能力要求较高）<br><code>/usr/bin/ansible-vault</code>　　    Ansible 文件加密工具<br><code>/usr/bin/ansible-console</code>　　Ansible基于Linux Consoble界面可与用户交互的命令执行工具</p></blockquote><p>　　其中，我们比较常用的是<code>/usr/bin/ansible</code>和<code>/usr/bin/ansible-playbook</code>。</p><h3 id="2、ansible-doc-命令"><a href="#2、ansible-doc-命令" class="headerlink" title="2、ansible-doc 命令"></a>2、ansible-doc 命令</h3><p>　　ansible-doc 命令常用于获取模块信息及其使用帮助，一般用法如下：</p><pre><code>    ansible-doc -l              #获取全部模块的信息    ansible-doc -s MOD_NAME     #获取指定模块的使用帮助</code></pre><p>　　我们也可以查看一下ansible-doc的全部用法：</p><pre><code>[root@server ~]# ansible-docUsage: ansible-doc [options] [module...]Options:  -h, --help            show this help message and exit　　# 显示命令参数API文档  -l, --list            List available modules　　#列出可用的模块  -M MODULE_PATH, --module-path=MODULE_PATH　　#指定模块的路径                        specify path(s) to module library (default=None)  -s, --snippet         Show playbook snippet for specified module(s)　　#显示playbook制定模块的用法  -v, --verbose         verbose mode (-vvv for more, -vvvv to enable　　# 显示ansible-doc的版本号查看模块列表：                        connection debugging)  --version             show program&#39;s version number and exit</code></pre><p>　　我们可以来看一下，以mysql相关的为例：</p><pre><code>[root@server ~]# ansible-doc -l |grep mysqlmysql_db                           Add or remove MySQL databases from a remote...mysql_replication                  Manage MySQL replication                   mysql_user                         Adds or removes a user from a MySQL databas...mysql_variables                    Manage MySQL global variables      [root@server ~]# ansible-doc -s mysql_user</code></pre><h3 id="2、ansible-命令详解"><a href="#2、ansible-命令详解" class="headerlink" title="2、ansible 命令详解"></a>2、ansible 命令详解</h3><p>　　命令的具体格式如下：</p><pre><code>ansible &lt;host-pattern&gt; [-f forks] [-m module_name] [-a args]</code></pre><p>　　也可以通过<code>ansible -h</code>来查看帮助，下面我们列出一些比较常用的选项，并解释其含义：</p><blockquote><p><code>-a MODULE_ARGS</code> #模块的参数，如果执行默认COMMAND的模块，即是命令参数，如： “date”，“pwd”等等<br><code>-k</code>，<code>--ask-pass</code> #ask for SSH password。登录密码，提示输入SSH密码而不是假设基于密钥的验证<br><code>--ask-su-pass</code> #ask for su password。su切换密码<br><code>-K</code>，<code>--ask-sudo-pass</code> #ask for sudo password。提示密码使用sudo，sudo表示提权操作<br><code>--ask-vault-pass</code> #ask for vault password。假设我们设定了加密的密码，则用该选项进行访问<br><code>-B SECONDS</code> #后台运行超时时间<br><code>-C</code> #模拟运行环境并进行预运行，可以进行查错测试<br><code>-c CONNECTION</code> #连接类型使用<br><code>-f FORKS</code> #并行任务数，默认为5<br><code>-i INVENTORY</code> #指定主机清单的路径，默认为<code>/etc/ansible/hosts</code><br><code>--list-hosts</code> #查看有哪些主机组<br><code>-m MODULE_NAME</code> #执行模块的名字，默认使用 command 模块，所以如果是只执行单一命令可以不用 -m参数<br><code>-o</code> #压缩输出，尝试将所有结果在一行输出，一般针对收集工具使用<br><code>-S</code> #用 su 命令<br><code>-R SU_USER</code> #指定 su 的用户，默认为 root 用户<br><code>-s</code> #用 sudo 命令<br><code>-U SUDO_USER</code> #指定 sudo 到哪个用户，默认为 root 用户<br><code>-T TIMEOUT</code> #指定 ssh 默认超时时间，默认为10s，也可在配置文件中修改<br><code>-u REMOTE_USER</code> #远程用户，默认为 root 用户<br><code>-v</code> #查看详细信息，同时支持<code>-vvv</code>，<code>-vvvv</code>可查看更详细信息</p></blockquote><h3 id="3、ansible-配置公私钥"><a href="#3、ansible-配置公私钥" class="headerlink" title="3、ansible 配置公私钥"></a>3、ansible 配置公私钥</h3><p>　　上面我们已经提到过 ansible 是基于 ssh 协议实现的，所以其配置公私钥的方式与 ssh 协议的方式相同，具体操作步骤如下：</p><pre><code>#1.生成私钥[root@server ~]# ssh-keygen #2.向主机分发私钥[root@server ~]# ssh-copy-id root@192.168.37.122[root@server ~]# ssh-copy-id root@192.168.37.133</code></pre><p>　　这样的话，就可以实现无密码登录，我们的实验过程也会顺畅很多。<br> 　　注意，如果出现了一下报错：</p><pre><code>    -bash: ssh-copy-id: command not found</code></pre><p>　　那么就证明我们需要安装一个包：</p><pre><code>    yum -y install openssh-clientsansible</code></pre><p>　　把包安装上即可。</p><h2 id="五、ansible-常用模块"><a href="#五、ansible-常用模块" class="headerlink" title="五、ansible 常用模块"></a>五、ansible 常用模块</h2><h3 id="1、主机连通性测试"><a href="#1、主机连通性测试" class="headerlink" title="1、主机连通性测试"></a>1、主机连通性测试</h3><p>　　我们使用<code>ansible web -m ping</code>命令来进行主机连通性测试，效果如下：</p><pre><code>[root@server ~]# ansible web -m ping192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: false,     &quot;ping&quot;: &quot;pong&quot;}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: false,     &quot;ping&quot;: &quot;pong&quot;}</code></pre><p>　　这样就说明我们的主机是连通状态的。接下来的操作才可以正常进行。</p><h3 id="2、command-模块"><a href="#2、command-模块" class="headerlink" title="2、command 模块"></a>2、command 模块</h3><p>　　这个模块可以直接在远程主机上执行命令，并将结果返回本主机。<br> 　　举例如下：</p><pre><code>[root@server ~]# ansible web -m command -a &#39;ss -ntl&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN     0      128          *:111                      *:*                  LISTEN     0      5      192.168.122.1:53                       *:*                  LISTEN     0      128          *:22                       *:*                  LISTEN     0      128    127.0.0.1:631                      *:*                  LISTEN     0      128          *:23000                    *:*                  LISTEN     0      100    127.0.0.1:25                       *:*                  LISTEN     0      128         :::111                     :::*                  LISTEN     0      128         :::22                      :::*                  LISTEN     0      128        ::1:631                     :::*                  LISTEN     0      100        ::1:25                      :::*                  192.168.37.133 | SUCCESS | rc=0 &gt;&gt;State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN     0      128          *:111                      *:*                  LISTEN     0      128          *:22                       *:*                  LISTEN     0      128    127.0.0.1:631                      *:*                  LISTEN     0      128          *:23000                    *:*                  LISTEN     0      100    127.0.0.1:25                       *:*                  LISTEN     0      128         :::111                     :::*                  LISTEN     0      128         :::22                      :::*                  LISTEN     0      128        ::1:631                     :::*                  LISTEN     0      100        ::1:25                      :::*  </code></pre><p>　　命令模块接受命令名称，后面是空格分隔的列表参数。给定的命令将在所有选定的节点上执行。它不会通过shell进行处理，比如$HOME和操作如”&lt;”，”&gt;”，”|”，”;”，”&amp;” 工作（需要使用（shell）模块实现这些功能）。注意，该命令不支持<code>| 管道命令</code>。<br> 　　下面来看一看该模块下常用的几个命令：</p><blockquote><p>chdir　　　   # 在执行命令之前，先切换到该目录<br>executable    # 切换shell来执行命令，需要使用命令的绝对路径<br>free_form 　 # 要执行的Linux指令，一般使用Ansible的-a参数代替。<br>creates 　      # 一个文件名，当这个文件存在，则该命令不执行,可以用来做判断<br>removes        # 一个文件名，这个文件不存在，则该命令不执行</p></blockquote><p>　　下面我们来看看这些命令的执行效果：</p><pre><code>[root@server ~]# ansible web -m command -a &#39;chdir=/data/ ls&#39;  #先切换到/data/ 目录，再执行“ls”命令192.168.37.122 | SUCCESS | rc=0 &gt;&gt;aaa.jpgfastdfsmogdatatmpwebwKgleloeYoCAMLtZAAAWEekAtkc497.jpg192.168.37.133 | SUCCESS | rc=0 &gt;&gt;aaa.jpgfastdfsmogdatatmpwebwKgleloeYoCAMLtZAAAWEekAtkc497.jpg[root@server ~]# ansible web -m command -a &#39;creates=/data/aaa.jpg ls&#39;  #如果/data/aaa.jpg存在，则不执行“ls”命令192.168.37.122 | SUCCESS | rc=0 &gt;&gt;skipped, since /data/aaa.jpg exists192.168.37.133 | SUCCESS | rc=0 &gt;&gt;skipped, since /data/aaa.jpg exists[root@server ~]# ansible web -m command -a &#39;removes=/data/aaa.jpg cat /data/a&#39; #如果/data/aaa.jpg存在，则执行“cat /data/a”命令192.168.37.122 | SUCCESS | rc=0 &gt;&gt;hello192.168.37.133 | SUCCESS | rc=0 &gt;&gt;hello</code></pre><h3 id="3、shell-模块"><a href="#3、shell-模块" class="headerlink" title="3、shell 模块"></a>3、shell 模块</h3><p>　　shell模块可以在远程主机上调用shell解释器运行命令，支持shell的各种功能，例如管道等。</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;cat /etc/passwd |grep &quot;keer&quot;&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;keer:x:10001:1000:keer:/home/keer:/bin/sh192.168.37.133 | SUCCESS | rc=0 &gt;&gt;keer:x:10001:10001::/home/keer:/bin/sh</code></pre><p>　　只要是我们的shell命令，都可以通过这个模块在远程主机上运行，这里就不一一举例了。</p><h3 id="4、copy-模块"><a href="#4、copy-模块" class="headerlink" title="4、copy 模块"></a>4、copy 模块</h3><p>　　这个模块用于将文件复制到远程主机，同时支持给定内容生成文件和修改权限等。<br> 　　其相关选项如下：</p><blockquote><p><code>src</code>　　　　 #被复制到远程主机的本地文件。可以是绝对路径，也可以是相对路径。如果路径是一个目录，则会递归复制，用法类似于”rsync”<br><code>content</code>　　#用于替换”src”，可以直接指定文件的值<br><code>dest</code>　　　   #必选项，将源文件复制到的远程主机的<strong>绝对路径</strong><br><code>backup</code>　　　#当文件内容发生改变后，在覆盖之前把源文件备份，备份文件包含时间信息<br><code>directory_mode</code>　　　　#递归设定目录的权限，默认为系统默认权限<br><code>force</code>　　　　#当目标主机包含该文件，但内容不同时，设为”yes”，表示强制覆盖；设为”no”，表示目标主机的目标位置不存在该文件才复制。默认为”yes”<br><code>others</code>　　　　#所有的 file 模块中的选项可以在这里使用</p></blockquote><p>用法举例如下：<br><strong>① 复制文件：</strong></p><pre><code>[root@server ~]# ansible web -m copy -a &#39;src=~/hello dest=/data/hello&#39; 192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;checksum&quot;: &quot;22596363b3de40b06f981fb85d82312e8c0ed511&quot;,     &quot;dest&quot;: &quot;/data/hello&quot;,     &quot;gid&quot;: 0,     &quot;group&quot;: &quot;root&quot;,     &quot;md5sum&quot;: &quot;6f5902ac237024bdd0c176cb93063dc4&quot;,     &quot;mode&quot;: &quot;0644&quot;,     &quot;owner&quot;: &quot;root&quot;,     &quot;size&quot;: 12,     &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1512437093.55-228281064292921/source&quot;,     &quot;state&quot;: &quot;file&quot;,     &quot;uid&quot;: 0}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;checksum&quot;: &quot;22596363b3de40b06f981fb85d82312e8c0ed511&quot;,     &quot;dest&quot;: &quot;/data/hello&quot;,     &quot;gid&quot;: 0,     &quot;group&quot;: &quot;root&quot;,     &quot;md5sum&quot;: &quot;6f5902ac237024bdd0c176cb93063dc4&quot;,     &quot;mode&quot;: &quot;0644&quot;,     &quot;owner&quot;: &quot;root&quot;,     &quot;size&quot;: 12,     &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1512437093.74-44694985235189/source&quot;,     &quot;state&quot;: &quot;file&quot;,     &quot;uid&quot;: 0}</code></pre><p><strong>② 给定内容生成文件，并制定权限</strong></p><pre><code>[root@server ~]# ansible web -m copy -a &#39;content=&quot;I am keer\n&quot; dest=/data/name mode=666&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;checksum&quot;: &quot;0421570938940ea784f9d8598dab87f07685b968&quot;,     &quot;dest&quot;: &quot;/data/name&quot;,     &quot;gid&quot;: 0,     &quot;group&quot;: &quot;root&quot;,     &quot;md5sum&quot;: &quot;497fa8386590a5fc89090725b07f175c&quot;,     &quot;mode&quot;: &quot;0666&quot;,     &quot;owner&quot;: &quot;root&quot;,     &quot;size&quot;: 10,     &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1512437327.37-199512601767687/source&quot;,     &quot;state&quot;: &quot;file&quot;,     &quot;uid&quot;: 0}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;checksum&quot;: &quot;0421570938940ea784f9d8598dab87f07685b968&quot;,     &quot;dest&quot;: &quot;/data/name&quot;,     &quot;gid&quot;: 0,     &quot;group&quot;: &quot;root&quot;,     &quot;md5sum&quot;: &quot;497fa8386590a5fc89090725b07f175c&quot;,     &quot;mode&quot;: &quot;0666&quot;,     &quot;owner&quot;: &quot;root&quot;,     &quot;size&quot;: 10,         &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1512437327.55-218104039503110/source&quot;,     &quot;state&quot;: &quot;file&quot;,     &quot;uid&quot;: 0}</code></pre><p>　　我们现在可以去查看一下我们生成的文件及其权限：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;ls -l /data/&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;total 28-rw-rw-rw-   1 root root   12 Dec  6 09:45 name192.168.37.133 | SUCCESS | rc=0 &gt;&gt;total 40-rw-rw-rw- 1 root     root       12 Dec  5 09:45 name</code></pre><p>　　可以看出我们的name文件已经生成，并且权限为666。<br><strong>③ 关于覆盖</strong><br> 　　我们把文件的内容修改一下，然后选择覆盖备份：</p><pre><code>[root@server ~]# ansible web -m copy -a &#39;content=&quot;I am keerya\n&quot; backup=yes dest=/data/name mode=666&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;backup_file&quot;: &quot;/data/name.4394.2017-12-06@09:46:25~&quot;,     &quot;changed&quot;: true,     &quot;checksum&quot;: &quot;064a68908ab9971ee85dbc08ea038387598e3778&quot;,     &quot;dest&quot;: &quot;/data/name&quot;,     &quot;gid&quot;: 0,     &quot;group&quot;: &quot;root&quot;,     &quot;md5sum&quot;: &quot;8ca7c11385856155af52e560f608891c&quot;,     &quot;mode&quot;: &quot;0666&quot;,     &quot;owner&quot;: &quot;root&quot;,     &quot;size&quot;: 12,     &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1512438383.78-228128616784888/source&quot;,     &quot;state&quot;: &quot;file&quot;,     &quot;uid&quot;: 0}192.168.37.133 | SUCCESS =&gt; {    &quot;backup_file&quot;: &quot;/data/name.5962.2017-12-05@09:46:24~&quot;,     &quot;changed&quot;: true,     &quot;checksum&quot;: &quot;064a68908ab9971ee85dbc08ea038387598e3778&quot;,     &quot;dest&quot;: &quot;/data/name&quot;,     &quot;gid&quot;: 0,     &quot;group&quot;: &quot;root&quot;,     &quot;md5sum&quot;: &quot;8ca7c11385856155af52e560f608891c&quot;,     &quot;mode&quot;: &quot;0666&quot;,     &quot;owner&quot;: &quot;root&quot;,     &quot;size&quot;: 12,     &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1512438384.0-170718946740009/source&quot;,     &quot;state&quot;: &quot;file&quot;,     &quot;uid&quot;: 0}</code></pre><p>　　现在我们可以去查看一下：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;ls -l /data/&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;total 28-rw-rw-rw-   1 root root   12 Dec  6 09:46 name-rw-rw-rw-   1 root root   10 Dec  6 09:45 name.4394.2017-12-06@09:46:25~192.168.37.133 | SUCCESS | rc=0 &gt;&gt;total 40-rw-rw-rw- 1 root     root       12 Dec  5 09:46 name-rw-rw-rw- 1 root     root       10 Dec  5 09:45 name.5962.2017-12-05@09:46:24~</code></pre><p>　　可以看出，我们的源文件已经被备份，我们还可以查看一下<code>name</code>文件的内容：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;cat /data/name&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;I am keerya192.168.37.133 | SUCCESS | rc=0 &gt;&gt;I am keerya</code></pre><p>　　证明，这正是我们新导入的文件的内容。</p><h3 id="5、file-模块"><a href="#5、file-模块" class="headerlink" title="5、file 模块"></a>5、file 模块</h3><p>　　该模块主要用于设置文件的属性，比如创建文件、创建链接文件、删除文件等。<br> 　　下面是一些常见的命令：</p><blockquote><p><code>force</code>　　#需要在两种情况下强制创建软链接，一种是源文件不存在，但之后会建立的情况下；另一种是目标软链接已存在，需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no<br><code>group</code>　　#定义文件/目录的属组。后面可以加上<code>mode</code>：定义文件/目录的权限<br><code>owner</code>　　#定义文件/目录的属主。后面必须跟上<code>path</code>：定义文件/目录的路径<br><code>recurse</code>　　#递归设置文件的属性，只对目录有效，后面跟上<code>src</code>：被链接的源文件路径，只应用于<code>state=link</code>的情况<br><code>dest</code>　　#被链接到的路径，只应用于<code>state=link</code>的情况<br><code>state</code>　　#状态，有以下选项：</p><p><code>directory</code>：如果目录不存在，就创建目录<br><code>file</code>：即使文件不存在，也不会被创建<br><code>link</code>：创建软链接<br><code>hard</code>：创建硬链接<br><code>touch</code>：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间<br><code>absent</code>：删除目录、文件或者取消链接文件</p></blockquote><p>　　用法举例如下：<br><strong>① 创建目录：</strong></p><pre><code>[root@server ~]# ansible web -m file -a &#39;path=/data/app state=directory&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;gid&quot;: 0,     &quot;group&quot;: &quot;root&quot;,     &quot;mode&quot;: &quot;0755&quot;,     &quot;owner&quot;: &quot;root&quot;,     &quot;path&quot;: &quot;/data/app&quot;,     &quot;size&quot;: 6,     &quot;state&quot;: &quot;directory&quot;,     &quot;uid&quot;: 0}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;gid&quot;: 0,     &quot;group&quot;: &quot;root&quot;,     &quot;mode&quot;: &quot;0755&quot;,     &quot;owner&quot;: &quot;root&quot;,     &quot;path&quot;: &quot;/data/app&quot;,     &quot;size&quot;: 4096,     &quot;state&quot;: &quot;directory&quot;,     &quot;uid&quot;: 0}</code></pre><p>　　我们可以查看一下：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;ls -l /data&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;total 28drwxr-xr-x   2 root root    6 Dec  6 10:21 app192.168.37.133 | SUCCESS | rc=0 &gt;&gt;total 44drwxr-xr-x 2 root     root     4096 Dec  5 10:21 app</code></pre><p>　　可以看出，我们的目录已经创建完成。<br><strong>② 创建链接文件</strong></p><pre><code>[root@server ~]# ansible web -m file -a &#39;path=/data/bbb.jpg src=aaa.jpg state=link&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;dest&quot;: &quot;/data/bbb.jpg&quot;,     &quot;gid&quot;: 0,     &quot;group&quot;: &quot;root&quot;,     &quot;mode&quot;: &quot;0777&quot;,     &quot;owner&quot;: &quot;root&quot;,     &quot;size&quot;: 7,     &quot;src&quot;: &quot;aaa.jpg&quot;,     &quot;state&quot;: &quot;link&quot;,     &quot;uid&quot;: 0}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;dest&quot;: &quot;/data/bbb.jpg&quot;,     &quot;gid&quot;: 0,     &quot;group&quot;: &quot;root&quot;,     &quot;mode&quot;: &quot;0777&quot;,     &quot;owner&quot;: &quot;root&quot;,     &quot;size&quot;: 7,     &quot;src&quot;: &quot;aaa.jpg&quot;,     &quot;state&quot;: &quot;link&quot;,     &quot;uid&quot;: 0}</code></pre><p>　　我们可以去查看一下：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;ls -l /data&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;total 28-rw-r--r--   1 root root 5649 Dec  5 13:49 aaa.jpglrwxrwxrwx   1 root root    7 Dec  6 10:25 bbb.jpg -&gt; aaa.jpg192.168.37.133 | SUCCESS | rc=0 &gt;&gt;total 44-rw-r--r-- 1 root     root     5649 Dec  4 14:44 aaa.jpglrwxrwxrwx 1 root     root        7 Dec  5 10:25 bbb.jpg -&gt; aaa.jpg</code></pre><p>　　我们的链接文件已经创建成功。<br><strong>③ 删除文件</strong></p><pre><code>[root@server ~]# ansible web -m file -a &#39;path=/data/a state=absent&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;path&quot;: &quot;/data/a&quot;,     &quot;state&quot;: &quot;absent&quot;}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;path&quot;: &quot;/data/a&quot;,     &quot;state&quot;: &quot;absent&quot;}</code></pre><p>　　我们可以查看一下：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;ls /data/a&#39;192.168.37.122 | FAILED | rc=2 &gt;&gt;ls: cannot access /data/a: No such file or directory192.168.37.133 | FAILED | rc=2 &gt;&gt;ls: cannot access /data/a: No such file or directory</code></pre><p>　　发现已经没有这个文件了。</p><h3 id="6、fetch-模块"><a href="#6、fetch-模块" class="headerlink" title="6、fetch 模块"></a>6、fetch 模块</h3><p>　　该模块用于从远程某主机获取（复制）文件到本地。<br> 　　有两个选项：</p><blockquote><p><code>dest</code>：用来存放文件的目录<br><code>src</code>：在远程拉取的文件，并且必须是一个<strong>file</strong>，不能是<strong>目录</strong></p></blockquote><p>　　具体举例如下：</p><pre><code>[root@server ~]# ansible web -m fetch -a &#39;src=/data/hello dest=/data&#39;  192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;checksum&quot;: &quot;22596363b3de40b06f981fb85d82312e8c0ed511&quot;,     &quot;dest&quot;: &quot;/data/192.168.37.122/data/hello&quot;,     &quot;md5sum&quot;: &quot;6f5902ac237024bdd0c176cb93063dc4&quot;,     &quot;remote_checksum&quot;: &quot;22596363b3de40b06f981fb85d82312e8c0ed511&quot;,     &quot;remote_md5sum&quot;: null}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;checksum&quot;: &quot;22596363b3de40b06f981fb85d82312e8c0ed511&quot;,     &quot;dest&quot;: &quot;/data/192.168.37.133/data/hello&quot;,     &quot;md5sum&quot;: &quot;6f5902ac237024bdd0c176cb93063dc4&quot;,     &quot;remote_checksum&quot;: &quot;22596363b3de40b06f981fb85d82312e8c0ed511&quot;,     &quot;remote_md5sum&quot;: null}</code></pre><p>　　我们可以在本机上查看一下文件是否复制成功。要注意，文件保存的路径是我们设置的接收目录下的<code>被管制主机ip</code>目录下：</p><pre><code>[root@server ~]# cd /data/[root@server data]# ls1  192.168.37.122  192.168.37.133  fastdfs  web[root@server data]# cd 192.168.37.122[root@server 192.168.37.122]# lsdata[root@server 192.168.37.122]# cd data/[root@server data]# lshello[root@server data]# pwd/data/192.168.37.122/data</code></pre><h3 id="7、cron-模块"><a href="#7、cron-模块" class="headerlink" title="7、cron 模块"></a>7、cron 模块</h3><p>　　该模块适用于管理<code>cron</code>计划任务的。<br> 　　其使用的语法跟我们的<code>crontab</code>文件中的语法一致，同时，可以指定以下选项：</p><blockquote><p><code>day=</code>           #日应该运行的工作( 1-31, <em>,</em> /2, )<br><code>hour=</code>         # 小时 ( 0-23, <em>,</em> /2, )<br><code>minute=</code>     #分钟( 0-59, <em>,</em> /2, )<br><code>month=</code>       # 月( 1-12, *, /2, )<br><code>weekday=</code>       # 周 ( 0-6 for Sunday-Saturday,, )<br><code>job=</code>           #指明运行的命令是什么<br><code>name=</code>        #定时任务描述<br><code>reboot</code>      # 任务在重启时运行，不建议使用，建议使用special_time<br><code>special_time</code> #特殊的时间范围，参数：reboot（重启时），annually（每年），monthly（每月），weekly（每周），daily（每天），hourly（每小时）<br><code>state</code>        #指定状态，present表示添加定时任务，也是默认设置，absent表示删除定时任务<br><code>user</code>          # 以哪个用户的身份执行</p></blockquote><p>　　举例如下：<br><strong>① 添加计划任务</strong></p><pre><code>[root@server ~]# ansible web -m cron -a &#39;name=&quot;ntp update every 5 min&quot; minute=*/5 job=&quot;/sbin/ntpdate 172.17.0.1 &amp;&gt; /dev/null&quot;&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;envs&quot;: [],     &quot;jobs&quot;: [        &quot;ntp update every 5 min&quot;    ]}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;envs&quot;: [],     &quot;jobs&quot;: [        &quot;ntp update every 5 min&quot;    ]}</code></pre><p>　　我们可以去查看一下：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;crontab -l&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;#Ansible: ntp update every 5 min*/5 * * * * /sbin/ntpdate 172.17.0.1 &amp;&gt; /dev/null192.168.37.133 | SUCCESS | rc=0 &gt;&gt;#Ansible: ntp update every 5 min*/5 * * * * /sbin/ntpdate 172.17.0.1 &amp;&gt; /dev/null</code></pre><p>　　可以看出，我们的计划任务已经设置成功了。<br><strong>② 删除计划任务</strong><br> 　　如果我们的计划任务添加错误，想要删除的话，则执行以下操作：<br> 　　首先我们查看一下现有的计划任务：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;crontab -l&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;#Ansible: ntp update every 5 min*/5 * * * * /sbin/ntpdate 172.17.0.1 &amp;&gt; /dev/null#Ansible: df everyday* 15 * * * df -lh &gt;&gt; /tmp/disk_total &amp;&gt; /dev/null192.168.37.133 | SUCCESS | rc=0 &gt;&gt;#Ansible: ntp update every 5 min*/5 * * * * /sbin/ntpdate 172.17.0.1 &amp;&gt; /dev/null#Ansible: df everyday* 15 * * * df -lh &gt;&gt; /tmp/disk_total &amp;&gt; /dev/null</code></pre><p>　　然后执行删除操作：</p><pre><code>[root@server ~]# ansible web -m cron -a &#39;name=&quot;df everyday&quot; hour=15 job=&quot;df -lh &gt;&gt; /tmp/disk_total &amp;&gt; /dev/null&quot; state=absent&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;envs&quot;: [],     &quot;jobs&quot;: [        &quot;ntp update every 5 min&quot;    ]}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;envs&quot;: [],     &quot;jobs&quot;: [        &quot;ntp update every 5 min&quot;    ]}</code></pre><p>　　删除完成后，我们再查看一下现有的计划任务确认一下：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;crontab -l&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;#Ansible: ntp update every 5 min*/5 * * * * /sbin/ntpdate 172.17.0.1 &amp;&gt; /dev/null192.168.37.133 | SUCCESS | rc=0 &gt;&gt;#Ansible: ntp update every 5 min*/5 * * * * /sbin/ntpdate 172.17.0.1 &amp;&gt; /dev/null</code></pre><p>　　我们的删除操作已经成功。</p><h3 id="8、yum-模块"><a href="#8、yum-模块" class="headerlink" title="8、yum 模块"></a>8、yum 模块</h3><p>　　顾名思义，该模块主要用于软件的安装。<br> 　　其选项如下：</p><blockquote><p><code>name=</code>　　  #所安装的包的名称<br><code>state=</code>　　#<code>present</code>—&gt;安装， <code>latest</code>—&gt;安装最新的, <code>absent</code>—&gt; 卸载软件。<br><code>update_cache</code>　　#强制更新yum的缓存<br><code>conf_file</code>　　#指定远程yum安装时所依赖的配置文件（安装本地已有的包）。<br><code>disable_pgp_check</code>　　#是否禁止GPG checking，只用于<code>present</code>or <code>latest</code>。<br><code>disablerepo</code>　　#临时禁止使用yum库。 只用于安装或更新时。<br><code>enablerepo</code>　　 #临时使用的yum库。只用于安装或更新时。</p></blockquote><p>　　下面我们就来安装一个包试试看：</p><pre><code>[root@server ~]# ansible web -m yum -a &#39;name=htop state=present&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;msg&quot;: &quot;&quot;,     &quot;rc&quot;: 0,     &quot;results&quot;: [        &quot;Loaded plugins: fastestmirror, langpacks\nLoading mirror speeds from cached hostfile\nResolving Dependencies\n--&gt; Running transaction check\n---&gt; Package htop.x86_64 0:2.0.2-1.el7 will be installed\n--&gt; Finished Dependency Resolution\n\nDependencies Resolved\n\n================================================================================\n Package         Arch              Version                Repository       Size\n================================================================================\nInstalling:\n htop            x86_64            2.0.2-1.el7            epel             98 k\n\nTransaction Summary\n================================================================================\nInstall  1 Package\n\nTotal download size: 98 k\nInstalled size: 207 k\nDownloading packages:\nRunning transaction check\nRunning transaction test\nTransaction test succeeded\nRunning transaction\n  Installing : htop-2.0.2-1.el7.x86_64                                      1/1 \n  Verifying  : htop-2.0.2-1.el7.x86_64                                      1/1 \n\nInstalled:\n  htop.x86_64 0:2.0.2-1.el7                                                     \n\nComplete!\n&quot;    ]}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;msg&quot;: &quot;Warning: RPMDB altered outside of yum.\n** Found 3 pre-existing rpmdb problem(s), &#39;yum check&#39; output follows:\nipa-client-4.4.0-12.el7.centos.x86_64 has installed conflicts freeipa-client: ipa-client-4.4.0-12.el7.centos.x86_64\nipa-client-common-4.4.0-12.el7.centos.noarch has installed conflicts freeipa-client-common: ipa-client-common-4.4.0-12.el7.centos.noarch\nipa-common-4.4.0-12.el7.centos.noarch has installed conflicts freeipa-common: ipa-common-4.4.0-12.el7.centos.noarch\n&quot;,     &quot;rc&quot;: 0,     &quot;results&quot;: [        &quot;Loaded plugins: fastestmirror, langpacks\nLoading mirror speeds from cached hostfile\nResolving Dependencies\n--&gt; Running transaction check\n---&gt; Package htop.x86_64 0:2.0.2-1.el7 will be installed\n--&gt; Finished Dependency Resolution\n\nDependencies Resolved\n\n================================================================================\n Package         Arch              Version                Repository       Size\n================================================================================\nInstalling:\n htop            x86_64            2.0.2-1.el7            epel             98 k\n\nTransaction Summary\n================================================================================\nInstall  1 Package\n\nTotal download size: 98 k\nInstalled size: 207 k\nDownloading packages:\nRunning transaction check\nRunning transaction test\nTransaction test succeeded\nRunning transaction\n  Installing : htop-2.0.2-1.el7.x86_64                                      1/1 \n  Verifying  : htop-2.0.2-1.el7.x86_64                                      1/1 \n\nInstalled:\n  htop.x86_64 0:2.0.2-1.el7                                                     \n\nComplete!\n&quot;    ]}</code></pre><p>　　安装成功。</p><h3 id="9、service-模块"><a href="#9、service-模块" class="headerlink" title="9、service 模块"></a>9、service 模块</h3><p>　　该模块用于服务程序的管理。<br> 　　其主要选项如下：</p><blockquote><p><code>arguments</code> #命令行提供额外的参数<br><code>enabled</code>     #设置开机启动。<br><code>name=</code> #服务名称<br><code>runlevel</code> #开机启动的级别，一般不用指定。<br><code>sleep</code> #在重启服务的过程中，是否等待。如在服务关闭以后等待2秒再启动。(定义在剧本中。)<br><code>state</code> #有四种状态，分别为：<code>started</code>—&gt;启动服务， <code>stopped</code>—&gt;停止服务， <code>restarted</code>—&gt;重启服务， <code>reloaded</code>—&gt;重载配置</p></blockquote><p>　　下面是一些例子：<br><strong>① 开启服务并设置自启动</strong></p><pre><code>[root@server ~]# ansible web -m service -a &#39;name=nginx state=started enabled=true&#39; 192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;enabled&quot;: true,     &quot;name&quot;: &quot;nginx&quot;,     &quot;state&quot;: &quot;started&quot;,     ……}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;enabled&quot;: true,     &quot;name&quot;: &quot;nginx&quot;,     &quot;state&quot;: &quot;started&quot;,     ……}</code></pre><p>　　我们可以去查看一下端口是否打开：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;ss -ntl&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN     0      128          *:80                       *:*                                  192.168.37.133 | SUCCESS | rc=0 &gt;&gt;State      Recv-Q Send-Q Local Address:Port               Peer Address:Port                    LISTEN     0      128          *:80                       *:*                  </code></pre><p>　　可以看出我们的80端口已经打开。<br><strong>② 关闭服务</strong><br> 　　我们也可以通过该模块来关闭我们的服务：</p><pre><code>[root@server ~]# ansible web -m service -a &#39;name=nginx state=stopped&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;name&quot;: &quot;nginx&quot;,     &quot;state&quot;: &quot;stopped&quot;,     ……}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;name&quot;: &quot;nginx&quot;,     &quot;state&quot;: &quot;stopped&quot;,     ……}</code></pre><p>　　一样的，我们来查看一下端口：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;ss -ntl | grep 80&#39;192.168.37.122 | FAILED | rc=1 &gt;&gt;192.168.37.133 | FAILED | rc=1 &gt;&gt;</code></pre><p>　　可以看出，我们已经没有80端口了，说明我们的nginx服务已经关闭了。</p><h3 id="10、user-模块"><a href="#10、user-模块" class="headerlink" title="10、user 模块"></a>10、user 模块</h3><p>　　该模块主要是用来管理用户账号。<br> 　　其主要选项如下：</p><blockquote><p><code>comment</code>　　# 用户的描述信息<br><code>createhome</code>　　# 是否创建家目录<br><code>force</code>　　# 在使用state=absent时, 行为与userdel –force一致.<br><code>group</code>　　# 指定基本组<br><code>groups</code>　　# 指定附加组，如果指定为(groups=)表示删除所有组<br><code>home</code>　　    # 指定用户家目录<br><code>move_home</code>　　# 如果设置为home=时, 试图将用户主目录移动到指定的目录<br><code>name</code>　　# 指定用户名<br><code>non_unique</code>　　# 该选项允许改变非唯一的用户ID值<br><code>password</code>　　# 指定用户密码<br><code>remove</code>　　# 在使用state=absent时, 行为是与userdel –remove一致<br><code>shell</code>　　# 指定默认shell<br><code>state</code>　　# 设置帐号状态，不指定为创建，指定值为absent表示删除<br><code>system</code>　　# 当创建一个用户，设置这个用户是系统用户。这个设置不能更改现有用户<br><code>uid</code>　　# 指定用户的uid</p></blockquote><p>　　举例如下：<br><strong>① 添加一个用户并指定其 uid</strong></p><pre><code>[root@server ~]# ansible web -m user -a &#39;name=keer uid=11111&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;comment&quot;: &quot;&quot;,     &quot;createhome&quot;: true,     &quot;group&quot;: 11111,     &quot;home&quot;: &quot;/home/keer&quot;,     &quot;name&quot;: &quot;keer&quot;,     &quot;shell&quot;: &quot;/bin/bash&quot;,     &quot;state&quot;: &quot;present&quot;,     &quot;stderr&quot;: &quot;useradd: warning: the home directory already exists.\nNot copying any file from skel directory into it.\nCreating mailbox file: File exists\n&quot;,     &quot;system&quot;: false,     &quot;uid&quot;: 11111}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;comment&quot;: &quot;&quot;,     &quot;createhome&quot;: true,     &quot;group&quot;: 11111,     &quot;home&quot;: &quot;/home/keer&quot;,     &quot;name&quot;: &quot;keer&quot;,     &quot;shell&quot;: &quot;/bin/bash&quot;,     &quot;state&quot;: &quot;present&quot;,     &quot;stderr&quot;: &quot;useradd: warning: the home directory already exists.\nNot copying any file from skel directory into it.\nCreating mailbox file: File exists\n&quot;,     &quot;system&quot;: false,     &quot;uid&quot;: 11111}</code></pre><p>　　添加完成，我们可以去查看一下：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;cat /etc/passwd |grep keer&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;keer:x:11111:11111::/home/keer:/bin/bash192.168.37.133 | SUCCESS | rc=0 &gt;&gt;keer:x:11111:11111::/home/keer:/bin/bash</code></pre><p><strong>② 删除用户</strong></p><pre><code>[root@server ~]# ansible web -m user -a &#39;name=keer state=absent&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;force&quot;: false,     &quot;name&quot;: &quot;keer&quot;,     &quot;remove&quot;: false,     &quot;state&quot;: &quot;absent&quot;}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;force&quot;: false,     &quot;name&quot;: &quot;keer&quot;,     &quot;remove&quot;: false,     &quot;state&quot;: &quot;absent&quot;}</code></pre><p>　　一样的，删除之后，我们去看一下：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;cat /etc/passwd |grep keer&#39;192.168.37.122 | FAILED | rc=1 &gt;&gt;192.168.37.133 | FAILED | rc=1 &gt;&gt;</code></pre><p>　　发现已经没有这个用户了。</p><h3 id="11、group-模块"><a href="#11、group-模块" class="headerlink" title="11、group 模块"></a>11、group 模块</h3><p>　　该模块主要用于添加或删除组。<br> 　　常用的选项如下：</p><blockquote><p><code>gid=</code>　　#设置组的GID号<br><code>name=</code>　　#指定组的名称<br><code>state=</code>　　#指定组的状态，默认为创建，设置值为<code>absent</code>为删除<br><code>system=</code>　　#设置值为<code>yes</code>，表示创建为系统组</p></blockquote><p>　　举例如下：<br><strong>① 创建组</strong></p><pre><code>[root@server ~]# ansible web -m group -a &#39;name=sanguo gid=12222&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;gid&quot;: 12222,     &quot;name&quot;: &quot;sanguo&quot;,     &quot;state&quot;: &quot;present&quot;,     &quot;system&quot;: false}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;gid&quot;: 12222,     &quot;name&quot;: &quot;sanguo&quot;,     &quot;state&quot;: &quot;present&quot;,     &quot;system&quot;: false}</code></pre><p>　　创建过后，我们来查看一下：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;cat /etc/group | grep 12222&#39; 192.168.37.122 | SUCCESS | rc=0 &gt;&gt;sanguo:x:12222:192.168.37.133 | SUCCESS | rc=0 &gt;&gt;sanguo:x:12222:</code></pre><p>　　可以看出，我们的组已经创建成功了。<br><strong>② 删除组</strong></p><pre><code>[root@server ~]# ansible web -m group -a &#39;name=sanguo state=absent&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;name&quot;: &quot;sanguo&quot;,     &quot;state&quot;: &quot;absent&quot;}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;name&quot;: &quot;sanguo&quot;,     &quot;state&quot;: &quot;absent&quot;}</code></pre><p>　　照例查看一下：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;cat /etc/group | grep 12222&#39; 192.168.37.122 | FAILED | rc=1 &gt;&gt;192.168.37.133 | FAILED | rc=1 &gt;&gt;</code></pre><p>　　已经没有这个组的相关信息了。</p><h3 id="12、script-模块"><a href="#12、script-模块" class="headerlink" title="12、script 模块"></a>12、script 模块</h3><p>　　该模块用于将本机的脚本在被管理端的机器上运行。<br> 　　该模块直接指定脚本的路径即可，我们通过例子来看一看到底如何使用的：<br> 　　首先，我们写一个脚本，并给其加上执行权限：</p><pre><code>[root@server ~]# vim /tmp/df.sh    #!/bin/bash    date &gt;&gt; /tmp/disk_total.log    df -lh &gt;&gt; /tmp/disk_total.log [root@server ~]# chmod +x /tmp/df.sh </code></pre><p>　　然后，我们直接运行命令来实现在被管理端执行该脚本：</p><pre><code>[root@server ~]# ansible web -m script -a &#39;/tmp/df.sh&#39;192.168.37.122 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;rc&quot;: 0,     &quot;stderr&quot;: &quot;Shared connection to 192.168.37.122 closed.\r\n&quot;,     &quot;stdout&quot;: &quot;&quot;,     &quot;stdout_lines&quot;: []}192.168.37.133 | SUCCESS =&gt; {    &quot;changed&quot;: true,     &quot;rc&quot;: 0,     &quot;stderr&quot;: &quot;Shared connection to 192.168.37.133 closed.\r\n&quot;,     &quot;stdout&quot;: &quot;&quot;,     &quot;stdout_lines&quot;: []}</code></pre><p>　　照例查看一下文件内容：</p><pre class=" language-repl"><code class="language-repl">[root@server ~]# ansible web -m shell -a 'cat /tmp/disk_total.log'192.168.37.122 | SUCCESS | rc=0 >>Tue Dec  5 15:58:21 CST 2017Filesystem      Size  Used Avail Use% Mounted on/dev/sda2        47G  4.4G   43G  10% /devtmpfs        978M     0  978M   0% /devtmpfs           993M   84K  993M   1% /dev/shmtmpfs           993M  9.1M  984M   1% /runtmpfs           993M     0  993M   0% /sys/fs/cgroup/dev/sda3        47G   33M   47G   1% /app/dev/sda1       950M  153M  798M  17% /boottmpfs           199M   16K  199M   1% /run/user/42tmpfs           199M     0  199M   0% /run/user/0192.168.37.133 | SUCCESS | rc=0 >>Tue Dec  5 15:58:21 CST 2017Filesystem      Size  Used Avail Use% Mounted on/dev/sda2        46G  4.1G   40G  10% /devtmpfs        898M     0  898M   0% /devtmpfs           912M   84K  912M   1% /dev/shmtmpfs           912M  9.0M  903M   1% /runtmpfs           912M     0  912M   0% /sys/fs/cgroup/dev/sda3       3.7G   15M  3.4G   1% /app/dev/sda1       1.9G  141M  1.6G   9% /boottmpfs           183M   16K  183M   1% /run/user/42tmpfs           183M     0  183M   0% /run/user/0</code></pre><p>　　可以看出已经执行成功了。</p><h3 id="13、setup-模块"><a href="#13、setup-模块" class="headerlink" title="13、setup 模块"></a>13、setup 模块</h3><p>　　该模块主要用于收集信息，是通过调用facts组件来实现的。<br> 　　facts组件是Ansible用于采集被管机器设备信息的一个功能，我们可以使用setup模块查机器的所有facts信息，可以使用filter来查看指定信息。整个facts信息被包装在一个JSON格式的数据结构中，ansible_facts是最上层的值。<br> 　　facts就是变量，内建变量 。每个主机的各种信息，cpu颗数、内存大小等。会存在facts中的某个变量中。调用后返回很多对应主机的信息，在后面的操作中可以根据不同的信息来做不同的操作。如redhat系列用yum安装，而debian系列用apt来安装软件。<br><strong>① 查看信息</strong><br> 　　我们可以直接用命令获取到变量的值，具体我们来看看例子：</p><pre><code>[root@server ~]# ansible web -m setup -a &#39;filter=&quot;*mem*&quot;&#39;   #查看内存192.168.37.122 | SUCCESS =&gt; {    &quot;ansible_facts&quot;: {        &quot;ansible_memfree_mb&quot;: 1116,         &quot;ansible_memory_mb&quot;: {            &quot;nocache&quot;: {                &quot;free&quot;: 1397,                 &quot;used&quot;: 587            },             &quot;real&quot;: {                &quot;free&quot;: 1116,                 &quot;total&quot;: 1984,                 &quot;used&quot;: 868            },             &quot;swap&quot;: {                &quot;cached&quot;: 0,                 &quot;free&quot;: 3813,                 &quot;total&quot;: 3813,                 &quot;used&quot;: 0            }        },         &quot;ansible_memtotal_mb&quot;: 1984    },     &quot;changed&quot;: false}192.168.37.133 | SUCCESS =&gt; {    &quot;ansible_facts&quot;: {        &quot;ansible_memfree_mb&quot;: 1203,         &quot;ansible_memory_mb&quot;: {            &quot;nocache&quot;: {                &quot;free&quot;: 1470,                 &quot;used&quot;: 353            },             &quot;real&quot;: {                &quot;free&quot;: 1203,                 &quot;total&quot;: 1823,                 &quot;used&quot;: 620            },             &quot;swap&quot;: {                &quot;cached&quot;: 0,                 &quot;free&quot;: 3813,                 &quot;total&quot;: 3813,                 &quot;used&quot;: 0            }        },         &quot;ansible_memtotal_mb&quot;: 1823    },     &quot;changed&quot;: false}</code></pre><p>　　我们可以通过命令查看一下内存的大小以确认一下是否一致：</p><pre><code>[root@server ~]# ansible web -m shell -a &#39;free -m&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;              total        used        free      shared  buff/cache   availableMem:           1984         404        1122           9         457        1346Swap:          3813           0        3813192.168.37.133 | SUCCESS | rc=0 &gt;&gt;              total        used        free      shared  buff/cache   availableMem:           1823         292        1207           9         323        1351Swap:          3813           0        3813</code></pre><p>　　可以看出信息是一致的。<br><strong>② 保存信息</strong><br> 　　我们的setup模块还有一个很好用的功能就是可以保存我们所筛选的信息至我们的主机上，同时，文件名为我们被管制的主机的IP，这样方便我们知道是哪台机器出的问题。<br> 　　我们可以看一看例子：</p><pre><code>[root@server tmp]# ansible web -m setup -a &#39;filter=&quot;*mem*&quot;&#39; --tree /tmp/facts192.168.37.122 | SUCCESS =&gt; {    &quot;ansible_facts&quot;: {        &quot;ansible_memfree_mb&quot;: 1115,         &quot;ansible_memory_mb&quot;: {            &quot;nocache&quot;: {                &quot;free&quot;: 1396,                 &quot;used&quot;: 588            },             &quot;real&quot;: {                &quot;free&quot;: 1115,                 &quot;total&quot;: 1984,                 &quot;used&quot;: 869            },             &quot;swap&quot;: {                &quot;cached&quot;: 0,                 &quot;free&quot;: 3813,                 &quot;total&quot;: 3813,                 &quot;used&quot;: 0            }        },         &quot;ansible_memtotal_mb&quot;: 1984    },     &quot;changed&quot;: false}192.168.37.133 | SUCCESS =&gt; {    &quot;ansible_facts&quot;: {        &quot;ansible_memfree_mb&quot;: 1199,         &quot;ansible_memory_mb&quot;: {            &quot;nocache&quot;: {                &quot;free&quot;: 1467,                 &quot;used&quot;: 356            },             &quot;real&quot;: {                &quot;free&quot;: 1199,                 &quot;total&quot;: 1823,                 &quot;used&quot;: 624            },             &quot;swap&quot;: {                &quot;cached&quot;: 0,                 &quot;free&quot;: 3813,                 &quot;total&quot;: 3813,                 &quot;used&quot;: 0            }        },         &quot;ansible_memtotal_mb&quot;: 1823    },     &quot;changed&quot;: false}</code></pre><p>　　然后我们可以去查看一下：</p><pre><code>[root@server ~]# cd /tmp/facts/[root@server facts]# ls192.168.37.122  192.168.37.133[root@server facts]# cat 192.168.37.122 {&quot;ansible_facts&quot;: {&quot;ansible_memfree_mb&quot;: 1115, &quot;ansible_memory_mb&quot;: {&quot;nocache&quot;: {&quot;free&quot;: 1396, &quot;used&quot;: 588}, &quot;real&quot;: {&quot;free&quot;: 1115, &quot;total&quot;: 1984, &quot;used&quot;: 869}, &quot;swap&quot;: {&quot;cached&quot;: 0, &quot;free&quot;: 3813, &quot;total&quot;: 3813, &quot;used&quot;: 0}}, &quot;ansible_memtotal_mb&quot;: 1984}, &quot;changed&quot;: false}</code></pre><h2 id="六、Ansible-playbook-简介"><a href="#六、Ansible-playbook-简介" class="headerlink" title="六、Ansible playbook 简介"></a>六、Ansible playbook 简介</h2><p>　　<strong>playbook 是 ansible 用于配置，部署，和管理被控节点的剧本。</strong><br>　　通过 playbook 的详细描述，执行其中的一系列 tasks ，可以让远端主机达到预期的状态。playbook 就像 Ansible 控制器给被控节点列出的的一系列 to-do-list ，而被控节点必须要完成。<br>　　也可以这么理解，playbook 字面意思，即剧本，现实中由演员按照剧本表演，在Ansible中，这次由计算机进行表演，由计算机安装，部署应用，提供对外服务，以及组织计算机处理各种各样的事情。</p><h2 id="七、Ansible-playbook使用场景"><a href="#七、Ansible-playbook使用场景" class="headerlink" title="七、Ansible playbook使用场景"></a>七、Ansible playbook使用场景</h2><p>　　执行一些简单的任务，使用ad-hoc命令可以方便的解决问题，但是有时一个设施过于复杂，需要大量的操作时候，执行的ad-hoc命令是不适合的，这时最好使用playbook。<br>　　就像执行shell命令与写shell脚本一样，也可以理解为批处理任务，不过playbook有自己的语法格式。<br>　　使用playbook你可以方便的重用这些代码，可以移植到不同的机器上面，像函数一样，最大化的利用代码。在你使用Ansible的过程中，你也会发现，你所处理的大部分操作都是编写playbook。可以把常见的应用都编写成playbook，之后管理服务器会变得十分简单。</p><h2 id="八、Ansible-playbook格式"><a href="#八、Ansible-playbook格式" class="headerlink" title="八、Ansible playbook格式"></a>八、Ansible playbook格式</h2><h3 id="1、格式简介"><a href="#1、格式简介" class="headerlink" title="1、格式简介"></a>1、格式简介</h3><p>　　<strong>playbook由YMAL语言编写。</strong>YAML( /ˈjæməl/ )参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822，Clark Evans在2001年5月在首次发表了这种语言，另外Ingy döt Net与OrenBen-Kiki也是这语言的共同设计者。<br>　　YMAL格式是类似于JSON的文件格式，便于人理解和阅读，同时便于书写。首先学习了解一下YMAL的格式，对我们后面书写playbook很有帮助。以下为playbook常用到的YMAL格式：<br>　　1、文件的第一行应该以 “—“ (三个连字符)开始，表明YMAL文件的开始。<br>　　2、在同一行中，#之后的内容表示注释，类似于shell，python和ruby。<br>　　3、YMAL中的列表元素以”-”开头然后紧跟着一个空格，后面为元素内容。<br>　　4、同一个列表中的元素应该保持相同的缩进。否则会被当做错误处理。<br>　　5、play中hosts，variables，roles，tasks等对象的表示方法都是键值中间以”:”分隔表示，”:”后面还要增加一个空格。<br>　　下面是一个举例：</p><pre><code>---#安装与运行mysql服务- hosts: node1  remote_user: root  tasks:      - name: install mysql-server package      yum: name=mysql-server state=present    - name: starting mysqld service      service: name=mysql state=started</code></pre><p>　　我们的文件名称应该以<code>.yml</code>结尾，像我们上面的例子就是<code>mysql.yml</code>。其中，有三个部分组成：</p><blockquote><p><code>host部分</code>：使用 hosts 指示使用哪个主机或主机组来运行下面的 tasks ，每个 playbook 都必须指定 hosts ，hosts也<strong>可以使用通配符格式</strong>。主机或主机组在 inventory 清单中指定，可以使用系统默认的<code>/etc/ansible/hosts</code>，也可以自己编辑，在运行的时候加上<code>-i</code>选项，指定清单的位置即可。在运行清单文件的时候，<code>–list-hosts</code>选项会显示那些主机将会参与执行 task 的过程中。<br><code>remote_user</code>：指定远端主机中的哪个用户来登录远端系统，在远端系统执行 task 的用户，可以任意指定，也可以使用 sudo，但是用户必须要有执行相应 task 的权限。<br><code>tasks</code>：指定远端主机将要执行的一系列动作。tasks 的核心为 ansible 的模块，前面已经提到模块的用法。tasks 包含 <code>name</code> 和<code>要执行的模块</code>，name 是可选的，只是为了便于用户阅读，不过还是建议加上去，模块是必须的，同时也要给予模块相应的参数。</p></blockquote><p>　　使用ansible-playbook运行playbook文件，得到如下输出信息，输出内容为JSON格式。并且由不同颜色组成，便于识别。一般而言<br>| 绿色代表执行成功，系统保持原样<br>| 黄色代表系统代表系统状态发生改变<br>| 红色代表执行失败，显示错误输出<br>　　执行有三个步骤：1、收集facts  2、执行tasks  3、报告结果</p><h3 id="2、核心元素"><a href="#2、核心元素" class="headerlink" title="2、核心元素"></a>2、核心元素</h3><p>　　Playbook的核心元素：</p><blockquote><p><code>Hosts</code>：主机组；<br><code>Tasks</code>：任务列表；<br><code>Variables</code>：变量，设置方式有四种；<br><code>Templates</code>：包含了模板语法的文本文件；<br><code>Handlers</code>：由特定条件触发的任务；</p></blockquote><h3 id="3、基本组件"><a href="#3、基本组件" class="headerlink" title="3、基本组件"></a>3、基本组件</h3><p>　　Playbooks配置文件的基础组件：</p><blockquote><p><code>Hosts</code>：运行指定任务的目标主机<br><code>remote_user</code>：在远程主机上执行任务的用户；<br><code>sudo_user</code>：<br><code>tasks</code>：任务列表</p><p>　　格式：<br>　　　　tasks：<br>　　　　　　– name: TASK_NAME<br>　　　　　　 module: arguments<br>　　　　　　 notify: HANDLER_NAME<br>　　　　　　 handlers:<br>　　　　　　– name: HANDLER_NAME<br>　　　　　　 module: arguments</p></blockquote><blockquote><p><code>模块，模块参数</code>：</p><p>　　格式：<br>　　　　(1) action: module arguments<br>　　　　(2) module: arguments<br>　　　　注意：shell和command模块后面直接跟命令，而非key=value类的参数列表；</p></blockquote><blockquote><p><code>handlers</code>：任务，在特定条件下触发；接收到其它任务的通知时被触发；</p></blockquote><p>　　(1) 某任务的状态在运行后为changed时，可通过“notify”通知给相应的handlers；<br>　　(2) 任务可以通过“tags“打标签，而后可在ansible-playbook命令上使用-t指定进行调用；</p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p><strong>① 定义playbook</strong></p><pre><code>[root@server ~]# cd /etc/ansible[root@server ansible]# vim nginx.yml---- hosts: web  remote_user: root  tasks:    - name: install nginx      yum: name=nginx state=present    - name: copy nginx.conf      copy: src=/tmp/nginx.conf dest=/etc/nginx/nginx.conf backup=yes      notify: reload　　　　#当nginx.conf发生改变时，通知给相应的handlers      tags: reloadnginx　　　#打标签    - name: start nginx service      service: name=nginx state=started      tags: startnginx　　　#打标签  handlers:　　#注意，前面没有-，是两个空格    - name: reload      service: name=nginx state=restarted　　#为了在进程中能看出来</code></pre><p><strong>② 测试运行结果</strong><br>　　写完了以后，我们就可以运行了：</p><pre><code>[root@server ansible]# ansible-playbook nginx.yml</code></pre><p>　　现在我们可以看看两台机器的端口是否开启：</p><pre><code>[root@server ansible]# ansible web -m shell -a &#39;ss -nutlp |grep nginx&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;tcp    LISTEN     0      128       *:80                    *:*                   users:((&quot;nginx&quot;,pid=8304,fd=6),(&quot;nginx&quot;,pid=8303,fd=6))192.168.37.133 | SUCCESS | rc=0 &gt;&gt;tcp    LISTEN     0      128       *:80                    *:*                   users:((&quot;nginx&quot;,pid=9671,fd=6),(&quot;nginx&quot;,pid=9670,fd=6))</code></pre><p><strong>③ 测试标签</strong><br>　　我们在里面已经打上了一个标签，所以可以直接引用标签。但是我们需要先把服务关闭，再来运行剧本并引用标签：</p><pre><code>[root@server ansible]# ansible web -m shell -a &#39;systemctl stop nginx&#39;[root@server ansible]# ansible-playbook nginx.yml -t startnginx</code></pre><p><strong>④ 测试notify</strong><br>　　我们还做了一个<code>notify</code>，来测试一下：<br>　　首先，它的触发条件是配置文件被改变，所以我们去把配置文件中的端口改一下：</p><pre><code>[root@server ansible]# vim /tmp/nginx.conf    listen       8080;</code></pre><p>　　然后我们重新加载一下这个剧本：</p><pre><code> [root@server ansible]# ansible-playbook nginx.yml -t reloadnginx</code></pre><p>　　发现我们执行的就是reload段以及我们定义的<code>notify</code>部分。<br>　　我们来看一看我们的端口号：</p><p>　　发现我们执行的就是reload段以及我们定义的<code>notify</code>部分。<br>　　我们来看一看我们的端口号：</p><pre><code>[root@server ansible]# ansible web -m shell -a &#39;ss -ntlp | grep nginx&#39;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;LISTEN     0      128          *:8080                     *:*                   users:((&quot;nginx&quot;,pid=2097,fd=6),(&quot;nginx&quot;,pid=2096,fd=6))192.168.37.133 | SUCCESS | rc=0 &gt;&gt;LISTEN     0      128          *:8080                     *:*                   users:((&quot;nginx&quot;,pid=3061,fd=6),(&quot;nginx&quot;,pid=3060,fd=6))</code></pre><p>　　可以看出，我们的nginx端口已经变成了8080。　　</p><h3 id="4、variables-部分"><a href="#4、variables-部分" class="headerlink" title="4、variables 部分"></a>4、variables 部分</h3><p>　　上文中，我们说到了<code>variables</code>是变量，有四种定义方法，现在我们就来说说这四种定义方法：</p><h4 id="①-facts-：可直接调用"><a href="#①-facts-：可直接调用" class="headerlink" title="① facts ：可直接调用"></a>① facts ：可直接调用</h4><p>　　上一篇中，我们有说到<code>setup</code>这个模块，这个模块就是通过调用facts组件来实现的。我们这里的<code>variables</code>也可以直接调用<code>facts</code>组件。<br>　　具体的<code>facters</code>我们可以使用<code>setup</code>模块来获取，然后直接放入我们的剧本中调用即可。</p><pre><code>ansible_all_ipv4_addresses：仅显示ipv4的信息 ---&gt; [u&#39;192.168.95.143&#39;]ansible_eth0[&#39;ipv4&#39;][&#39;address&#39;]：仅显示ipv4的信息 ---&gt; eth0 的ip地址ansible_devices：仅显示磁盘设备信息ansible_distribution：显示是什么系统，例：centos,suse等ansible_distribution_version：仅显示系统版本ansible_machine：显示系统类型，例：32位，还是64位ansible_eth0：仅显示eth0的信息ansible_hostname：仅显示主机名ansible_kernel：仅显示内核版本ansible_lvm：显示lvm相关信息ansible_memtotal_mb：显示系统总内存ansible_memfree_mb：显示可用系统内存ansible_memory_mb：详细显示内存情况ansible_swaptotal_mb：显示总的swap内存ansible_swapfree_mb：显示swap内存的可用内存ansible_mounts：显示系统磁盘挂载情况ansible_processor：显示cpu个数(具体显示每个cpu的型号)ansible_processor_vcpus：显示cpu个数(只显示总的个数)ansible_python_version：显示python版本</code></pre><p>例如：批量修改主机 host 文件</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> web    <span class="token key atrule">vars</span><span class="token punctuation">:</span>            <span class="token key atrule">IP</span><span class="token punctuation">:</span> <span class="token string">"{{ ansible_eth0['ipv4']['address'] }}"</span>    <span class="token key atrule">tasks</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> 将原有的hosts文件备份              <span class="token key atrule">shell</span><span class="token punctuation">:</span> mv /etc/hosts /etc/hosts_bak          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> 将ansible端的hosts复制到各自机器上              <span class="token key atrule">copy</span><span class="token punctuation">:</span> src=/root/hosts dest=/etc/ owner=root group=root mode=0644          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> 在新的hosts文件后面追加各自机器内网ip和hostname              <span class="token key atrule">lineinfile</span><span class="token punctuation">:</span> dest=/etc/hosts line="<span class="token punctuation">{</span><span class="token punctuation">{</span> IP <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span> ansible_hostname <span class="token punctuation">}</span><span class="token punctuation">}</span>"</code></pre><h4 id="②-用户自定义变量"><a href="#②-用户自定义变量" class="headerlink" title="② 用户自定义变量"></a>② 用户自定义变量</h4><p>　　我们也可以直接使用用户自定义变量，想要自定义变量有以下两种方式：</p><blockquote><p>通过命令行传入</p></blockquote><p>　　<code>ansible-playbook</code>命令的命令行中的<code>-e VARS, --extra-vars=VARS</code>，这样就可以直接把自定义的变量传入。</p><blockquote><p>在playbook中定义变量</p></blockquote><p>　　我们也可以直接在playbook中定义我们的变量：</p><pre><code>vars:　　- var1: value1　　- var2: value2</code></pre><h5 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h5><p><strong>① 定义剧本</strong><br>　　我们就使用全局替换把我们刚刚编辑的文件修改一下：</p><pre><code>[root@server ansible]# vim nginx.yml</code></pre><p><img src="https://s1.ax1x.com/2020/04/16/JEZEz8.png" alt="JEZEz8.png"><br><img src="https://s1.ax1x.com/2020/04/16/JEZmLQ.png" alt="JEZmLQ.png">　　这样一来，我们的剧本就定义完成了。<br><strong>② 拷贝配置文件</strong><br>　　我们想要在被监管的机器上安装什么服务的话，就直接在我们的server端上把该服务的配置文件拷贝到我们的<code>/tmp/</code>目录下。这样我们的剧本才能正常运行。<br>　　我们就以<code>keepalived</code>服务为例：</p><pre class=" language-shell"><code class="language-shell">[root@server ansible]# cp /etc/keepalived/keepalived.conf /tmp/keepalived.conf</code></pre><p><strong>③ 运行剧本，变量由命令行传入</strong></p><pre><code>[root@server ansible]# ansible-playbook nginx.yml -e rpmname=keepalived</code></pre><p><img src="https://s1.ax1x.com/2020/04/16/JEZKds.png" alt="JEZKds.png"><br><strong>④ 修改剧本，直接定义变量</strong><br>　　同样的，我们可以直接在剧本中把变量定义好，这样就不需要在通过命令行传入了。以后想要安装不同的服务，直接在剧本里把变量修改一下即可。</p><pre><code>[root@server ansible]# vim nginx.yml</code></pre><p>![img](E:/学习晋升文件汇总/Linux架构学习入门/4. network_manager/19-20天-企业自动化运维工具Aansible实战/assets/1204916-20171208112356562-1275040347.png)<br><strong>⑤ 运行定义过变量的剧本</strong><br>　　我们刚刚已经把变量定义在剧本里面了。现在我们来运行一下试试看：</p><pre><code>[root@server ansible]# ansible-playbook nginx.yml</code></pre><p><img src="https://s1.ax1x.com/2020/04/16/JEZMon.png" alt="JEZMon.png"><br>　　发现这样也是可以的~</p><h4 id="③-通过roles传递变量"><a href="#③-通过roles传递变量" class="headerlink" title="③ 通过roles传递变量"></a>③ 通过roles传递变量</h4><p>　　具体的，我们下文中说到 roles 的时候再详细说明。</p><h4 id="④-Host-Inventory"><a href="#④-Host-Inventory" class="headerlink" title="④ Host Inventory"></a>④ Host Inventory</h4><p>　　我们也可以直接在主机清单中定义。<br>　　定义的方法如下：</p><blockquote><p>向不同的主机传递不同的变量：</p></blockquote><pre><code>　　IP/HOSTNAME varaiable=value var2=value2</code></pre><blockquote><p>向组中的主机传递相同的变量：</p></blockquote><pre><code>　　[groupname:vars]　　variable=value</code></pre><p>Ansible Inventory 内置参数</p><p>![Ansible Inventory 内置参数](E:/学习晋升文件汇总/Linux架构学习入门/4. network_manager/19-20天-企业自动化运维工具Aansible实战/assets/Ansible Inventory 内置参数.png)</p><p>使用内置变量把用户名密码写在Inventory中，也就是/etc/ansible/hosts文件里，缺点就是<strong>暴露了账号密码</strong>，不安全。如果有多个主机需要使用同样的变量，可以用组变量的形式，书写格式如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">[</span>web<span class="token punctuation">]</span>192.168.100.10192.168.100.11192.168.100.12 <span class="token punctuation">[</span>web<span class="token punctuation">:</span>vars<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#给名为webservers的组定义一个变量，:vars是固定格式</span>ansible_ssh_port=22ansible_ssh_user='root'ansible_ssh_pass='1234.com'</code></pre><h3 id="5、模板-templates"><a href="#5、模板-templates" class="headerlink" title="5、模板 templates"></a>5、模板 templates</h3><p>　　模板是一个文本文件，嵌套有脚本（使用模板编程语言编写）。<br>　　<code>Jinja2</code>：Jinja2是python的一种模板语言，以Django的模板语言为原本。<br>模板支持：</p><pre><code>　　字符串：使用单引号或双引号；　　数字：整数，浮点数；　　列表：[item1, item2, ...]　　元组：(item1, item2, ...)　　字典：{key1:value1, key2:value2, ...}　　布尔型：true/false　　算术运算：　　　　+, -, *, /, //, %, **　　比较操作：　　　　==, !=, &gt;, &gt;=, &lt;, &lt;=　　逻辑运算：　　　　and, or, not</code></pre><p>　　通常来说，模板都是通过引用变量来运用的。</p><h5 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h5><p><strong>① 定义模板</strong><br>　　我们直接把之前定义的<code>/tmp/nginx.conf</code>改个名，然后编辑一下，就可以定义成我们的模板文件了：</p><pre><code>[root@server ansible]# cd /tmp[root@server tmp]# mv nginx.conf nginx.conf.j2[root@server tmp]# vim nginx.conf.j2    worker_processes  {{ ansible_processor_vcpus }};    listen       {{ nginxport }};</code></pre><p><strong>② 修改剧本</strong><br>　　我们现在需要去修改剧本来定义变量：</p><pre><code>[root@server ansible]# vim nginx.yml</code></pre><p><a href="https://imgchr.com/i/JEZtL4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/16/JEZtL4.png" alt="JEZtL4.png"></a><br>　　需要修改的部分如图所示。</p><p>  copy 也需要修改为 template</p><p><strong>③ 运行剧本</strong><br>　　上面的准备工作完成后，我们就可以去运行剧本了：</p><pre><code>[root@server ansible]# ansible-playbook nginx.yml -t reloadnginxPLAY [web] *********************************************************************TASK [setup] *******************************************************************ok: [192.168.37.122]ok: [192.168.37.133]TASK [copy nginx.conf] *********************************************************ok: [192.168.37.122]ok: [192.168.37.133]PLAY RECAP *********************************************************************192.168.37.122             : ok=2    changed=0    unreachable=0    failed=0   192.168.37.133             : ok=2    changed=0    unreachable=0    failed=0 </code></pre><h3 id="6、条件测试"><a href="#6、条件测试" class="headerlink" title="6、条件测试"></a>6、条件测试</h3><p>when语句：在task中使用，jinja2的语法格式。<br>举例如下：</p><pre><code>tasks:- name: install conf file to centos7  template: src=files/nginx.conf.c7.j2  when: ansible_distribution_major_version == &quot;7&quot;- name: install conf file to centos6  template: src=files/nginx.conf.c6.j2  when: ansible_distribution_major_version == &quot;6&quot;</code></pre><p>循环：迭代，需要重复执行的任务；<br>　　对迭代项的引用，固定变量名为”item”，而后，要在task中使用with_items给定要迭代的元素列表；<br>举例如下：</p><pre><code>tasks:- name: unstall web packages  yum: name={{ item }} state=absent  with_items:  - httpd  - php  - php-mysql</code></pre><h3 id="7、字典"><a href="#7、字典" class="headerlink" title="7、字典"></a>7、字典</h3><p>　　ansible playbook 还支持字典功能。举例如下：</p><pre><code>- name: install some packages  yum: name={{ item }} state=present  with_items:    - nginx    - memcached    - php-fpm- name: add some groups  group: name={{ item }} state=present  with_items:    - group11    - group12    - group13- name: add some users  user: name={{ item.name }} group={{ item.group }} state=present  with_items:    - { name: &#39;user11&#39;, group: &#39;group11&#39; }    - { name: &#39;user12&#39;, group: &#39;group12&#39; }    - { name: &#39;user13&#39;, group: &#39;group13&#39; }</code></pre><h3 id="8、角色订制：roles"><a href="#8、角色订制：roles" class="headerlink" title="8、角色订制：roles"></a>8、角色订制：roles</h3><h4 id="①-简介"><a href="#①-简介" class="headerlink" title="① 简介"></a>① 简介</h4><p>　　对于以上所有的方式有个弊端就是无法实现复用假设在同时部署Web、db、ha 时或不同服务器组合不同的应用就需要写多个yml文件。很难实现灵活的调用。<br>　　roles 用于层次性、结构化地组织playbook。roles 能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量(vars)、文件(file)、任务(tasks)、模块(modules)及处理器(handlers)放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。</p><h4 id="②-角色集合"><a href="#②-角色集合" class="headerlink" title="② 角色集合"></a>② 角色集合</h4><p>角色集合：roles/<br>mysql/<br>httpd/<br>nginx/<br>files/：存储由copy或script等模块调用的文件；<br>tasks/：此目录中至少应该有一个名为main.yml的文件，用于定义各task；其它的文件需要由main.yml进行“包含”调用；<br>handlers/：此目录中至少应该有一个名为main.yml的文件，用于定义各handler；其它的文件需要由main.yml进行“包含”调用；<br>vars/：此目录中至少应该有一个名为main.yml的文件，用于定义各variable；其它的文件需要由main.yml进行“包含”调用；<br>templates/：存储由template模块调用的模板文本；<br>meta/：此目录中至少应该有一个名为main.yml的文件，定义当前角色的特殊设定及其依赖关系；其它的文件需要由main.yml进行“包含”调用；<br>default/：此目录中至少应该有一个名为main.yml的文件，用于设定默认变量；</p><h4 id="③-角色定制实例"><a href="#③-角色定制实例" class="headerlink" title="③ 角色定制实例"></a>③ 角色定制实例</h4><p><strong>1. 在roles目录下生成对应的目录结构</strong></p><pre><code>[root@server ansible]# cd roles/[root@server roles]# ls[root@server roles]# mkdir -pv ./{nginx,mysql,httpd}/{files,templates,vars,tasks,handlers,meta,default}[root@server roles]# tree.├── httpd│   ├── default│   ├── files│   ├── handlers│   ├── meta│   ├── tasks│   ├── templates│   └── vars├── mysql│   ├── default│   ├── files│   ├── handlers│   ├── meta│   ├── tasks│   ├── templates│   └── vars└── nginx    ├── default    ├── files    ├── handlers    ├── meta    ├── tasks    ├── templates    └── vars24 directories, 0 files</code></pre><p><strong>2. 定义配置文件</strong><br>　　我们需要修改的配置文件为<code>/tasks/main.yml</code>，下面，我们就来修改一下：</p><pre><code>[root@server roles]# vim nginx/tasks/main.yml- name: cp  copy: src=nginx-1.10.2-1.el7.ngx.x86_64.rpm dest=/tmp/nginx-1.10.2-1.el7.ngx.x86_64.rpm- name: install  yum: name=/tmp/nginx-1.10.2-1.el7.ngx.x86_64.rpm state=latest- name: conf  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf  tags: nginxconf  notify: new conf to reload- name: start service  service: name=nginx state=started enabled=true</code></pre><p><strong>3. 放置我们所需要的文件到指定目录</strong><br>　　因为我们定义的角色已经有了新的组成方式，所以我们需要把文件都放到指定的位置，这样，才能让配置文件找到这些并进行加载。<br>　　rpm包放在<code>files</code>目录下，模板放在<code>templates</code>目录下：</p><pre><code>[root@server nginx]# cp /tmp/nginx-1.10.2-1.el7.ngx.x86_64.rpm ./files/[root@server nginx]# cp /tmp/nginx.conf.j2 ./templates/[root@server nginx]# tree.├── default├── files│   └── nginx-1.10.2-1.el7.ngx.x86_64.rpm├── handlers├── meta├── tasks│   └── main.yml├── templates│   └── nginx.conf.j2└── vars7 directories, 3 files</code></pre><p><strong>4. 修改变量文件</strong><br>　　我们在模板中定义的变量，也要去配置文件中加上：</p><pre><code>[root@server nginx]# vim vars/main.ymlnginxprot: 9999</code></pre><p><strong>5. 定义handlers文件</strong><br>　　我们在配置文件中定义了<code>notify</code>，所以我么也需要定义<code>handlers</code>，我们来修改配置文件：</p><pre><code>[root@server nginx]# vim handlers/main.yml- name: new conf to reload  service: name=nginx state=restarted</code></pre><p><strong>6. 定义剧本文件</strong><br>　　接下来，我们就来定义剧本文件，由于大部分设置我们都单独配置在了roles里面，所以，接下来剧本就只需要写一点点内容即可：</p><pre><code>[root@server ansible]# vim roles.yml - hosts: web  remote_user: root  roles:    - nginx</code></pre><p><strong>7. 启动服务</strong><br>　　剧本定义完成以后，我们就可以来启动服务了：</p><pre><code>[root@server ansible]# ansible-playbook roles.ymlPLAY [web] *********************************************************************TASK [setup] *******************************************************************ok: [192.168.37.122]ok: [192.168.37.133]TASK [nginx : cp] **************************************************************ok: [192.168.37.122]ok: [192.168.37.133]TASK [nginx : install] *********************************************************changed: [192.168.37.122]changed: [192.168.37.133]TASK [nginx : conf] ************************************************************changed: [192.168.37.122]changed: [192.168.37.133]TASK [nginx : start service] ***************************************************changed: [192.168.37.122]changed: [192.168.37.133]RUNNING HANDLER [nginx : new conf to reload] ***********************************changed: [192.168.37.122]changed: [192.168.37.133]PLAY RECAP *********************************************************************192.168.37.122             : ok=6    changed=4    unreachable=0    failed=0   192.168.37.133             : ok=6    changed=4    unreachable=0    failed=0   </code></pre><p>　　启动过后照例查看端口号：</p><pre><code>[root@server ansible]# ansible web -m shell -a &quot;ss -ntulp |grep 9999&quot;192.168.37.122 | SUCCESS | rc=0 &gt;&gt;tcp    LISTEN     0      128       *:9999                  *:*                   users:((&quot;nginx&quot;,pid=7831,fd=6),(&quot;nginx&quot;,pid=7830,fd=6),(&quot;nginx&quot;,pid=7829,fd=6))192.168.37.133 | SUCCESS | rc=0 &gt;&gt;tcp    LISTEN     0      128       *:9999                  *:*                   users:((&quot;nginx&quot;,pid=9654,fd=6),(&quot;nginx&quot;,pid=9653,fd=6),(&quot;nginx&quot;,pid=9652,fd=6))</code></pre><p>　　可以看出我们的剧本已经执行成功。</p><h2 id="九、Ansible使用jinja2管理配置文件以及jinja2语法简介"><a href="#九、Ansible使用jinja2管理配置文件以及jinja2语法简介" class="headerlink" title="九、Ansible使用jinja2管理配置文件以及jinja2语法简介"></a>九、Ansible使用jinja2管理配置文件以及jinja2语法简介</h2><h3 id="1、Jinja2介绍"><a href="#1、Jinja2介绍" class="headerlink" title="1、Jinja2介绍"></a>1、Jinja2介绍</h3><p>Jinja2是基于python的模板引擎，功能比较类似于PHP的smarty，J2ee的Freemarker和velocity。它能完全支持unicode，并具有集成的沙箱执行环境，应用广泛。jinja2使用BSD授权</p><p>Jinja2的语法是由variables(变量)和statement(语句)组成，如下；</p><h4 id="1、variables：可以输出数据"><a href="#1、variables：可以输出数据" class="headerlink" title="1、variables：可以输出数据"></a>1、variables：可以输出数据</h4><pre><code> my_variables </code></pre>{{ some_dudes_name | capitalize }}<h4 id="2、statements-可以用来创建条件和循环等"><a href="#2、statements-可以用来创建条件和循环等" class="headerlink" title="2、statements: 可以用来创建条件和循环等"></a>2、statements: 可以用来创建条件和循环等</h4><pre class=" language-bash"><code class="language-bash">if语句：<span class="token punctuation">{</span>% <span class="token keyword">if</span> my_conditional %<span class="token punctuation">}</span> <span class="token punctuation">..</span>.<span class="token punctuation">{</span>% endif %<span class="token punctuation">}</span><span class="token keyword">for</span> 语句：<span class="token punctuation">{</span>% <span class="token keyword">for</span> item <span class="token keyword">in</span> all_items %<span class="token punctuation">}</span><span class="token variable"><span class="token variable">`</span>item<span class="token variable">`</span></span> ……<span class="token punctuation">{</span>% endfor %<span class="token punctuation">}</span></code></pre><p>从上面第二个variables的例子中可以看出，jinja2支持使用带过滤器的Unix型管道操作符，有很多的内置过滤器可供使用。我们可以仅仅用一堆简单if和for就可以建立几乎任何的常规配置文件，不过如果你有意更进一步，jinja2 documentation （<a href="http://jinja.pocoo.org/docs/dev/）包含了很多有趣的东西可供了解。我们可以看到ansible允许在模板中使用诸如绘制时间此类的一些额外的模板变量" target="_blank" rel="noopener">http://jinja.pocoo.org/docs/dev/）包含了很多有趣的东西可供了解。我们可以看到ansible允许在模板中使用诸如绘制时间此类的一些额外的模板变量</a></p><p>第一个例子：引用变量</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cd roles/template/</span><span class="token keyword">.</span>├── meta│   └── main.yml├── tasks│   ├── template.yml  │   └── main.yml├── templates│   ├── order.j2└── vars    └── main.yml</code></pre><p>总调度yml文件：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat templates.yml</span>---- hosts: 10.0.90.27  user: root  gather_facts: <span class="token boolean">false</span>  roles:   - role: template</code></pre><p>注意:这里 - role: template 和 - template 是一样的！</p><p>其他yml文件，如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat tasks/main.yml</span>- include: template.yml<span class="token comment" spellcheck="true">#cat tasks/template.yml</span>- name: create <span class="token punctuation">{</span><span class="token punctuation">{</span> PROJECT <span class="token punctuation">}</span><span class="token punctuation">}</span> directory  file: dest<span class="token operator">=</span>/data/<span class="token punctuation">{</span><span class="token punctuation">{</span> PROJECT <span class="token punctuation">}</span><span class="token punctuation">}</span> state<span class="token operator">=</span>directory- name: template transfor java <span class="token function">dir</span>  template: src<span class="token operator">=</span>order.j2 dest<span class="token operator">=</span>/data/<span class="token punctuation">{</span><span class="token punctuation">{</span> PROJECT <span class="token punctuation">}</span><span class="token punctuation">}</span>/order.conf<span class="token comment" spellcheck="true">#cat templates/order.j2</span>project: <span class="token punctuation">{</span><span class="token punctuation">{</span> PROJECT <span class="token punctuation">}</span><span class="token punctuation">}</span>switch: <span class="token punctuation">{</span><span class="token punctuation">{</span> SWITCH <span class="token punctuation">}</span><span class="token punctuation">}</span>dbport: <span class="token punctuation">{</span><span class="token punctuation">{</span> DBPORT <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#cat vars/main.yml</span>PROJECT: <span class="token string">"JAVA"</span>SWITCH: <span class="token string">"ON"</span>DBPORT: <span class="token string">"8080"</span>测试：<span class="token comment" spellcheck="true"># ansible-playbook templates.yml --syntax-check</span>playbook: templates.yml执行：<span class="token comment" spellcheck="true"># ansible-playbook templates.yml </span>PLAY <span class="token punctuation">[</span>10.0.90.27<span class="token punctuation">]</span> **************************************************************TASK <span class="token punctuation">[</span>template <span class="token keyword">:</span> include<span class="token punctuation">]</span> ***************************************************included: /etc/ansible/roles/template/tasks/template.yml <span class="token keyword">for</span> 10.0.90.27TASK <span class="token punctuation">[</span>template <span class="token keyword">:</span> create JAVA directory<span class="token punctuation">]</span> *************************************changed: <span class="token punctuation">[</span>10.0.90.27<span class="token punctuation">]</span>TASK <span class="token punctuation">[</span>template <span class="token keyword">:</span> template transfor java dir<span class="token punctuation">]</span> ********************************changed: <span class="token punctuation">[</span>10.0.90.27<span class="token punctuation">]</span>PLAY RECAP *********************************************************************10.0.90.27                 <span class="token keyword">:</span> ok<span class="token operator">=</span>3    changed<span class="token operator">=</span>2    unreachable<span class="token operator">=</span>0    failed<span class="token operator">=</span>0   <span class="token comment" spellcheck="true">#到10.0.90.27查看结果</span><span class="token comment" spellcheck="true">#cat /data/JAVA/order.conf</span>project: JAVAswitch: ONdbport: 8080</code></pre><p>第二个例子：for 语句</p><p>为远程主机生成服务器列表，加入该列表从192.168.13.201 web01.test.com 到192.168.13.211 web11.test.com 结束，如果手动添加就很不科学了，这里需要使用jinja2语法的for循环通过模板批量生成对应的配置文件，如下：</p><p>ansible目录结构：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cd /etc/ansible/roles/test_hosts</span><span class="token keyword">.</span>├── meta│   └── main.yml├── tasks│   ├── file1.yml│   └── main.yml├── templates│   └── test1.j2└── vars    └── main.yml</code></pre><p>各个目录下yml文件内容：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cat tasks/file1.yml </span>- name: ansible jinja2 template <span class="token keyword">for</span> hosts config  template: src<span class="token operator">=</span>test1.j2 dest<span class="token operator">=</span>/etc/httpd/conf/httpd.conf.test<span class="token comment" spellcheck="true"># cat tasks/main.yml </span>- include: file1.yml<span class="token comment" spellcheck="true"># cat templates/test1.j2 </span><span class="token punctuation">{</span>% <span class="token keyword">for</span> <span class="token function">id</span> <span class="token keyword">in</span> range<span class="token punctuation">(</span>201,212<span class="token punctuation">)</span> %<span class="token punctuation">}</span>192.168.13.<span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token function">id</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> web<span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token string">"%03d"</span> <span class="token operator">|</span>format<span class="token punctuation">(</span>id-200<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>.test.com<span class="token punctuation">{</span>% endfor %<span class="token punctuation">}</span>解释：<span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token function">id</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> 提取for循环中对应的变量id值<span class="token string">"%02d"</span>   调用的是python内置的字符串格式化输出（%d格式化整数）因为是01,02这种格式，所以是保留2位，故用02然后将结果通过管道符 “<span class="token operator">|</span>” 传递给format 函数做二次处理。</code></pre><p>执行结果：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat httpd.conf.test</span>192.168.13.201 web01.test.com192.168.13.202 web02.test.com192.168.13.203 web03.test.com192.168.13.204 web04.test.com192.168.13.205 web05.test.com192.168.13.206 web06.test.com192.168.13.207 web07.test.com192.168.13.208 web08.test.com192.168.13.209 web09.test.com192.168.13.210 web10.test.com192.168.13.211 web11.test.com</code></pre><p>第三个例子：if语句</p><p>说明：如果定义端口号，就绑定定义的端口号，如果不定义端口号，就绑定默认端口号</p><pre class=" language-bash"><code class="language-bash">ansible目录结果<span class="token comment" spellcheck="true">#cd /etc/ansible/roles/mysql_cnf</span><span class="token comment" spellcheck="true">#tree</span><span class="token keyword">.</span>├── meta│   └── main.yml├── tasks│   └── main.yml├── templates│   └── test3.j2└── vars</code></pre><p>主要的yml文件是templates目录下面的test3.j2</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cat templates/test3.j2 </span><span class="token punctuation">{</span>% <span class="token keyword">if</span> PORT %<span class="token punctuation">}</span>bind_address<span class="token operator">=</span>10.0.90.27:<span class="token punctuation">{</span><span class="token punctuation">{</span> PORT <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span>% <span class="token keyword">else</span> %<span class="token punctuation">}</span>bind_address<span class="token operator">=</span>10.0.90.27:3306<span class="token punctuation">{</span>% endif %<span class="token punctuation">}</span></code></pre><p>playbook主文件</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cat jinj2_test.yml </span>---- hosts: 10.0.90.27  user: root  gather_facts: <span class="token boolean">false</span>  vars:    PORT: 3136  tasks:    - name: copy <span class="token function">file</span> to client      template: src<span class="token operator">=</span>/etc/ansible/roles/mysql_cnf/templates/test3.j2 dest<span class="token operator">=</span>/root/my.cnf</code></pre><p>执行：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ansible-playbook jinj2_test.yml</span>PLAY <span class="token punctuation">[</span>10.0.90.27<span class="token punctuation">]</span> **************************************************************TASK <span class="token punctuation">[</span>copy <span class="token function">file</span> to client<span class="token punctuation">]</span> *****************************************************changed: <span class="token punctuation">[</span>10.0.90.27<span class="token punctuation">]</span>PLAY RECAP *********************************************************************10.0.90.27                 <span class="token keyword">:</span> ok<span class="token operator">=</span>1    changed<span class="token operator">=</span>1    unreachable<span class="token operator">=</span>0    failed<span class="token operator">=</span>0</code></pre><p>查看</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cat my.cnf </span>bind_address<span class="token operator">=</span>10.0.90.27:3136</code></pre><p>如果将vars变量去掉，执行结果：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cat jinj2_test.yml </span>---- hosts: 10.0.90.27  user: root  gather_facts: <span class="token boolean">false</span>  vars:    PORT: <span class="token boolean">false</span>  tasks:    - name: copy <span class="token function">file</span> to client      template: src<span class="token operator">=</span>/etc/ansible/roles/mysql_cnf/templates/test3.j2 dest<span class="token operator">=</span>/root/my.cnf</code></pre><p>查看：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cat my.cnf </span>bind_address<span class="token operator">=</span>10.0.90.27:3306</code></pre><h4 id="3、Jinja-default-设定"><a href="#3、Jinja-default-设定" class="headerlink" title="3、Jinja default()设定"></a>3、Jinja default()设定</h4><p>精通程序编码的朋友皆知，default()默认值的设定有助于程序的健壮性和简洁性。所幸Jinja也支持该功能，上面的例子中生成Mysql配置文件中的端口定义，如果指定则PORT=3136，否则PORT=3306，我们将该案例改造为使用default()试试</p><p>编辑/etc/ansible/roles/mysql_cnf/templates/test3.j2内容如下,这种方法更简介。</p><p>bind_address=10.0.90.27:3306</p><h3 id="2、ansible使用jiaja2生成apache多主机配置"><a href="#2、ansible使用jiaja2生成apache多主机配置" class="headerlink" title="2、ansible使用jiaja2生成apache多主机配置"></a>2、ansible使用jiaja2生成apache多主机配置</h3><h4 id="1、创建目录，创建好之后如下："><a href="#1、创建目录，创建好之后如下：" class="headerlink" title="1、创建目录，创建好之后如下："></a>1、创建目录，创建好之后如下：</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cd /etc/ansible/roles/apache_conf</span><span class="token comment" spellcheck="true"># tree ./</span>./├── meta│   └── main.yml├── tasks│   ├── file.yml│   └── main.yml├── templates│   └── apache.config.j2└── vars    └── main.yml4 directories, 5 files</code></pre><h4 id="2、创建tasks调度文件，如下："><a href="#2、创建tasks调度文件，如下：" class="headerlink" title="2、创建tasks调度文件，如下："></a>2、创建tasks调度文件，如下：</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat file.yml </span>- name: ansible jinja2 template <span class="token keyword">for</span> apache config  template: src<span class="token operator">=</span>apache.config.j2 dest<span class="token operator">=</span>/etc/httpd/conf/httpd.conf.template<span class="token comment" spellcheck="true">#cat main.yml </span>- include: file.yml</code></pre><h4 id="3、创建apache的jinja2模板文件，如下："><a href="#3、创建apache的jinja2模板文件，如下：" class="headerlink" title="3、创建apache的jinja2模板文件，如下："></a>3、创建apache的jinja2模板文件，如下：</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#cat apache.config.j2 </span>NameVirtualHost <span class="token operator">*</span><span class="token operator">:</span><span class="token number">80</span><span class="token punctuation">{</span><span class="token operator">%</span> <span class="token keyword">for</span> vhost in apache_vhost <span class="token operator">%</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>VirtualHost <span class="token operator">*</span><span class="token operator">:</span><span class="token number">80</span><span class="token operator">></span>ServerName <span class="token punctuation">{</span><span class="token punctuation">{</span> vhost<span class="token punctuation">.</span>servername <span class="token punctuation">}</span><span class="token punctuation">}</span>DocumentRoot <span class="token punctuation">{</span><span class="token punctuation">{</span> vhost<span class="token punctuation">.</span>documentroot <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token operator">%</span> <span class="token keyword">if</span> vhost<span class="token punctuation">.</span>serveradmin is defined <span class="token operator">%</span><span class="token punctuation">}</span>ServerAdmin <span class="token punctuation">{</span><span class="token punctuation">{</span> vhost<span class="token punctuation">.</span>serveradmin <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token operator">%</span> endif <span class="token operator">%</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>Directory <span class="token string">"{{ vhost.documentroot }}"</span><span class="token operator">></span>AllowOverride AllOptions <span class="token operator">-</span>Indexes FollowSymLinksOrder allow<span class="token punctuation">,</span>denyAllow from all<span class="token operator">&lt;</span><span class="token operator">/</span>Directory<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>VirtualHost<span class="token operator">></span><span class="token punctuation">{</span><span class="token operator">%</span> endfor <span class="token operator">%</span><span class="token punctuation">}</span></code></pre><h4 id="4、创建变量，如下："><a href="#4、创建变量，如下：" class="headerlink" title="4、创建变量，如下："></a>4、创建变量，如下：</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat vars/main.yml</span>apache_vhost:- <span class="token punctuation">{</span>servername: <span class="token string">"apache.test1.com"</span>, documentroot: <span class="token string">"/data/test1/"</span><span class="token punctuation">}</span>- <span class="token punctuation">{</span>servername: <span class="token string">"apache.test2.com"</span>, documentroot: <span class="token string">"/data/test2/"</span><span class="token punctuation">}</span></code></pre><h4 id="5、创建总调度yml文件，如下："><a href="#5、创建总调度yml文件，如下：" class="headerlink" title="5、创建总调度yml文件，如下："></a>5、创建总调度yml文件，如下：</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat /etc/ansible/apache_test.yml </span>---- hosts: 10.0.90.27  user: root  gather_facts: no  roles:   - <span class="token punctuation">{</span> role: apache_conf <span class="token punctuation">}</span></code></pre><h4 id="6、测试："><a href="#6、测试：" class="headerlink" title="6、测试："></a>6、测试：</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#ansible-playbook apache_test.yml --syntax-check</span>playbook: apache_test.yml</code></pre><h4 id="7、执行测试"><a href="#7、执行测试" class="headerlink" title="7、执行测试"></a>7、执行测试</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#ansible-playbook apache_test.yml </span>PLAY <span class="token punctuation">[</span>10.0.90.27<span class="token punctuation">]</span> **************************************************************TASK <span class="token punctuation">[</span>apache_conf <span class="token keyword">:</span> include<span class="token punctuation">]</span> ***************************************************included: /etc/ansible/roles/apache_conf/tasks/file.yml <span class="token keyword">for</span> 10.0.90.27TASK <span class="token punctuation">[</span>apache_conf <span class="token keyword">:</span> ansible jinja2 template <span class="token keyword">for</span> apache config<span class="token punctuation">]</span> *****************changed: <span class="token punctuation">[</span>10.0.90.27<span class="token punctuation">]</span>PLAY RECAP *********************************************************************10.0.90.27                 <span class="token keyword">:</span> ok<span class="token operator">=</span>2    changed<span class="token operator">=</span>1    unreachable<span class="token operator">=</span>0    failed<span class="token operator">=</span>0</code></pre><h4 id="8、到客户端查看"><a href="#8、到客户端查看" class="headerlink" title="8、到客户端查看"></a>8、到客户端查看</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat httpd.conf.template </span>NameVirtualHost *:80<span class="token operator">&lt;</span>VirtualHost *:80<span class="token operator">></span>ServerName apache.test1.comDocumentRoot /data/test1/<span class="token operator">&lt;</span>Directory <span class="token string">"/data/test1/"</span><span class="token operator">></span>AllowOverride AllOptions -Indexes FollowSymLinksOrder allow,denyAllow from all<span class="token operator">&lt;</span>/Directory<span class="token operator">></span><span class="token operator">&lt;</span>/VirtualHost<span class="token operator">></span><span class="token operator">&lt;</span>VirtualHost *:80<span class="token operator">></span>ServerName apache.test2.comDocumentRoot /data/test2/<span class="token operator">&lt;</span>Directory <span class="token string">"/data/test2/"</span><span class="token operator">></span>AllowOverride AllOptions -Indexes FollowSymLinksOrder allow,denyAllow from all<span class="token operator">&lt;</span>/Directory<span class="token operator">></span><span class="token operator">&lt;</span>/VirtualHost<span class="token operator">></span></code></pre><h2 id="3、ansible使用jiaja2生成nginx一个模板多种不同配置"><a href="#3、ansible使用jiaja2生成nginx一个模板多种不同配置" class="headerlink" title="3、ansible使用jiaja2生成nginx一个模板多种不同配置"></a>3、ansible使用jiaja2生成nginx一个模板多种不同配置</h2><p>说明：为2台Nginx Proxy，1台Nginx Web通过一套模板生成对应的配置</p><h4 id="1、ansible目录结构："><a href="#1、ansible目录结构：" class="headerlink" title="1、ansible目录结构："></a>1、ansible目录结构：</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cd roles/nginx_conf/</span><span class="token comment" spellcheck="true">#tree</span><span class="token keyword">.</span>├── files├── meta│   └── main.yml├── tasks│   ├── file.yml│   └── main.yml├── templates│   └── nginx.conf.j2└── vars    └── main.yml</code></pre><h4 id="2、tasks目录下文件内容："><a href="#2、tasks目录下文件内容：" class="headerlink" title="2、tasks目录下文件内容："></a>2、tasks目录下文件内容：</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat tasks/file.yml </span>- name: nginx.j2 template transfer example   template: src<span class="token operator">=</span>nginx.conf.j2 dest<span class="token operator">=</span>/etc/nginx/nginx.conf.template<span class="token comment" spellcheck="true">#cat tasks/main.yml </span>- include: file.yml</code></pre><h4 id="3、nginx模板文件"><a href="#3、nginx模板文件" class="headerlink" title="3、nginx模板文件"></a>3、nginx模板文件</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat templates/nginx.conf.j2 </span><span class="token punctuation">{</span>% <span class="token keyword">if</span> nginx_use_proxy %<span class="token punctuation">}</span><span class="token punctuation">{</span>% <span class="token keyword">for</span> proxy <span class="token keyword">in</span> nginx_proxies %<span class="token punctuation">}</span>upstream <span class="token punctuation">{</span><span class="token punctuation">{</span> proxy.name <span class="token punctuation">}</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">#server 127.0.0.1:{{ proxy.port }};</span>   server <span class="token punctuation">{</span><span class="token punctuation">{</span> ansible_eth0.ipv4.address <span class="token punctuation">}</span><span class="token punctuation">}</span>:<span class="token punctuation">{</span><span class="token punctuation">{</span> proxy.port <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">{</span>% endfor %<span class="token punctuation">}</span><span class="token punctuation">{</span>% endif%<span class="token punctuation">}</span>server <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>    servername <span class="token punctuation">{</span><span class="token punctuation">{</span> nginx_server_name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    access_log off<span class="token punctuation">;</span>    error_log /etc/nginx/nginx_error.log<span class="token punctuation">;</span>    rewrite ^ https://<span class="token variable">$server_name</span><span class="token variable">$request_uri?</span> permanent<span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>    listen 443 ssl<span class="token punctuation">;</span>    server_name <span class="token punctuation">{</span><span class="token punctuation">{</span> nginx_server_name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    ssl_certificate /etc/nginx/ssl/<span class="token punctuation">{</span><span class="token punctuation">{</span> nginx_ssl_cert_name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    ssl_certificate_key /etc/nginx/ssl/<span class="token punctuation">{</span><span class="token punctuation">{</span> nginx_ssl_cert_key <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    root <span class="token punctuation">{</span><span class="token punctuation">{</span> nginx_web_root <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    index index.html index.html<span class="token punctuation">;</span><span class="token punctuation">{</span>% <span class="token keyword">if</span> nginx_use_auth %<span class="token punctuation">}</span>   auth_basic  <span class="token string">"Restricted"</span><span class="token punctuation">;</span>   auth_basic_user_file /etc/nginx/<span class="token punctuation">{</span><span class="token punctuation">{</span> project_name <span class="token punctuation">}</span><span class="token punctuation">}</span>.htpasswd<span class="token punctuation">;</span><span class="token punctuation">{</span>% endif %<span class="token punctuation">}</span><span class="token punctuation">{</span>% <span class="token keyword">if</span> nginx_use_proxy %<span class="token punctuation">}</span><span class="token punctuation">{</span>% <span class="token keyword">for</span> proxy <span class="token keyword">in</span> nginx_proxies %<span class="token punctuation">}</span>   location <span class="token punctuation">{</span><span class="token punctuation">{</span> proxy.location <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>      proxy_set_header X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>      proxy_set_header X-Forwarded-Proto http<span class="token punctuation">;</span>      proxy_set_header X-Url-Scheme <span class="token variable">$scheme</span><span class="token punctuation">;</span>      proxy_set_header X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>      proxy_set_header Host <span class="token variable">$http_host</span><span class="token punctuation">;</span>      proxy_set_header X-NginX-Proxy <span class="token boolean">true</span><span class="token punctuation">;</span>      proxy_redirect off<span class="token punctuation">;</span>      proxy_pass http://<span class="token punctuation">{</span><span class="token punctuation">{</span> proxy.name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">{</span>% endfor %<span class="token punctuation">}</span><span class="token punctuation">{</span>% endif %<span class="token punctuation">}</span><span class="token punctuation">{</span>% <span class="token keyword">if</span> nginx_server_static %<span class="token punctuation">}</span>   location / <span class="token punctuation">{</span>       try_files <span class="token variable">$url</span> <span class="token variable">$url</span>/ <span class="token operator">=</span>404<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">{</span>% endif %<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="4、ansible变量文件"><a href="#4、ansible变量文件" class="headerlink" title="4、ansible变量文件"></a>4、ansible变量文件</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> vars/main.yml nginx_server_name: www.testnginx.comnginx_web_root: /data/html/nginx_proxies:- name: suspicious  location: /  port: 1234- name: suspicious-api  location: /api  port: 4567</code></pre><h4 id="5、ansible主playbook文件"><a href="#5、ansible主playbook文件" class="headerlink" title="5、ansible主playbook文件"></a>5、ansible主playbook文件</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat nginx_test.yml </span><span class="token comment" spellcheck="true">##The first roles</span>- name: Nginx Proxy Server<span class="token string">'s Config Dynamic Create  hosts: "10.0.90.25:10.0.90.26"  remote_user: root  vars:    nginx_use_proxy: true    nginx_ssl_cert_name: ifa.crt    nginx_ssl_cert_key: ifa.key    nginx_use_auth: true    project_name: suspicious    nginx_server_static: true  gather_facts: true  roles:     -  role: nginx_conf##The second roles- name: Nginx WebServer'</span>s Config Dynamic Create  hosts: 10.0.90.27  remote_user: root  vars:    nginx_use_proxy: <span class="token boolean">false</span>    nginx_ssl_cert_name: ifa.crt    nginx_ssl_cert_key: ifa.crt    nginx_use_auth: <span class="token boolean">false</span>    project_name: suspicious    nginx_server_static: <span class="token boolean">false</span>  gather_facts: <span class="token boolean">false</span>  roles:     -  role: nginx_conf</code></pre><h4 id="6、测试并执行："><a href="#6、测试并执行：" class="headerlink" title="6、测试并执行："></a>6、测试并执行：</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#ansible-playbook nginx_test.yml --syntax-check</span>playbook: nginx_test.yml执行：<span class="token comment" spellcheck="true"># ansible-playbook nginx_test.yml</span>PLAY <span class="token punctuation">[</span>Nginx Proxy Server<span class="token string">'s Config Dynamic Create] ******************************TASK [setup] *******************************************************************ok: [10.0.90.25]ok: [10.0.90.26]TASK [nginx_conf : include] ****************************************************included: /etc/ansible/roles/nginx_conf/tasks/file.yml for 10.0.90.25, 10.0.90.26TASK [nginx_conf : nginx.j2 template transfer example] *************************changed: [10.0.90.26]changed: [10.0.90.25]PLAY [Nginx WebServer'</span>s Config Dynamic Create<span class="token punctuation">]</span> *********************************TASK <span class="token punctuation">[</span>nginx_conf <span class="token keyword">:</span> include<span class="token punctuation">]</span> ****************************************************included: /etc/ansible/roles/nginx_conf/tasks/file.yml <span class="token keyword">for</span> 10.0.90.27TASK <span class="token punctuation">[</span>nginx_conf <span class="token keyword">:</span> nginx.j2 template transfer example<span class="token punctuation">]</span> *************************changed: <span class="token punctuation">[</span>10.0.90.27<span class="token punctuation">]</span>PLAY RECAP *********************************************************************10.0.90.25                 <span class="token keyword">:</span> ok<span class="token operator">=</span>3    changed<span class="token operator">=</span>1    unreachable<span class="token operator">=</span>0    failed<span class="token operator">=</span>0   10.0.90.26                 <span class="token keyword">:</span> ok<span class="token operator">=</span>3    changed<span class="token operator">=</span>1    unreachable<span class="token operator">=</span>0    failed<span class="token operator">=</span>0   10.0.90.27                 <span class="token keyword">:</span> ok<span class="token operator">=</span>2    changed<span class="token operator">=</span>1    unreachable<span class="token operator">=</span>0    failed<span class="token operator">=</span>0</code></pre><h4 id="7、查看检测执行结果"><a href="#7、查看检测执行结果" class="headerlink" title="7、查看检测执行结果"></a>7、查看检测执行结果</h4><p>到Nginx Proxy 服务器查看配置文件</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat nginx.conf.template </span>upstream suspicious   <span class="token comment" spellcheck="true">#server 127.0.0.1:1234;</span>   server 10.0.90.26:1234<span class="token punctuation">;</span><span class="token punctuation">}</span>upstream suspicious-api   <span class="token comment" spellcheck="true">#server 127.0.0.1:4567;</span>   server 10.0.90.26:4567<span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>    servername www.testnginx.com<span class="token punctuation">;</span>    access_log off<span class="token punctuation">;</span>    error_log /etc/nginx/nginx_error.log<span class="token punctuation">;</span>    rewrite ^ https://<span class="token variable">$server_name</span><span class="token variable">$request_uri?</span> permanent<span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>    listen 443 ssl<span class="token punctuation">;</span>    server_name www.testnginx.com<span class="token punctuation">;</span>    ssl_certificate /etc/nginx/ssl/ifa.crt<span class="token punctuation">;</span>    ssl_certificate_key /etc/nginx/ssl/ifa.key<span class="token punctuation">;</span>    root /data/html/<span class="token punctuation">;</span>    index index.html index.html<span class="token punctuation">;</span>   auth_basic  <span class="token string">"Restricted"</span><span class="token punctuation">;</span>   auth_basic_user_file /etc/nginx/suspicious.htpasswd<span class="token punctuation">;</span>   location / <span class="token punctuation">{</span>      proxy_set_header X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>      proxy_set_header X-Forwarded-Proto http<span class="token punctuation">;</span>      proxy_set_header X-Url-Scheme <span class="token variable">$scheme</span><span class="token punctuation">;</span>      proxy_set_header X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>      proxy_set_header Host <span class="token variable">$http_host</span><span class="token punctuation">;</span>      proxy_set_header X-NginX-Proxy <span class="token boolean">true</span><span class="token punctuation">;</span>      proxy_redirect off<span class="token punctuation">;</span>      proxy_pass http://suspicious<span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>   location /api <span class="token punctuation">{</span>      proxy_set_header X-Real-IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>      proxy_set_header X-Forwarded-Proto http<span class="token punctuation">;</span>      proxy_set_header X-Url-Scheme <span class="token variable">$scheme</span><span class="token punctuation">;</span>      proxy_set_header X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>      proxy_set_header Host <span class="token variable">$http_host</span><span class="token punctuation">;</span>      proxy_set_header X-NginX-Proxy <span class="token boolean">true</span><span class="token punctuation">;</span>      proxy_redirect off<span class="token punctuation">;</span>      proxy_pass http://suspicious-api<span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>   location / <span class="token punctuation">{</span>       try_files <span class="token variable">$url</span> <span class="token variable">$url</span>/ <span class="token operator">=</span>404<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>到Nginx Web 服务器上查看配置文件</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#cat nginx.conf.template </span>server <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>    servername www.testnginx.com<span class="token punctuation">;</span>    access_log off<span class="token punctuation">;</span>    error_log /etc/nginx/nginx_error.log<span class="token punctuation">;</span>    rewrite ^ https://<span class="token variable">$server_name</span><span class="token variable">$request_uri?</span> permanent<span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>    listen 443 ssl<span class="token punctuation">;</span>    server_name www.testnginx.com<span class="token punctuation">;</span>    ssl_certificate /etc/nginx/ssl/ifa.crt<span class="token punctuation">;</span>    ssl_certificate_key /etc/nginx/ssl/ifa.crt<span class="token punctuation">;</span>    root /data/html/<span class="token punctuation">;</span>    index index.html index.html<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>到这里，就结束了。用同样的模板通过简单的if和变量设置就可以完成不同类型主机的Nginx conf配置，所以一方面在了解Ansible强大的模板功能的同时，也需要看到模板质量的重要性。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ消息中间件</title>
      <link href="2019/04/16/sql/rabbitmq-xiao-xi-zhong-jian-jian/"/>
      <url>2019/04/16/sql/rabbitmq-xiao-xi-zhong-jian-jian/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="RabbitMQ-消息中间件"><a href="#RabbitMQ-消息中间件" class="headerlink" title="RabbitMQ 消息中间件"></a>RabbitMQ 消息中间件</h2><h3 id="1、消息中间件"><a href="#1、消息中间件" class="headerlink" title="1、消息中间件"></a>1、消息中间件</h3><h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>消息中间件也可以称消息队列，是指用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信。</p><p>当下主流的消息中间件有RabbitMQ、Kafka、ActiveMQ、RocketMQ等。其能在不同平台之间进行通信，常用来屏蔽各种平台协议之间的特性，实现应用程序之间的协同。优点在于能够在客户端和服务器之间进行同步和异步的连接，并且在任何时刻都可以将消息进行传送和转发，是分布式系统中非常重要的组件，主要用来解决应用耦合、异步通信、流量削峰等问题。 </p><h4 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h4><h5 id="1、消息中间件主要作用"><a href="#1、消息中间件主要作用" class="headerlink" title="1、消息中间件主要作用"></a>1、消息中间件主要作用</h5><ul><li>解耦</li><li>冗余(存储)</li><li>扩展性</li><li>削峰</li><li>可恢复性</li><li>顺序保证</li><li>缓冲</li><li>异步通信</li></ul><h5 id="2、消息中间件的两种模式"><a href="#2、消息中间件的两种模式" class="headerlink" title="2、消息中间件的两种模式"></a>2、消息中间件的两种模式</h5><h6 id="1、P2P模式"><a href="#1、P2P模式" class="headerlink" title="1、P2P模式"></a>1、P2P模式</h6><p>P2P模式包含三个角色：消息队列（Queue）、发送者(Sender)、接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到它们被消费或超时。</p><p><strong>P2P的特点：</strong></p><ul><li>每个消息只有一个消费者（Consumer），即一旦被消费，消息就不再在消息队列中</li><li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行它不会影响到消息被发送到队列</li><li>接收者在成功接收消息之后需向队列应答成功</li><li>如果希望发送的每个消息都会被成功处理的话，那么需要P2P模 </li></ul><h6 id="2、Pub-Sub模式"><a href="#2、Pub-Sub模式" class="headerlink" title="2、Pub/Sub模式"></a>2、Pub/Sub模式</h6><p>Pub/Sub模式包含三个角色：主题（Topic）、发布者（Publisher）、订阅者（Subscriber） 。多个发布者将消息发送到Topic，系统将这些消息传递给多个订阅者。</p><p><strong>Pub/Sub的特点：</strong></p><ul><li>每个消息可以有多个消费者</li><li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息</li><li>为了消费消息，订阅者必须保持运行的状态</li><li>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型</li></ul><h5 id="3、常用中间件介绍与对比"><a href="#3、常用中间件介绍与对比" class="headerlink" title="3、常用中间件介绍与对比"></a>3、常用中间件介绍与对比</h5><h6 id="1、Kafka"><a href="#1、Kafka" class="headerlink" title="1、Kafka"></a>1、Kafka</h6><p>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</p><h6 id="2、RabbitMQ"><a href="#2、RabbitMQ" class="headerlink" title="2、RabbitMQ"></a>2、RabbitMQ</h6><p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p><h6 id="3、RocketMQ"><a href="#3、RocketMQ" class="headerlink" title="3、RocketMQ"></a>3、RocketMQ</h6><p>RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</p><p>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</p><h3 id="2、RabbitMQ-详解"><a href="#2、RabbitMQ-详解" class="headerlink" title="2、RabbitMQ 详解"></a>2、RabbitMQ 详解</h3><h4 id="1、RabbitMQ-介绍"><a href="#1、RabbitMQ-介绍" class="headerlink" title="1、RabbitMQ 介绍"></a>1、RabbitMQ 介绍</h4><p>RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><p>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。</p><h4 id="2、RabbitMQ-特点"><a href="#2、RabbitMQ-特点" class="headerlink" title="2、RabbitMQ 特点"></a>2、RabbitMQ 特点</h4><ul><li>可靠性</li><li>灵活的路由</li><li>扩展性</li><li>高可用性</li><li>多种协议</li><li>多语言客户端</li><li>管理界面</li><li>插件机制</li></ul><h4 id="3、AMQP-介绍"><a href="#3、AMQP-介绍" class="headerlink" title="3、AMQP 介绍"></a>3、AMQP 介绍</h4><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p><h4 id="4、什么和是消息队列"><a href="#4、什么和是消息队列" class="headerlink" title="4、什么和是消息队列"></a>4、什么和是消息队列</h4><p>MQ 全称为Message Queue, 消息队列。是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。</p><p><strong>消息传递</strong>指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。队列的使用除去了接收和发送应用程序同时执行的要求。</p><p>在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。</p><p>消息队列的使用场景是怎样的？</p><h4 id="5、RabbitMQ-应用场景"><a href="#5、RabbitMQ-应用场景" class="headerlink" title="5、RabbitMQ 应用场景"></a>5、RabbitMQ 应用场景</h4><p>对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如：<br>1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何防止丢失？<br>2）如何降低发送者和接收者的耦合度？<br>3）如何让Priority高的接收者先接到数据？<br>4）如何做到load balance？有效均衡接收者的负载？<br>5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。<br>6）如何做到可扩展，甚至将这个通信模块发到cluster上？<br>7）如何保证接收者接收到了完整，正确的数据？<br><strong>AMDQ</strong>协议解决了以上的问题，而RabbitMQ实现了<strong>AMQP</strong>。</p><h4 id="6、RabbitMQ-概念介绍"><a href="#6、RabbitMQ-概念介绍" class="headerlink" title="6、RabbitMQ 概念介绍"></a>6、RabbitMQ 概念介绍</h4><ul><li><strong>Broker</strong>：简单来说就是消息队列服务器实体。</li><li><strong>Exchange</strong>：消息交换机，它指定消息按什么规则，路由到哪个队列。</li><li><strong>Queue</strong>：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li><strong>Binding</strong>：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li><li><strong>Routing Key</strong>：路由关键字，exchange根据这个关键字进行消息投递。</li><li><strong>vhost</strong>：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li><li><strong>producer</strong>：消息生产者，就是投递消息的程序。</li><li><strong>consumer</strong>：消息消费者，就是接受消息的程序。</li><li><strong>channel</strong>：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</li></ul><p>RabbitMQ从整体上来看是一个典型的生产者消费者模型，主要负责接收、存储和转发消息</p><p><img src="https://s1.ax1x.com/2020/04/26/JRegrq.png" alt="JRegrq.png"></p><h4 id="7、RabbitMQ-使用流程"><a href="#7、RabbitMQ-使用流程" class="headerlink" title="7、RabbitMQ 使用流程"></a>7、RabbitMQ 使用流程</h4><p>AMQP模型中，消息在producer中产生，发送到MQ的exchange上，exchange根据配置的路由方式发到相应的Queue上，Queue又将消息发送给consumer，消息从queue到consumer有push和pull两种方式。 消息队列的使用过程大概如下：</p><ol><li>客户端连接到消息队列服务器，打开一个channel。</li><li>客户端声明一个exchange，并设置相关属性。</li><li>客户端声明一个queue，并设置相关属性。</li><li>客户端使用routing key，在exchange和queue之间建立好绑定关系。</li><li>客户端投递消息到exchange。</li></ol><p>exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。 exchange也有几个类型，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。</p><h3 id="3、RabbitMQ-单机安装部署"><a href="#3、RabbitMQ-单机安装部署" class="headerlink" title="3、RabbitMQ 单机安装部署"></a>3、RabbitMQ 单机安装部署</h3><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h4><p>下载地址：<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="noopener">http://www.rabbitmq.com/download.html</a></p><h4 id="2、Windows上安装"><a href="#2、Windows上安装" class="headerlink" title="2、Windows上安装"></a>2、Windows上安装</h4><h6 id="1、安装安装Erlang"><a href="#1、安装安装Erlang" class="headerlink" title="1、安装安装Erlang"></a>1、安装安装Erlang</h6><p>下载erlang：<a href="http://www.erlang.org/download/otp_win64_17.3.exe" target="_blank" rel="noopener">http://www.erlang.org/download/otp_win64_17.3.exe</a></p><p>安装：</p><p><img src="https://s1.ax1x.com/2020/04/26/JRe5iF.png" alt="JRe5iF.png"></p><p><img src="https://s1.ax1x.com/2020/04/26/JRmiLt.png" alt="JRmiLt.png"></p><p><img src="https://s1.ax1x.com/2020/04/26/JRmEo8.png" alt="JRmEo8.png"></p><p><img src="https://s1.ax1x.com/2020/04/26/JRmnzj.png" alt="JRmnzj.png"></p><p>erlang安装完成。</p><h6 id="2、安装安装RabbitMQ"><a href="#2、安装安装RabbitMQ" class="headerlink" title="2、安装安装RabbitMQ"></a>2、安装安装RabbitMQ</h6><p><img src="https://s1.ax1x.com/2020/04/26/JRm1e0.png" alt="JRm1e0.png"></p><p><img src="https://s1.ax1x.com/2020/04/26/JRm8oT.png" alt="JRm8oT.png"></p><p>RabbitMQ安装完成。</p><p><img src="https://s1.ax1x.com/2020/04/26/JRmUSJ.png" alt="JRmUSJ.png"></p><p>启动、停止、重新安装等。</p><h6 id="3、启用管理工具"><a href="#3、启用管理工具" class="headerlink" title="3、启用管理工具"></a>3、启用管理工具</h6><p>第一步：点击打开RabbitMQ的命令窗口。如图：</p><p><img src="https://s1.ax1x.com/2020/04/26/JRmwO1.png" alt="JRmwO1.png"></p><p>第二步：输入命令rabbitmq-plugins enable rabbitmq_management</p><p>这个命令的意思是安装RabbitMQ的插件。</p><p>第三步：测试是否安装成功。</p><p>方法：访问地址：<a href="http://127.0.0.1:15672/" target="_blank" rel="noopener">http://127.0.0.1:15672/</a></p><p><img src="https://s1.ax1x.com/2020/04/26/JRmDw6.png" alt="JRmDw6.png"></p><p>默认账号：guest/guest</p><h4 id="3、Linux上安装"><a href="#3、Linux上安装" class="headerlink" title="3、Linux上安装"></a>3、Linux上安装</h4><h6 id="1、安装-erlang"><a href="#1、安装-erlang" class="headerlink" title="1、安装 erlang"></a>1、安装 erlang</h6><p>添加yum支持</p><pre><code>cd /usr/local/src/mkdir rabbitmqcd rabbitmqwget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpmrpm -ivh erlang-solutions-1.0-1.noarch.rpmrpm --import http://packages.erlang-solutions.com/rpm/erlang_solutions.ascyum install erlang</code></pre><h6 id="2、安装RabbitMQ"><a href="#2、安装RabbitMQ" class="headerlink" title="2、安装RabbitMQ"></a>2、安装RabbitMQ</h6><p>1、用 yum 安装 RabbitMQ</p><pre class=" language-bash"><code class="language-bash">rpm --import https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc<span class="token comment" spellcheck="true"># this example assumes the CentOS 7 version of the package</span>yum <span class="token function">install</span> rabbitmq-server-3.7.13-1.el7.noarch.rpm</code></pre><pre class=" language-bash"><code class="language-bash">rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc<span class="token comment" spellcheck="true"># this example assumes the CentOS 7 version of the package</span>yum <span class="token function">install</span> rabbitmq-server-3.7.13-1.el7.noarch.rpm</code></pre><p>2、用 rpm 手动安装</p><p>下载：</p><pre><code>wget  https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.13/rabbitmq-server-3.7.13-1.el7.noarch.rpm</code></pre><p>上传rabbitmq-server-3.7.13-1.el7.noarch.rpm文件到/usr/local/src/rabbitmq/</p><p>安装：</p><pre><code>rpm -ivh rabbitmq-server-3.7.13-1.el7.noarch.rpm</code></pre><p>几个常用命令：</p><pre><code>service rabbitmq-server startservice rabbitmq-server stopservice rabbitmq-server restart chkconfig rabbitmq-server on　　//设置开机自启</code></pre><p>设置配置文件：</p><pre><code>cd /etc/rabbitmqcp /usr/share/doc/rabbitmq-server-3.7.13/rabbitmq.config.example /etc/rabbitmq/mv rabbitmq.config.example rabbitmq.config</code></pre><p>设置用户远程访问：</p><pre><code>vim /etc/rabbitmq/rabbitmq.config</code></pre><p><img src="https://s1.ax1x.com/2020/04/26/JRmyFO.png" alt="JRmyFO.png"></p><p>去掉后面的逗号</p><p>开启web界面管理工具</p><pre><code>rabbitmq-plugins enable rabbitmq_managementservice rabbitmq-server restart</code></pre><p>防火墙开放15672端口(CentOS7 不用操作)</p><pre><code>/sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT/etc/rc.d/init.d/iptables save</code></pre><h6 id="4、客户端的简单介绍"><a href="#4、客户端的简单介绍" class="headerlink" title="4、客户端的简单介绍"></a>4、客户端的简单介绍</h6><p>1、界面的介绍</p><p><img src="https://s1.ax1x.com/2020/04/26/JRmcfe.png" alt="JRmcfe.png"></p><p>注意设置虚拟主机与添加用户这块。</p><p><img src="https://s1.ax1x.com/2020/04/26/JRmfOI.png" alt="JRmfOI.png"></p><pre><code>命令行添加用户，设置tagsrabbitmqctl list_usersrabbitmqctl add_user username passwordrabbitmqctl set_user_tags username  administrator</code></pre><p>关于虚拟主机，Virtual Host，其实是一个虚拟概念，类似于权限控制组，一个Virtual Host里面可以有若干个Exchange和Queue，但是权限控制的最小粒度是Virtual Host</p><p>用户角色有下面几种：</p><ol><li>超级管理员(administrator)</li></ol><p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p><ol><li>监控者(monitoring)</li></ol><p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p><ol><li>策略制定者(policymaker)</li></ol><p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p><ol><li>普通管理者(management)</li></ol><p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p><ol><li>其他</li></ol><p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p><h4 id="4、Mac-安装教程"><a href="#4、Mac-安装教程" class="headerlink" title="4、Mac 安装教程"></a>4、Mac 安装教程</h4><h6 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h6><p>在Mac下安装RabbitMQ是非常简单的，一般默认RabbitMQ服务器依赖的Erlang已经安装，只需要用下面两个命令就可以完成RabbitMQ的安装（前提是homebrew已经被安装）：</p><pre><code>brew updatebrew install rabbitmq</code></pre><p>耐心等待，安装完成后需要将/usr/local/sbin添加到$PATH，可以将下面这两行加到~/.bash_profile：</p><pre><code># RabbitMQ Configexport PATH=$PATH:/usr/local/sbin</code></pre><p>编辑完后:wq保存退出，使环境变量立即生效。</p><pre><code>source ~/.bash_profile</code></pre><h6 id="2、启动RabbitMQ服务"><a href="#2、启动RabbitMQ服务" class="headerlink" title="2、启动RabbitMQ服务"></a>2、启动RabbitMQ服务</h6><p>上面配置完成后，需要关闭终端窗口，重新打开，然后输入下面命令即可启动RabbitMQ服务：</p><pre><code>rabbitmq-server</code></pre><h6 id="3、登录Web管理界面"><a href="#3、登录Web管理界面" class="headerlink" title="3、登录Web管理界面"></a>3、登录Web管理界面</h6><p>浏览器输入<code>localhost：15672</code>,账号密码全输入guest即可登录。</p><h4 id="5、RabbitMQ常用的命令"><a href="#5、RabbitMQ常用的命令" class="headerlink" title="5、RabbitMQ常用的命令"></a>5、RabbitMQ常用的命令</h4><h5 id="1、基本命令"><a href="#1、基本命令" class="headerlink" title="1、基本命令"></a>1、基本命令</h5><p>启动监控管理器：rabbitmq-plugins enable rabbitmq_management<br>关闭监控管理器：rabbitmq-plugins disable rabbitmq_management<br>启动rabbitmq：rabbitmq-service start<br>关闭rabbitmq：rabbitmq-service stop<br>查看所有的队列：rabbitmqctl list_queues<br>清除所有的队列：rabbitmqctl reset<br>关闭应用：rabbitmqctl stop_app<br>启动应用：rabbitmqctl start_app</p><h5 id="2、用户和权限设置"><a href="#2、用户和权限设置" class="headerlink" title="2、用户和权限设置"></a>2、用户和权限设置</h5><p>添加用户：rabbitmqctl add_user username password<br>分配角色：rabbitmqctl set_user_tags username administrator<br>新增虚拟主机：rabbitmqctl add_vhost vhost_name<br>将新虚拟主机授权给新用户：<code>rabbitmqctl set_permissions -p vhost_name username “.*” “.*” “.*”</code>(后面三个”*”代表用户拥有配置、写、读全部权限)</p><h5 id="3、角色说明"><a href="#3、角色说明" class="headerlink" title="3、角色说明"></a>3、角色说明</h5><ul><li>超级管理员(administrator)<br>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</li><li>监控者(monitoring)<br>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</li><li>策略制定者(policymaker)<br>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</li><li>普通管理者(management)<br>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</li><li>其他<br>无法登陆管理控制台，通常就是普通的生产者和消费者。</li></ul><h3 id="4、RabbitMQ-集群部署及配置"><a href="#4、RabbitMQ-集群部署及配置" class="headerlink" title="4、RabbitMQ 集群部署及配置"></a>4、RabbitMQ 集群部署及配置</h3><p>消息中间件RabbitMQ，一般以集群方式部署，主要提供消息的接受和发送，实现各微服务之间的消息异步。以下将介绍RabbitMQ+HA方式进行部署。</p><h4 id="1、原理介绍"><a href="#1、原理介绍" class="headerlink" title="1、原理介绍"></a>1、原理介绍</h4><p>RabbitMQ是依据erlang的分布式特性（RabbitMQ底层是通过Erlang架构来实现的，所以rabbitmqctl会启动Erlang节点，并基于Erlang节点来使用Erlang系统连接RabbitMQ节点，在连接过程中需要正确的Erlang Cookie和节点名称，Erlang节点通过交换Erlang Cookie以获得认证）来实现的，所以部署Rabbitmq分布式集群时要先安装Erlang，并把其中一个服务的cookie复制到另外的节点。</p><p>RabbitMQ集群中，各个RabbitMQ为对等节点，即每个节点均提供给客户端连接，进行消息的接收和发送。节点分为内存节点和磁盘节点，一般的，均应建立为磁盘节点，为了防止机器重启后的消息消失；</p><p>RabbitMQ的Cluster集群模式一般分为两种，普通模式和镜像模式。消息队列通过RabbitMQ HA镜像队列进行消息队列实体复制。</p><p>普通模式下，以两个节点（rabbit01、rabbit02）为例来进行说明。对于Queue来说，消息实体只存在于其中一个节点rabbit01（或者rabbit02），rabbit01和rabbit02两个节点仅有相同的元数据，即队列的结构。当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01、rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。</p><p>镜像模式下，将需要消费的队列变为镜像队列，存在于多个节点，这样就可以实现RabbitMQ的HA高可用性。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在consumer消费数据时临时读取。缺点就是，集群内部的同步通讯会占用大量的网络带宽。</p><h4 id="2、部署-RabbitMQ-Cluster"><a href="#2、部署-RabbitMQ-Cluster" class="headerlink" title="2、部署 RabbitMQ Cluster"></a>2、部署 RabbitMQ Cluster</h4><p>多台机器部署RabbitMQ的cluster，</p><h5 id="1、环境要求"><a href="#1、环境要求" class="headerlink" title="1、环境要求"></a>1、环境要求</h5><p>1、所有节点需要再同一个局域网内；</p><p>2、所有节点需要有相同的 erlang cookie，否则不能正常通信，为了实现cookie内容一致，采用scp的方式进行。</p><p>3、准备三台虚拟机，配置相同</p><p>rabbitmq01 192.168.101.11   </p><p>rabbitmq02 192.168.101.12  </p><p>rabbitmq03 192.168.101.13</p><p>操作系统：centos7.5</p><h5 id="2、部署过程"><a href="#2、部署过程" class="headerlink" title="2、部署过程"></a>2、部署过程</h5><h6 id="1、所有节点配置-etc-hosts"><a href="#1、所有节点配置-etc-hosts" class="headerlink" title="1、所有节点配置/etc/hosts"></a>1、所有节点配置/etc/hosts</h6><p>node1 192.168.101.11   </p><p>node2 192.168.101.12  </p><p>node3 192.168.101.13</p><h6 id="2、所有节点安装-erLang-和-rabbitmq"><a href="#2、所有节点安装-erLang-和-rabbitmq" class="headerlink" title="2、所有节点安装 erLang 和 rabbitmq"></a>2、所有节点安装 erLang 和 rabbitmq</h6><p><strong>1、安装erlang</strong></p><p>安装依赖包</p><pre><code>yum install -y *epel* gcc-c++ unixODBC unixODBC-devel openssl-devel ncurses-devel</code></pre><p>编译安装</p><pre><code>wget http://erlang.org/download/otp_src_21.3.tar.gztar -zxvf otp_src_21.3.tar.gzcd otp_src_21.3./configure --prefix=/usr/local/bin/erlang --without-javacmake &amp;&amp; make installecho &quot;export PATH=$PATH:/usr/local/bin/erlang/bin:/usr/local/bin/rabbitmq_server-3.6.15/sbin&quot; &gt;&gt; /etc/profilesource /etc/profile</code></pre><p>出现 erl 命令则说明安装成功；</p><p><strong>2、安装rabbitmq</strong></p><p>编译安装</p><pre><code>wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-generic-unix-3.6.15.tar.xzyum install -y xzxz -d rabbitmq-server-generic-unix-3.6.15.tar.xztar -xvf rabbitmq-server-generic-unix-3.6.15.tar -C /usr/local/bin/echo &quot;export PATH=$PATH:/usr/local/bin/erlang/bin:/usr/local/bin/rabbitmq_server-3.6.15/sbin&quot; &gt;&gt; /etc/profilesource /etc/profile</code></pre><p><strong>3、导入 rabbitmq 的管理界面</strong></p><pre><code>rabbitmq-plugins enable rabbitmq_management</code></pre><p><strong>4、设置 erlang</strong></p><p>找到erlang cookie文件的位置，官方在介绍集群的文档中提到过.erlang.cookie 一般会存在这两个地址：第一个是<code>home/.erlang.cookie</code>；第二个地方就是<code>/var/lib/rabbitmq/.erlang.cookie</code>。如果我们使用解压缩方式安装部署的rabbitmq，那么这个文件会在{home}目录下，也就是<code>$home/.erlang.cookie</code>。如果我们使用rpm等安装包方式进行安装的，那么这个文件会在<code>/var/lib/rabbitmq</code>目录下。</p><p>这里将 node1 的该文件复制到 node2、node3，注意这个文件的权限是 400（默认即是400），因此采用scp的方式只拷贝内容即可；</p><p>可以通过<code>cat  $home/.erlang.cookie</code>来查看三台机器的cookie是否一致，设置erlang的目的是要保证集群内的cookie内容一致。</p><p><strong>使用-detached参数运行各节点</strong></p><pre><code>rabbitmqctl stoprabbitmq-server -detached</code></pre><p>然后可以通过 <code>rabbitmqctl cluster_status</code>查看节点状态。</p><p>注意：要先拷贝cookie到另外两台机器上，保证三台机器上的cookie是一致的，然后再启动服务。</p><p>由于guest这个用户,只能在本地访问,所以我们要新增一个用户并赋予权限:</p><p>添加用户并设置密码:</p><pre><code>rabbitmqctl add_user  admin 123456</code></pre><p>添加权限（使admin用户对虚拟主机“/” 具有所有权限）:</p><pre><code>rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></pre><p>修改用户角色（加入administrator用户组）</p><pre><code>rabbitmqctl set_user_tags admin administrator</code></pre><p>然后就可以远程访问了，然后可直接配置用户权限等信息。到此,就可以通过<a href="http://ip:15672" target="_blank" rel="noopener">http://ip:15672</a> 使用admin 123456 进行登陆了。</p><p>到这里的话，每个节点是作为单独的一台RabbitMQ存在的，也可以正常提供服务了</p><h5 id="3、组成集群"><a href="#3、组成集群" class="headerlink" title="3、组成集群"></a>3、组成集群</h5><p>rabbitmq-server 启动时，会一起启动节点和应用，它预先设置RabbitMQ应用为standalone模式。要将一个节点加入到现有的集群中，你需要停止这个应用，并将节点设置为原始状态。如果使用./rabbitmqctl stop，应用和节点都将被关闭。所以使用rabbitmqctl stop_app仅仅关闭应用。</p><p>1、将 node2、node3与 node1 组成集群，这里以node2为例</p><pre><code>node2# rabbitmqctl stop_app      node2# rabbitmqctl join_cluster rabbit@node1               ####这里集群的名字一定不要写错了node2# rabbitmqctl start_app</code></pre><p>2、将node3重复上述操作，也加入node1的集群。</p><pre><code>node3# rabbitmqctl stop_app      node3# rabbitmqctl join_cluster rabbit@node1               ####这里集群的名字一定不要写错了node3# rabbitmqctl start_app</code></pre><p>则此时 node2 与 node3 也会自动建立连接，集群配置完毕；</p><pre><code>#使用内存节点加入集群node2 # rabbitmqctl join_cluster --ram rabbit@node1</code></pre><p>3、在 RabbitMQ 集群任意节点上执行 <code>rabbitmqctl cluster_status</code>来查看是否集群配置成功。</p><pre><code>node3# rabbitmqctl cluster_statusCluster status of node rabbit@node3 ...[{nodes,[{disc,[rabbit@node1,rabbit@node2,rabbit@node3]}]}, {running_nodes,[rabbit@node1,rabbit@node2,rabbit@node3]}, {cluster_name,&lt;&quot;rabbit@node1&quot;&gt;},      #集群的名称默认为 rabbit@node1 {partitions,[]}, {alarms,[{rabbit@node1,[]},{rabbit@node2,[]},{rabbit@node3,[]}]}]</code></pre><p>4、也可通过在web页面上的“Queues”的列表中，查看有如下显示为“同步镜像到node2”，则也表示集群配置成功</p><p><img src="https://s1.ax1x.com/2020/04/26/JRmHfg.png" alt="JRmHfg.png"></p><p>5、设置镜像队列策略</p><p>在任意一个节点上执行如下操作（这里在node1上执行）</p><p>首先，在web界面，登陆后，点击“Admin–Virtual Hosts（页面右侧）”，在打开的页面上的下方的“Add a new virtual host”处增加一个虚拟主机，同时给用户“admin”和“guest”均加上权限（在页面直接设置、点点点即可）；</p><p>然后，在linux中执行如下命令</p><pre><code>rabbitmqctl set_policy -p coresystem  ha-all &quot;^&quot; &#39;{&quot;ha-mode&quot;:&quot;all&quot;}&#39;</code></pre><p>“coresystem” vhost名称， “^”匹配所有的队列， ha-all 策略名称为ha-all, ‘{“ha-mode”:”all”}’ 策略模式为 all 即复制到所有节点，包含新增节点。</p><p>则此时镜像队列设置成功。（这里的虚拟主机coresystem是代码中需要用到的虚拟主机，虚拟主机的作用是做一个消息的隔离，本质上可认为是一个rabbitmq-server，是否增加虚拟主机，增加几个，这是由开发中的业务决定，即有哪几类服务，哪些服务用哪一个虚拟主机，这是一个规划）。</p><p>6、镜像队列策略设置说明</p><pre><code>rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]-p Vhost： 可选参数，针对指定vhost下的queue进行设置Name: policy的名称Pattern: queue的匹配模式(正则表达式)Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode    ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes        all：表示在集群中所有的节点上进行镜像        exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定        nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定    ha-params：ha-mode模式需要用到的参数    ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manualpriority：可选参数，policy的优先级</code></pre><p>将所有队列设置为镜像队列，即队列会被复制到各个节点，各个节点状态保持一直。完成这 6 个步骤后，RabbitMQ 高可用集群搭建完成，最后一个步骤就是搭建均衡器。</p><p>7、安装并配置负载均衡器HA</p><p>注意：如果使用阿里云，可以使用阿里云的内网slb来实现负载均衡，不用自己搭建HA。</p><p>1、在192.168.101.11安装HAProxy</p><pre><code>yum -y install HAProxy</code></pre><p>2、修改 /etc/haproxy/haproxy.cfg</p><pre><code>vim /etc/haproxy/haproxy.cfgglobal     log         127.0.0.1 local2    chroot      /var/lib/haproxy    pidfile     /var/run/haproxy.pid    maxconn     4000    user        haproxy    group       haproxy    daemon    stats socket /var/lib/haproxy/statsdefaults        log        global        mode       tcp        option     tcplog        option     dontlognull        retries    3        option redispatch        maxconn 2000        contimeout      5s        clitimeout      120s        srvtimeout      120s listen rabbitmq_cluster 192.168.101.11:5670       mode      tcp        balance roundrobin        server rabbit1  192.168.101.11:5672 check inter 5000 rise 2 fall 2        server rabbit2  192.168.101.12:5672 check inter 5000 rise 2 fall 2        </code></pre><p>3、重启HAProxy</p><pre><code>service haproxy restart</code></pre><p>登录浏览器输入地址<a href="http://192.168.101.11:8100/rabbitmqstats查看HAProxy的状态" target="_blank" rel="noopener">http://192.168.101.11:8100/rabbitmqstats查看HAProxy的状态</a></p><p>三、常见问题</p><p>常见错误：</p><p>1、使用 rabbitmq-server -detached命令启动rabbitmq时，出现以下提示Warning: PID file not written; -detached was passed，此时使用rabbitmqctl status提示服务已启动，可知此问题不用解决。</p><p>2、由于更改hostname文件，在每次rabbitmqctl stop或者rabbitmqctl cluster_status等，只要是rabbitmq的命令就报错，提示大概如下</p><pre><code>Cluster status of node rabbit@web2 ...Error: unable to connect to node rabbit@web2: nodedownDIAGNOSTICS===========attempted to contact: [rabbit@web2]rabbit@web2:  * connected to epmd (port 4369) on web2  * epmd reports node &#39;rabbit&#39; running on port 25672  * TCP connection succeeded but Erlang distribution failed  * Hostname mismatch: node &quot;rabbit@mq2&quot; believes its host is different. Please ensure that hostnames resolve the same way locally and on &quot;rabbit@mq2&quot;current node details:- node name: &#39;rabbitmq-cli-11@web2&#39;- home dir: /root- cookie hash: SGwxMdJ3PjEXG1asIEFpBg==</code></pre><p>此时先<code>ps aux | grep mq</code>，然后<code>kill -9</code> 该进程，然后再<code>rabbitmq-server -detached</code>即可解决。（即先强杀，再重新启动）</p><p>3、使用<code>rabbitmqctl stop</code>，<code>rabbitmq-server -detached</code>重新启动后，原先添加的用户admin、虚拟主机coresystem等均丢失，还需要重新添加。</p><p>采用脚本启动，在脚本中写好启动好需要加载的各配置项（创建admin用户并授权，创建虚拟主机并授权，配置镜像队列）。</p><p>4、命令</p><pre><code>rabbitmqctl stop_app         #仅关闭应用，不关闭节点rabbitmqctl start_app         #开启应用rabbitmq--server -detached     #启动节点和应用rabbitmqctl    stop             #关闭节点和应用</code></pre><p>4、常用命令：</p><p>Rabbitmq服务器的主要通过rabbitmqctl和rabbimq-plugins两个工具来管理，以下是一些常用功能。</p><p>1、 服务器启动与关闭</p><pre><code>  启动: rabbitmq-server –detached  关闭: rabbitmqctl stop  若单机有多个实例，则在rabbitmqctl后加 –n 指定名称</code></pre><p>2、插件管理</p><pre><code>  开启某个插件：rabbitmq-plugins enable  xxx  关闭某个插件：rabbitmq-plugins disable xxx  注意：重启服务器后生效。</code></pre><p>3、virtual_host管理</p><pre><code>  新建virtual_host:rabbitmqctl add_vhost  xxx  撤销virtual_host:rabbitmqctl  delete_vhost xxx </code></pre><p>4、用户管理</p><pre><code>  新建用户：rabbitmqctl add_user xxxpwd  删除用户: rabbitmqctl delete_user xxx  查看用户：rabbitmqctl list_users  改密码: rabbimqctl change_password {username} {newpassword}  设置用户角色：rabbitmqctlset_user_tags {username} {tag ...}          Tag可以为 administrator,monitoring, management       </code></pre><p>5、 权限管理</p><pre><code>  权限设置：set_permissions [-pvhostpath] {user} {conf} {write} {read}  Vhostpath: Vhost路径  user: 用户名  Conf: 一个正则表达式match哪些配置资源能够被该用户访问。  Write: 一个正则表达式match哪些配置资源能够被该用户读。  Read: 一个正则表达式match哪些配置资源能够被该用户访问。</code></pre><p>6、获取服务器状态信息</p><pre><code> 服务器状态：rabbitmqctl status     ##其中可查看rabbitmq的版本信息</code></pre><p>7、获取集群状态信息</p><pre><code>rabbitmqctl cluster_status</code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx编译安装</title>
      <link href="2019/03/27/linux/nginx/nginx-bian-yi-an-zhuang/"/>
      <url>2019/03/27/linux/nginx/nginx-bian-yi-an-zhuang/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="nginx-编译安装与配置使用"><a href="#nginx-编译安装与配置使用" class="headerlink" title="nginx 编译安装与配置使用"></a>nginx 编译安装与配置使用</h4><h5 id="1、安装编译环境"><a href="#1、安装编译环境" class="headerlink" title="1、安装编译环境"></a>1、安装编译环境</h5><p>yum -y install gcc gcc-c++</p><h5 id="2、安装pcre软件包（使nginx支持http-rewrite模块）"><a href="#2、安装pcre软件包（使nginx支持http-rewrite模块）" class="headerlink" title="2、安装pcre软件包（使nginx支持http rewrite模块）"></a>2、安装pcre软件包（使nginx支持http rewrite模块）</h5><p>yum install -y pcre pcre-devel</p><h5 id="3、安装openssl-devel（使nginx支持ssl）"><a href="#3、安装openssl-devel（使nginx支持ssl）" class="headerlink" title="3、安装openssl-devel（使nginx支持ssl）"></a>3、安装openssl-devel（使nginx支持ssl）</h5><p>yum install -y openssl openssl-devel </p><h5 id="4、安装zlib"><a href="#4、安装zlib" class="headerlink" title="4、安装zlib"></a>4、安装zlib</h5><p>yum install -y zlib zlib-devel</p><h5 id="5、创建用户nginx"><a href="#5、创建用户nginx" class="headerlink" title="5、创建用户nginx"></a>5、创建用户nginx</h5><p>useradd nginx </p><p>passwd nginx</p><h5 id="6、安装nginx"><a href="#6、安装nginx" class="headerlink" title="6、安装nginx"></a>6、安装nginx</h5><pre class=" language-shell"><code class="language-shell">[root@localhost ～]#wget http://192.168.233.100/nginx.org/download/nginx-1.14.2.tar.gz</code></pre><pre class=" language-shell"><code class="language-shell">[root@localhost ～]#tar -vzxf nginx-1.14.2.tar.gz -C /usr/local[root@localhost ～]#cd nginx-1.14.2/ [root@localhost nginx-1.14.2]# ./configure \ --group=nginx \ --user=nginx \ --prefix=/usr/local/nginx \ --sbin-path=/usr/sbin/nginx \ --conf-path=/etc/nginx/nginx.conf \ --error-log-path=/var/log/nginx/error.log \ --http-log-path=/var/log/nginx/access.log \ --http-client-body-temp-path=/tmp/nginx/client_body \ --http-proxy-temp-path=/tmp/nginx/proxy \ --http-fastcgi-temp-path=/tmp/nginx/fastcgi \ --pid-path=/var/run/nginx.pid \ --lock-path=/var/lock/nginx \ --with-http_stub_status_module \ --with-http_ssl_module \ --with-http_gzip_static_module \ --with-pcre [root@localhost nginx-1.11.3]# make &&make install</code></pre><h5 id="7、Nginx-编译参数"><a href="#7、Nginx-编译参数" class="headerlink" title="7、Nginx 编译参数"></a>7、Nginx 编译参数</h5><pre class=" language-shell"><code class="language-shell"># 查看 nginx 安装的模块[root@tianyun ~]# nginx -V# 模块参数具体功能 --with-cc-opt='-g -O2 -fPIE -fstack-protector    //设置额外的参数将被添加到CFLAGS变量。（FreeBSD或者ubuntu使用）--param=ssp-buffer-size=4 -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2' --with-ld-opt='-Wl,-Bsymbolic-functions -fPIE -pie -Wl,-z,relro -Wl,-z,now' --prefix=/usr/share/nginx                        //指向安装目录--conf-path=/etc/nginx/nginx.conf                //指定配置文件--http-log-path=/var/log/nginx/access.log        //指定访问日志--error-log-path=/var/log/nginx/error.log        //指定错误日志--lock-path=/var/lock/nginx.lock                 //指定lock文件--pid-path=/run/nginx.pid                        //指定pid文件--http-client-body-temp-path=/var/lib/nginx/body    //设定http客户端请求临时文件路径--http-fastcgi-temp-path=/var/lib/nginx/fastcgi     //设定http fastcgi临时文件路径--http-proxy-temp-path=/var/lib/nginx/proxy         //设定http代理临时文件路径--http-scgi-temp-path=/var/lib/nginx/scgi           //设定http scgi临时文件路径--http-uwsgi-temp-path=/var/lib/nginx/uwsgi         //设定http uwsgi临时文件路径--with-debug                                        //启用debug日志--with-pcre-jit                                     //编译PCRE包含“just-in-time compilation”--with-ipv6                                         //启用ipv6支持--with-http_ssl_module                              //启用ssl支持--with-http_stub_status_module                      //获取nginx自上次启动以来的状态--with-http_realip_module                 //允许从请求标头更改客户端的IP地址值，默认为关--with-http_auth_request_module           //实现基于一个子请求的结果的客户端授权。如果该子请求返回的2xx响应代码，所述接入是允许的。如果它返回401或403中，访问被拒绝与相应的错误代码。由子请求返回的任何其他响应代码被认为是一个错误。--with-http_addition_module               //作为一个输出过滤器，支持不完全缓冲，分部分响应请求--with-http_dav_module                    //增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法 默认关闭，需编译开启--with-http_geoip_module                  //使用预编译的MaxMind数据库解析客户端IP地址，得到变量值--with-http_gunzip_module                 //它为不支持“gzip”编码方法的客户端解压具有“Content-Encoding: gzip”头的响应。--with-http_gzip_static_module            //在线实时压缩输出数据流--with-http_image_filter_module           //传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）--with-http_spdy_module                   //SPDY可以缩短网页的加载时间--with-http_sub_module                    //允许用一些其他文本替换nginx响应中的一些文本--with-http_xslt_module                   //过滤转换XML请求--with-mail                               //启用POP3/IMAP4/SMTP代理模块支持--with-mail_ssl_module                    //启用ngx_mail_ssl_module支持启用外部模块支持</code></pre><h5 id="8、修改配置文件-etc-nginx-nginx-conf"><a href="#8、修改配置文件-etc-nginx-nginx-conf" class="headerlink" title="8、修改配置文件/etc/nginx/nginx.conf"></a>8、修改配置文件/etc/nginx/nginx.conf</h5><pre class=" language-shell"><code class="language-shell"># 全局参数设置 worker_processes  1;          #设置nginx启动进程的数量，一般设置成与逻辑cpu数量相同 error_log  logs/error.log;    #指定错误日志 worker_rlimit_nofile 102400;  #设置一个nginx进程能打开的最大文件数 pid        /var/run/nginx.pid; events {     worker_connections  1024; #设置一个进程的最大并发连接数 } # http 服务相关设置 http {     include      mime.types;     default_type  application/octet-stream;     log_format  main  'remote_addr - remote_user [time_local] "request" '                      'status body_bytes_sent "$http_referer" '                      '"http_user_agent" "http_x_forwarded_for"';     access_log  /var/log/nginx/access.log  main;    #设置访问日志的位置和格式     sendfile          on; #是否调用sendfile函数输出文件，一般设置为on，若nginx是用来进行磁盘IO负载应用时，可以设置为off，降低系统负载     gzip              on;      #是否开启gzip压缩     keepalive_timeout  65;     #设置长连接的超时时间 # 虚拟服务器的相关设置     server {         listen      80;        #设置监听的端口         server_name  localhost;        #设置绑定的主机名、域名或ip地址         charset koi8-r;        # 设置编码字符         location / {             root  /var/www/nginx;           #设置服务器默认网站的根目录位置             index  index.html index.htm;    #设置默认打开的文档             }         error_page  500 502 503 504  /50x.html; #设置错误信息返回页面         location = /50x.html {             root  html;        #这里的绝对位置是/var/www/nginx/html         }     }  }</code></pre><h5 id="9、检测-nginx-配置文件是否正确"><a href="#9、检测-nginx-配置文件是否正确" class="headerlink" title="9、检测 nginx 配置文件是否正确"></a>9、检测 nginx 配置文件是否正确</h5><pre class=" language-shell"><code class="language-shell">[root@localhost ~]#/usr/local/nginx/sbin/nginx -t</code></pre><h5 id="10、启动nginx服务"><a href="#10、启动nginx服务" class="headerlink" title="10、启动nginx服务"></a>10、启动nginx服务</h5><pre class=" language-shell"><code class="language-shell">/usr/local/nginx/sbin/nginx</code></pre><h5 id="11、通过-nginx-命令控制-nginx-服务"><a href="#11、通过-nginx-命令控制-nginx-服务" class="headerlink" title="11、通过 nginx 命令控制 nginx 服务"></a>11、通过 nginx 命令控制 nginx 服务</h5><pre class=" language-shell"><code class="language-shell">nginx -c /path/to/nginx.conf       # 以特定目录下的配置文件启动nginx:nginx -s reload                      # 修改配置后重新加载生效nginx -s reopen                     # 重新打开日志文件nginx -s stop                        # 快速停止nginxnginx -s quit                         # 完整有序的停止nginxnginx -t                         # 测试当前配置文件是否正确nginx -t -c /path/to/nginx.conf  # 测试特定的nginx配置文件是否正确</code></pre><h5 id="12、实现nginx开机自启"><a href="#12、实现nginx开机自启" class="headerlink" title="12、实现nginx开机自启"></a>12、实现nginx开机自启</h5><p> a、添加启动脚本  vim /etc/init.d/nginx</p><pre class=" language-shell"><code class="language-shell">#!/bin/sh # # nginx - this script starts and stops the nginx daemon # # chkconfig:  - 85 15  # description:  Nginx is an HTTP(S) server, HTTP(S) reverse \ #              proxy and IMAP/POP3 proxy server # processname: nginx # config:      /etc/nginx/nginx.conf # config:      /etc/sysconfig/nginx # pidfile:    /var/run/nginx.pid # Source function library. . /etc/rc.d/init.d/functions# Source networking configuration. . /etc/sysconfig/network# Check that networking is up. [ "$NETWORKING" = "no" ] && exit 0 nginx="/usr/sbin/nginx"prog=$(basename $nginx) NGINX_CONF_FILE="/etc/nginx/nginx.conf"[ -f /etc/sysconfig/nginx ] && . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() {   # make required directories   user=`nginx -V 2>&1 | grep "configure arguments:" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -`   options=`$nginx -V 2>&1 | grep 'configure arguments:'`   for opt in $options; do      if [ `echo $opt | grep '.*-temp-path'` ]; then          value=`echo $opt | cut -d "=" -f 2`           if [ ! -d "$value" ]; then              # echo "creating" $value               mkdir -p $value && chown -R $user $value           fi      fi  done} start() {     [ -x $nginx ] || exit 5     [ -f $NGINX_CONF_FILE ] || exit 6     make_dirs     echo -n $"Starting $prog: "    daemon $nginx -c $NGINX_CONF_FILE     retval=$?     echo    [ $retval -eq 0 ] && touch $lockfile     return $retval } stop() {     echo -n $"Stopping $prog: "    killproc $prog -QUIT     retval=$?     echo    [ $retval -eq 0 ] && rm -f $lockfile     return $retval } restart() {     configtest || return $?     stop     sleep 1     start } reload() {     configtest || return $?     echo -n $"Reloading $prog: "    killproc $nginx -HUP     RETVAL=$?     echo} force_reload() {     restart } configtest() {   $nginx -t -c $NGINX_CONF_FILE } rh_status() {     status $prog } rh_status_q() {     rh_status >/dev/null 2>&1 } case "$1" in    start)         rh_status_q && exit 0         $1         ;;     stop)         rh_status_q || exit 0         $1         ;;     restart|configtest)         $1         ;;     reload)         rh_status_q || exit 7         $1         ;;     force-reload)         force_reload         ;;     status)         rh_status         ;;     condrestart|try-restart)         rh_status_q || exit 0             ;;     *)         echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}"        exit 2 esac</code></pre><p>b、添加权限</p><pre class=" language-shell"><code class="language-shell">chmod +x /etc/init.d/nginx</code></pre><p>c、重载系统启动文件</p><pre class=" language-shell"><code class="language-shell">systemctl daemon-reload</code></pre><p>d、设置开机自启</p><pre class=" language-shell"><code class="language-shell">systemctl start nginx</code></pre><p>10、nginx 日志文件详解</p><p>​    nginx 日志文件分为 <strong>log_format</strong> 和 <strong>access_log</strong> 两部分</p><p>​    log_format 定义记录的格式，其语法格式为</p><p>​    log_format        样式名称        样式详情</p><p>​    配置文件中默认有</p><pre><code>log_format  main  &#39;remote_addr - remote_user [time_local] &quot;request&quot; &#39;                  &#39;status body_bytes_sent &quot;$http_referer&quot; &#39;                  &#39;&quot;http_user_agent&quot; &quot;http_x_forwarded_for&quot;&#39;;</code></pre><table><thead><tr><th>点击这里</th><th>点击这里</th></tr></thead><tbody><tr><td>变量</td><td>说明</td></tr><tr><td>$remote_addr和$http_x_forwarded_for</td><td>客户端的ip</td></tr><tr><td>$remote_user</td><td>客户端的名称</td></tr><tr><td>$time_local</td><td>访问时的本地时间</td></tr><tr><td>$request</td><td>请求的URL和http协议</td></tr><tr><td>$status</td><td>访问的状态码</td></tr><tr><td>$body_bytes_sent</td><td>发送给客户端的主体内容大小</td></tr><tr><td>$http_referer</td><td>记录客户端是从哪个页面链接访问过来的，若没有链接，则访问‘-’</td></tr><tr><td>$http_user_agent</td><td>记录客户端使用的浏览器的相关信息</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables笔记</title>
      <link href="2019/02/28/linux/iptables-bi-ji/"/>
      <url>2019/02/28/linux/iptables-bi-ji/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="防火墙之-iptables"><a href="#防火墙之-iptables" class="headerlink" title="防火墙之 iptables"></a>防火墙之 iptables</h3><h2 id="1-1-安全优化配置原则"><a href="#1-1-安全优化配置原则" class="headerlink" title="1.1 安全优化配置原则"></a>1.1 安全优化配置原则</h2><p>尽可能不给服务器配置外网ip ,可以通过代理转发或者通过防火墙映射.并发不是特别大情况有外网ip,可以开启防火墙服务.</p><p>大并发的情况，不能开iptables,影响性能，利用硬件防火墙提升架构安全</p><h3 id="1-1-1-生产中-iptables-的实际应用"><a href="#1-1-1-生产中-iptables-的实际应用" class="headerlink" title="1.1.1 生产中 iptables 的实际应用"></a>1.1.1 生产中 iptables 的实际应用</h3><p>主要应用方向</p><p>1、主机防火墙（filter表的INPUT链）。</p><p>2、局域网共享上网(nat 表的 POSTROUTING 链)。半个路由器，NAT功能。</p><p>3、端口及IP映射(nat 表的 PREROUTING 链)，硬防的NAT功能。</p><p>4、IP一对一映射。</p><p><strong>其他说明：</strong></p><blockquote><p> ①iptables是基于内核的防火墙，功能非常强大，基于数据包的过滤！特别是可以在一台非常低的硬件配置下跑的非常好。</p><p> 　　<strong>注：</strong>iptables主要工作在OSI七层的2.3.4层。七层的控制可以使用squid代理+iptables。</p><p> ②iptabes：生产中根据具体情况，一般，内网关闭，外网打开。大并发的情况不能开iptables，影响性能，iptables是要消耗CPU的，所以大并发的情况下，我们使用硬件防火墙的各方面做的很仔细。selinux：生产中也是关闭的。可以做ids的入侵检测。</p><p> ③实际生产中尽可能不给服务器配置外网IP。可以通过代理转发。比如，nagios就不需要外网。</p><p> ④并发不是很大的情况下，再外网的IP环境，开防火墙。</p><p> ⑤第一次直接默认规则生成配置文件，以后就在配置文件中进行修改（编辑添加删除）。</p><p> ⑥封掉IP：根据IP地址和网络连接数进行封杀。（定时任务，定时封掉，判断，存在就不再进行二次封杀）</p></blockquote><h3 id="1-1-2-常用案例功能小结："><a href="#1-1-2-常用案例功能小结：" class="headerlink" title="1.1.2 常用案例功能小结："></a>1.1.2 常用案例功能小结：</h3><p>1）linux主机防火墙，单机作为防火墙（表filter）。</p><p>2）局域网共享上网（表nat postrouting）。</p><p>3）外部地址映射为内部地址和端口（表nat prerouting）</p><h2 id="1-2-iptables-防火墙简介"><a href="#1-2-iptables-防火墙简介" class="headerlink" title="1.2 iptables 防火墙简介"></a>1.2 iptables 防火墙简介</h2><p>Netfilter/Iptables(以下简称Iptables)是unix/linux自带的一款优秀且开放源代码的完全自由的基于包过滤的防火墙工具，它的功能十分强大，使用非常灵活，可以对流入和流出服务器的数据包进行很精细的控制.特别是它可以在一台非常低的硬件配置服务器上跑的非常好（赛扬500HZ cpu 64M 内存的惲况下部署网关防火墙），提供近400人的上网服务丝毫不逊色专业路由器防火墙。 iptables + zebra + squid (常用网络开源产品）。</p><p>   iptables是linux2.4及2.6内核中集成的服务，其功能与安全性比其老一蜚ipfwadm，ipchains 强大的多，iptables主要工作在0SI七层的二、三、四层，如果重新编译内核，iptables也可以支持 7 层控制（squid代理+iptables）。</p><h3 id="1-2-1-iptables名词和术语"><a href="#1-2-1-iptables名词和术语" class="headerlink" title="1.2.1 iptables名词和术语"></a>1.2.1 iptables名词和术语</h3><p>不少刚接触到iptables的朋友可能会对iptables防火墙的相关名词搞的很晕，不知道其所云的具体意思，而是就最基本的能让大家容易快速理解和掌握的思路来描述：</p><p>容器：包含或者说属于的关系</p><h3 id="1-2-2-什么是容器"><a href="#1-2-2-什么是容器" class="headerlink" title="1.2.2 什么是容器"></a>1.2.2 什么是容器</h3><p>谁不知道啊，容器就是装东西的，如（箱、包、坛）。没错，恭喜你答对了.词典里解释说，容器就是用来包装或装载物品的贮存器（如箱、罐、坛）或者成形或柔软不成形的包覆材料.</p><p>在iptables里的呢，就是用来描述这种包含或者说属于的关系。</p><h3 id="1-2-3-什么是-Netfilter-iptables"><a href="#1-2-3-什么是-Netfilter-iptables" class="headerlink" title="1.2.3 什么是 Netfilter/iptables ?"></a>1.2.3 什么是 Netfilter/iptables ?</h3><p>Netfilter是表（tables）的容器，这样解释大家肯定还是晕。举个例子，如果把Netfilter看成是某个小区的一栋楼。那么表（tables)就是楼里的其中的一套房子。这套房子”表（tables)”属于这栋“Netfilter”。</p><h3 id="1-2-4-什么是表（tables）？"><a href="#1-2-4-什么是表（tables）？" class="headerlink" title="1.2.4 什么是表（tables）？"></a>1.2.4 什么是表（tables）？</h3><p>表（tables）是链的容器，即所有的链（chains）都属于其对应的表（tables）.如上，如果把Netfilter看成是某个小区的一栋楼.那么表（tables）就是楼里的其中的一套房子。</p><h3 id="1-2-5-什么是链（chains）？"><a href="#1-2-5-什么是链（chains）？" class="headerlink" title="1.2.5 什么是链（chains）？"></a>1.2.5 什么是链（chains）？</h3><p>链（chains）是规则（Policys）的容器。接上，如果把表（tables）当作有一套房子，那么链（chains）就可以说是房子里的家具（柜子等）。</p><h3 id="1-2-6-什么是规则（Policy）？"><a href="#1-2-6-什么是规则（Policy）？" class="headerlink" title="1.2.6 什么是规则（Policy）？"></a>1.2.6 什么是规则（Policy）？</h3><p>规则（Policy）就比较容易理解了，就是iptables系列过滤信息的规范和具体方法条款了.可以理解为柜子如何增加并摆放柜子东西等。</p><p>基本术语如下表格所示：</p><table><thead><tr><th><strong>Netfilter</strong></th><th><strong>表（tables**</strong>）**</th><th><strong>链（chains**</strong>）**</th><th><strong>规则（Policy**</strong>）**</th></tr></thead><tbody><tr><td><strong>一栋楼</strong></td><td>楼里的房子</td><td>房子里的柜子</td><td>柜子里衣服，摆放规则</td></tr></tbody></table><h2 id="1-3-iptables-表和链"><a href="#1-3-iptables-表和链" class="headerlink" title="1.3 iptables 表和链"></a>1.3 iptables 表和链</h2><p>描述完iptables术语后，相信大家对iptables的表和链有了初步的了解了，默认情况下，iptables根据功能和表的定义划分包含三个表，filter,nat,mangle,其每个表又包含不同的操作链（chains )。 实际iptables包含4张表和五个链,巧主要记住两张表即可filter和nat表即可。</p><p>下面表格展示了表和链的对应关系。</p><p><strong>四个表：</strong></p><table><thead><tr><th><strong>表（tables**</strong>）**</th><th><strong>链（chains**</strong>）**</th></tr></thead><tbody><tr><td><strong>Filter</strong> 1</td><td>这是默认表，实现防火墙数据过滤功能。</td></tr><tr><td>1-<strong>INPUT</strong></td><td>对于指定到本地套接字的包，即到达本地防火墙服务器的数据包。</td></tr><tr><td>1-<strong>FORWARD</strong></td><td>路由穿过的数据包，即经过本地防火墙服务器的数据包。</td></tr><tr><td>1-<strong>OUTPUT</strong></td><td>本地创建的数据包</td></tr><tr><td><strong>NAT</strong>2</td><td>当遇到新创建的数据包连接时将参考这个表</td></tr><tr><td>2-<strong>FREROUTING</strong></td><td>一进来就对数据包进行改变</td></tr><tr><td>2-<strong>OUTPUT</strong></td><td>本地创建的数据包在路由前进行改变</td></tr><tr><td>2-<strong>POSTROUTING</strong></td><td>在数据包即将出去时改变数据包信息</td></tr><tr><td><strong>Mangle</strong>3</td><td>这个表专门用于改变数据包</td></tr><tr><td>3-<strong>INPUT</strong></td><td>进入到设备本身的包</td></tr><tr><td>3-<strong>FORWARD</strong></td><td>对路由后的数据包信息进行修改</td></tr><tr><td>3-<strong>FREROUTING</strong></td><td>在路由之前更改传入的包</td></tr><tr><td>3-<strong>OUTPUT</strong></td><td>本地创建的数据包在路由之前改变</td></tr><tr><td>3-<strong>POSTROUTING</strong></td><td>在数据包即将离开时更改数据包信息</td></tr><tr><td><strong>raw</strong>4</td><td><strong>此表用处较少，可以忽略不计。</strong>This  table is used mainly for configuring exemptions from connection tracking in combination with the  NOTRACK  target.</td></tr><tr><td>4-<strong>PREROUTING</strong></td><td>for packets arriving via any network interface</td></tr><tr><td>4-<strong>OUTPUT</strong></td><td>for packets  generated by local processes</td></tr></tbody></table><p><strong>五个链</strong></p><table><thead><tr><th><strong>表（tables**</strong>）**</th><th><strong>链（chains**</strong>）**</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>INPUT</td><td>FORWARD</td><td>OUTPUT</td><td>PREROUTING</td><td>POSTROUTING</td><td></td></tr><tr><td><strong>Filter</strong></td><td>√</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td><strong>NAT</strong></td><td><strong>×</strong></td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td><strong>Managle</strong></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><strong>raw</strong></td><td>×</td><td>×</td><td>√</td><td>√</td><td>×</td></tr><tr><td>说明：√ 表示有，× 表示无。</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://s1.ax1x.com/2020/04/26/JRnutO.png" alt="JRnutO.png"></p><p>图 - iptables中的表与链的结构关系</p><h3 id="1-3-1-filter表的详细介绍"><a href="#1-3-1-filter表的详细介绍" class="headerlink" title="1.3.1 filter表的详细介绍"></a>1.3.1 filter表的详细介绍</h3><table><thead><tr><th><strong>filter**</strong>表**</th><th>主要和主机自身相关，真正负责主机防火墙功能的（过滤流入流出主机的数据包）filter表是iptables默认使用的表，这个表定义了三个链（chains）<strong>工作场景:**</strong>主机防火墙**</th></tr></thead><tbody><tr><td><strong>INPUT</strong></td><td>负责过滤所有目标是本机地址的数据包通俗来说：就是过滤进入主机的数据包</td></tr><tr><td><strong>FORWARD</strong></td><td>负责转发流经主机的数据包。起到转发的作用，和NAT关系很大。LVS NAT 模式，net.ipv4.ip_forward=0</td></tr><tr><td><strong>OUTPUT</strong></td><td>处理所有源地址是本机地址的数据包通俗的讲：就是处理从主机发出的数据包</td></tr></tbody></table><p>   对于filter表的控制是我们实现本机防火墙功能的重要手段，特别是INPUT链的控制。</p><h3 id="1-3-2-NAT表信息详细介绍"><a href="#1-3-2-NAT表信息详细介绍" class="headerlink" title="1.3.2 NAT表信息详细介绍"></a>1.3.2 NAT表信息详细介绍</h3><table><thead><tr><th>NAT表</th><th>负责网络地址转换的，即来源与目的的IP地址和port的转换。应用：和主机本身无关，一般用于局域网共享上网或者特殊的端口转换相关.<strong>工作场景：</strong>1、用于路由(zebra)或网关(iptables),共享上网(POSTROUTING)2、做内部外部IP地址一对一映射(dmz),硬件防火墙映射IP到内部服务器，FTP服务(PREROUTING)3、WEB,单个端口的映射，直接映射80端口(PREROUTING)这个表定义了3个链，nat功能相当于网络的acl控制。和网络交换机acl类似。</th></tr></thead><tbody><tr><td><strong>OUTPUT</strong></td><td>和主机放出去的数据包有关，改变主机发出数据包的目的地址。</td></tr><tr><td><strong>PREROUTING</strong></td><td>在数据包到达防火墙时，进行路由判断之前执行的规则，作用是改变数据包的目的地址、目的端口等就是收信时，根据规则重写收件人的地址例如：把公网IP： xxx.xxx.xxx.xxx 映射到局域网的 x.x.x.x 服务器如果是web服务，可以把80转换为局域网的服务器9000端口上。</td></tr><tr><td><strong>POSTROUTING</strong></td><td>在数据包离开防火墙时进行路由判断之后执行的规则，作用改变数据包的源地址，源端口等。写好收件人的地址，要让家人回信时能够有地址可回。例如。默认笔记本和虚拟机都是局域网地址，在出网的时候被路由器将源地址改为公网地址。<strong>生产应用：</strong>局域网共享上网。</td></tr></tbody></table><h3 id="1-3-3-Mangle表信息详细介绍"><a href="#1-3-3-Mangle表信息详细介绍" class="headerlink" title="1.3.3 Mangle表信息详细介绍"></a>1.3.3 Mangle表信息详细介绍</h3><table><thead><tr><th>Mangle表</th><th>主要负责修改数据包中特殊的路由标记，如TTL,TOS,MARK等，这个表定义了5个链(chains).</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>由于这个表与特殊标记相关，一般倩况下，我们用不到这个mangle表。</p><p>这里就不做详细介绍了。</p><h2 id="1-4-iptables工作流程"><a href="#1-4-iptables工作流程" class="headerlink" title="1.4 iptables工作流程"></a>1.4 iptables工作流程</h2><h3 id="1-4-1-工作流程说明"><a href="#1-4-1-工作流程说明" class="headerlink" title="1.4.1 工作流程说明"></a>1.4.1 工作流程说明</h3><p>前面介绍已经提到，iptables是采用数据包过滤机制工作的，所以它会对请求的数据包的包头数据进行分析，并根据我们预先设定的规则进行匹配来决定是否可以进入主机。</p><p>iptables是采用数据包过滤机制工作的，所以它会对请求的数据包的包头数据进行分析，并根据我们预先设定的规则进行匹配来决定是否可以进入主机。</p><p>数据包的流向是从左向右的。</p><p><img src="https://s1.ax1x.com/2020/04/26/JRnXCD.png" alt="JRnXCD.png">图 - iptables包处理流程图</p><p> <img src="https://s1.ax1x.com/2020/04/26/JRupDI.png" alt="JRupDI.png"></p><p>图 - iptables包处理流程图(简化)</p><p><strong>抽象说明：</strong>上图可以用北京地铁1,2号线来描述：</p><p>1号线：主要是NAT功能</p><blockquote><p> 案例：</p><p> 　　1)局域网上网共享（路由和网关），使用NAT的POSTROUTING链。</p><p> 　　2)外部IP和端口映射为内部IP和端口（DMZ功能），使用NAT的PREROUTING链</p></blockquote><p>2号线：主要是FILTER功能，即防火墙功能FILTER INPUT FORWARD</p><blockquote><p>案例：</p><p>　　主要应用就是主机服务器防火墙，使用FILTER的INPUT链</p></blockquote><p> <img src="https://s1.ax1x.com/2020/04/26/JRuPVP.png" alt="JRuPVP.png"></p><p>图 - iptables数据包转发流程图</p><h3 id="1-4-2-iptables工作流程小结"><a href="#1-4-2-iptables工作流程小结" class="headerlink" title="1.4.2 iptables工作流程小结"></a>1.4.2 iptables工作流程小结</h3><blockquote><p>1、防火墙是一层层过滤的。实际是按照配置规则的顺序从上到下，从前到后进行过滤的。</p><p>2、如果匹配上了规则，即明确表明是阻止还是通过，此时数据包就不在向下匹配新规则了。</p><p>3、如果所有规则中没有明确表明是阻止还是通过这个数据包，也就是没有匹配上规则，向下进行匹配，直到匹配默认规则得到明确的阻止还是通过。</p><p>4、防火墙的默认规则是对应链的所有的规则执行完以后才会执行的（最后执行的规则）。</p></blockquote><h2 id="1-5-iptables操作"><a href="#1-5-iptables操作" class="headerlink" title="1.5 iptables操作"></a>1.5 iptables操作</h2><p>系统环境说明</p><pre><code>[root@clsn ~]# cat /etc/redhat-release CentOS release 6.9 (Final)[root@clsn ~]# hostname -I10.0.0.188 172.16.1.188</code></pre><p>软件版本</p><pre><code>[root@clsn ~]# iptables -Viptables v1.4.7</code></pre><h3 id="1-5-1-iptables参数说明"><a href="#1-5-1-iptables参数说明" class="headerlink" title="1.5.1 iptables参数说明"></a>1.5.1 iptables参数说明</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>参数说明</strong></th><th></th><th></th></tr></thead><tbody><tr><td><strong>显示相关参数</strong></td><td></td><td></td><td></td></tr><tr><td><strong>-n/–numeric</strong></td><td>以数字的方式显示地址或端口信息</td><td></td><td></td></tr><tr><td><strong>-L/ –list</strong></td><td>列出一个链或所有链中的规则信息</td><td></td><td></td></tr><tr><td><strong>–list-rules/-S</strong></td><td>Print the rules in a chain or all chains</td><td></td><td></td></tr><tr><td><strong>–line-number</strong></td><td>当列出规则信息时，打印规则行号</td><td></td><td></td></tr><tr><td><strong>-v</strong></td><td>显示详细信息，可以叠加</td><td></td><td></td></tr><tr><td><strong>-h</strong></td><td>显示帮助信息</td><td></td><td></td></tr><tr><td><strong>初始化相关参数</strong></td><td></td><td></td><td></td></tr><tr><td><strong>iptables -F</strong></td><td>清除所有规则，不会处理默认的规则</td><td></td><td></td></tr><tr><td><strong>iptables -X</strong></td><td>删除用户自定义的链</td><td></td><td></td></tr><tr><td><strong>iptables -Z</strong></td><td>链的计数器清零（数据包计数器与数据包字节计数器）</td><td></td><td></td></tr><tr><td><strong>配置常用参数</strong></td><td></td><td></td><td></td></tr><tr><td><strong>-t</strong> <strong>表名称</strong></td><td>指定配置哪个表，指定配置表名称。</td><td></td><td></td></tr><tr><td><strong>–append/-A</strong> <strong>链名称</strong></td><td>附加或追加上相应规则策略，到指定链(链名称必须大写)，默认将配置的规则插入到最后一条。</td><td></td><td></td></tr><tr><td><strong>–check/-C</strong></td><td>Check for the existence of a rule</td><td></td><td></td></tr><tr><td><strong>–insert/-I</strong> <strong>链名称</strong></td><td>插入相应规则策略，到指定链上，默认将配置的规则插入到第一条（可以根据规则序号插入到指定位置）–封IP地址使用。</td><td></td><td></td></tr><tr><td><strong>–delete/-D</strong> <strong>链名称</strong></td><td>删除指定的规则(可以根据规则序号进行删除)</td><td></td><td></td></tr><tr><td><strong>–replace/-R</strong></td><td>Replace rule rulenum (1 = first) in chain</td><td></td><td></td></tr><tr><td><strong>-P(**</strong>大写)<strong>**链名称</strong></td><td>改变链上的最终默认规则策略</td><td></td><td></td></tr><tr><td><strong>–new/-N</strong></td><td>创建新的用户定义链</td><td></td><td></td></tr><tr><td><strong>-p</strong> <strong>协议名称**</strong>[!] –proto**</td><td>指定规则的协议名称 all tcp udp icmp</td><td></td><td></td></tr><tr><td><strong>–dport</strong></td><td>指定匹配的目标端口信息</td><td></td><td></td></tr><tr><td><strong>–sport</strong></td><td>指定匹配的源端口信息</td><td></td><td></td></tr><tr><td><strong>-j</strong> <strong>动作</strong></td><td>匹配数据包后的动作</td><td></td><td></td></tr><tr><td><strong>ACCEPT</strong></td><td>允许</td><td></td><td></td></tr><tr><td><strong>DROP</strong></td><td>丢弃(没有响应)</td><td></td><td></td></tr><tr><td><strong>REJECT</strong></td><td>拒绝(回应请求者明确的拒绝)</td><td></td><td></td></tr><tr><td><strong>MASQUERADE</strong></td><td>伪装上网时使用</td><td></td><td></td></tr><tr><td><strong>SNAT</strong></td><td>共享地址上网</td><td></td><td></td></tr><tr><td><strong>DNAT</strong></td><td>目的地址改写</td><td></td><td></td></tr><tr><td><strong>-i**</strong>[!] –in-interface**</td><td>在INPUT链配置规则中，指定从哪一个网卡接口进入的流量（只能配置在INPUT链上）</td><td></td><td></td></tr><tr><td><strong>-o**</strong>[!] –out-interface**</td><td>在OUTPUT链配置规则中，指定从哪一个网接口出去的流量（只能配置在OUTPUT链上）</td><td></td><td></td></tr><tr><td><strong>-s</strong> <strong>[!] –source</strong></td><td>指定源IP地址或源网段信息</td><td></td><td></td></tr><tr><td><strong>-d**</strong>[!] –destination**</td><td>指定目标IP地址或目标网段信息</td><td></td><td></td></tr><tr><td><strong>扩展参数</strong></td><td></td><td></td><td></td></tr><tr><td><strong>-m</strong> <strong>模块</strong></td><td>表示增加扩展，匹配功能扩展匹配（可以加载扩展参数）</td><td></td><td></td></tr><tr><td><strong>multiport</strong></td><td>实现不连续多端口扩展匹配</td><td></td><td></td></tr><tr><td><strong>icmp</strong></td><td>使用icmp的扩展</td><td></td><td></td></tr><tr><td><strong>state</strong></td><td>状态模块扩展</td><td></td><td></td></tr><tr><td><strong>–icmp-type</strong></td><td>只有类型8是真正会影响ping，或者也可以采用any；了解很多icmp类型<em>iptables -p icmp -h</em></td><td></td><td></td></tr><tr><td><strong>–limit n/{second/minute/hour}</strong></td><td>指定时间内的请求速率”n”为速率，后面为时间分别为：秒分 时</td><td></td><td></td></tr><tr><td><strong>–limit-burst [n]</strong></td><td>在同一时间内允许通过的请求”n”为数字，不指定默认为5</td><td></td><td></td></tr><tr><td><strong>–exact/-x</strong></td><td>扩展数字（显示精确数值）</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>!**</strong>的使用实例**</p><pre><code>[root@clsn ~]# iptables ! -VNot 1.4.7 ;-)[root@clsn ~]# iptables  -Viptables v1.4.7</code></pre><p>注意：在iptables中所有链名必须大写，表明必须小写，动作必须大写，匹配必须小写。</p><h3 id="1-5-2-配置前准备"><a href="#1-5-2-配置前准备" class="headerlink" title="1.5.2 配置前准备"></a>1.5.2 配置前准备</h3><p>在配置防火墙首先要其中防火墙</p><pre><code>[root@clsn ~]# /etc/init.d/iptables start iptables: Applying firewall rules:                         [  OK  ]</code></pre><p>清除iptables所有规则</p><pre><code>[root@clsn ~]# iptables -Z[root@clsn ~]# iptables -X[root@clsn ~]# iptables -F</code></pre><p>查看iptables的规则</p><pre><code>[root@clsn ~]# iptables -nvLChain INPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination         Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination         Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination</code></pre><p>查看其他的表配置（-t 参数）</p><pre><code>[root@clsn ~]# iptables -nL -t rawChain PREROUTING (policy ACCEPT)target     prot opt source               destination         Chain OUTPUT (policy ACCEPT)target     prot opt source               destination</code></pre><p>查看配置规则的顺序号</p><pre><code>[root@clsn ~]# iptables -nvL -line-number--line-number #  显示规则的序号</code></pre><h2 id="1-6-iptables-filter表配置实例"><a href="#1-6-iptables-filter表配置实例" class="headerlink" title="1.6 iptables filter表配置实例"></a>1.6 iptables filter表配置实例</h2><h3 id="1-6-1-基础配置"><a href="#1-6-1-基础配置" class="headerlink" title="1.6.1 基础配置"></a>1.6.1 基础配置</h3><p><strong>配置实例一：</strong>配置22/ssh端口访问控制规则</p><pre><code>iptables -A INPUT -p tcp --dprot 22 -j DROP     # 禁止所有人访问22端口iptables -I INPUT -p tcp --dprot 22 -j ACCEPT   # 恢复连接方法iptables -I INPUT 2 -p tcp --dprot 22 -j ACCEPT # 通过插入指定行号信息，指定将规则插入到第几行iptables -D INPUT -p tcp --dport 22 -j ACCEPT   # 删除指定规则iptables -D INPUT 2                             # 根据规则行号，删除相应的规则</code></pre><p>只允许10.0.0.1的ip通过ssh连接这台服务器</p><pre><code>iptables -I INPUT -s 10.0.0.1 -p tcp --dport 22 -j ACCEPT </code></pre><p>配置实例二：禁止网段连入（禁止172.16.1.0网段访问172.16.1.188）</p><pre><code>iptables -A INPUT  -s 172.16.1.0/24 -d 172.16.1.188  -j DROP</code></pre><p>配置实例三：禁止某个172.16.1.0网段访问服务器主机的22端口</p><pre><code>iptables -A INPUT -s 172.16.1.0/24 -d 172.16.1.188  -p tcp --dport 22 -j DROP</code></pre><p>方向说明：</p><pre><code># 在入方向控制iptables -I INPUT -i eth0  -p tcp --dport 22 -j ACCEPT# 在出方向控制iptables -I OUTPUT -o eth0  -p tcp --sport 22 -j DROP</code></pre><h3 id="1-6-2-配置实例四：除10-0-0-0网段可以进行连接服务器主机意外，其余网段都禁止"><a href="#1-6-2-配置实例四：除10-0-0-0网段可以进行连接服务器主机意外，其余网段都禁止" class="headerlink" title="1.6.2 配置实例四：除10.0.0.0网段可以进行连接服务器主机意外，其余网段都禁止"></a>1.6.2 配置实例四：除10.0.0.0网段可以进行连接服务器主机意外，其余网段都禁止</h3><p>  <em>第一种方式：</em></p><pre><code>iptables -A INPUT -s 10.0.0.0/24 -d 172.16.1.8  -j ACCEPT</code></pre><p>   修改默认规则，将默认规则改为拒绝</p><p><em>第二种方式：</em></p><p>   ！  — 表示对规则信息进行取反</p><pre><code>iptables -A INPUT ! -s 10.0.0.0/24 -d 172.16.1.8  -j DROP   --- centos6用法iptables -A INPUT -s ! 10.0.0.0/24 -d 172.16.1.8  -j DROP   --- centos5用法</code></pre><p>说明：只有iptables帮助手册中指定的参数可以用取反符号（iptables –help）</p><h3 id="1-6-3-配置实例五：测试匹配列举端口范围。"><a href="#1-6-3-配置实例五：测试匹配列举端口范围。" class="headerlink" title="1.6.3 配置实例五：测试匹配列举端口范围。"></a>1.6.3 配置实例五：测试匹配列举端口范围。</h3><pre><code>iptables -A INPUT -p tcp --dport 22:80 -j DROP                 # 设置连续多端口控制策略iptables -A INPUT -p tcp -m multiport  --dport 22,80 -j DROP   # 设置不连续多端口控制策略</code></pre><p>   -m 参数表示增加扩展匹配功能，multiport 实现不连续多端口扩展匹配</p><h3 id="1-6-4-配置实例六：匹配ICMP类型"><a href="#1-6-4-配置实例六：匹配ICMP类型" class="headerlink" title="1.6.4 配置实例六：匹配ICMP类型"></a>1.6.4 配置实例六：匹配ICMP类型</h3><p>   禁止ping策略原则</p><p>   iptables服务器是ping命令发起者或是接受者</p><p><strong>发起者：</strong></p><p>input链： 禁止icmp-type 0        0 Echo Reply——回显应答（Ping应答)</p><pre><code>iptables -A INPUT -i eth0 -p icmp --icmp-type 0 -j DROP</code></pre><p>output链： 禁止icmp-type 8     8 Echo request——回显请求（Ping请求）</p><pre><code>iptables -A OUTPUT -o eth0 -p icmp --icmp-type 8 -j DROP</code></pre><p>   <strong>接受者：</strong></p><p>input链： 禁止icmp-type 8      8 Echo request——回显请求（Ping请求）</p><pre><code>iptables -A INPUT -i eth0 -p icmp --icmp-type 8 -j DROP </code></pre><p>output链： 禁止icmp-type 0     0 Echo Reply——回显应答（Ping应答)</p><pre><code>iptables -A OUTPUT -o eth0 -p icmp --icmp-type 0 -j DROP</code></pre><p>简化配置：</p><pre><code>iptables -A INPUT -i eth0 -p icmp -m icmp --icmp-type any -j DROP  #禁止所有类型的icmp</code></pre><p>   指定类型禁止icmp</p><pre><code>iptables -A INPUT -p icmp --icmp-type 8iptables -A INPUT -p icmp --icmp-type 8 -j DROPiptables -A INPUT -p icmp -m icmp --icmp-type any -j ACCEPTiptables -A FORWARD -s 192.168.1.0/24 -p icmp -m icmp --icmp-type any -j ACCEPT</code></pre><p>   说明：只有类型8是真正会影响ping，或者也可以采用any；了解很多icmp类型iptables -p icmp -h</p><p><strong>ICMP**</strong>类型的说明**</p><table><thead><tr><th>TYPE</th><th>CODE</th><th>Description</th><th>Query</th><th>Error</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>0</td><td>Echo Reply——回显应答（Ping应答）</td><td>x</td><td></td></tr><tr><td><strong>3</strong></td><td>0</td><td>Network Unreachable——网络不可达</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>1</td><td>Host Unreachable——主机不可达</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>2</td><td>Protocol Unreachable——协议不可达</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>3</td><td>Port Unreachable——端口不可达</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>4</td><td>Fragmentation needed but no frag. bit set——需要进行分片但设置不分片比特</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>5</td><td>Source routing failed——源站选路失败</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>6</td><td>Destination network unknown——目的网络未知</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>7</td><td>Destination host unknown——目的主机未知</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>8</td><td>Source host isolated (obsolete)——源主机被隔离（作废不用）</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>9</td><td>Destination network administratively prohibited——目的网络被强制禁止</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>10</td><td>Destination host administratively prohibited——目的主机被强制禁止</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>11</td><td>Network unreachable for TOS——由于服务类型TOS，网络不可达</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>12</td><td>Host unreachable for TOS——由于服务类型TOS，主机不可达</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>13</td><td>Communication administratively prohibited by filtering——由于过滤，通信被强制禁止</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>14</td><td>Host precedence violation——主机越权</td><td></td><td>x</td></tr><tr><td><strong>3</strong></td><td>15</td><td>Precedence cutoff in effect——优先中止生效</td><td></td><td>x</td></tr><tr><td><strong>4</strong></td><td>0</td><td>Source quench——源端被关闭（基本流控制）</td><td></td><td></td></tr><tr><td><strong>5</strong></td><td>0</td><td>Redirect for network——对网络重定向</td><td></td><td></td></tr><tr><td><strong>5</strong></td><td>1</td><td>Redirect for host——对主机重定向</td><td></td><td></td></tr><tr><td><strong>5</strong></td><td>2</td><td>Redirect for TOS and network——对服务类型和网络重定向</td><td></td><td></td></tr><tr><td><strong>5</strong></td><td>3</td><td>Redirect for TOS and host——对服务类型和主机重定向</td><td></td><td></td></tr><tr><td><strong>8</strong></td><td>0</td><td>Echo request——回显请求（Ping请求）</td><td>x</td><td></td></tr><tr><td><strong>9</strong></td><td>0</td><td>Router advertisement——路由器通告</td><td></td><td></td></tr><tr><td><strong>10</strong></td><td>0</td><td>Route solicitation——路由器请求</td><td></td><td></td></tr><tr><td><strong>11</strong></td><td>0</td><td>TTL equals 0 during transit——传输期间生存时间为0</td><td></td><td>x</td></tr><tr><td><strong>11</strong></td><td>1</td><td>TTL equals 0 during reassembly——在数据报组装期间生存时间为0</td><td></td><td>x</td></tr><tr><td><strong>12</strong></td><td>0</td><td>IP header bad (catchall error)——坏的IP首部（包括各种差错）</td><td></td><td>x</td></tr><tr><td><strong>12</strong></td><td>1</td><td>Required options missing——缺少必需的选项</td><td></td><td>x</td></tr><tr><td><strong>13</strong></td><td>0</td><td>Timestamp request (obsolete)——时间戳请求（作废不用）</td><td>x</td><td></td></tr><tr><td><strong>14</strong></td><td></td><td>Timestamp reply (obsolete)——时间戳应答（作废不用）</td><td>x</td><td></td></tr><tr><td><strong>15</strong></td><td>0</td><td>Information request (obsolete)——信息请求（作废不用）</td><td>x</td><td></td></tr><tr><td><strong>16</strong></td><td>0</td><td>Information reply (obsolete)——信息应答（作废不用）</td><td>x</td><td></td></tr><tr><td><strong>17</strong></td><td>0</td><td>Address mask request——地址掩码请求</td><td>x</td><td></td></tr><tr><td><strong>18</strong></td><td>0</td><td>Address mask reply——地址掩码应答</td><td></td><td></td></tr></tbody></table><p>数据来源：<a href="http://www.cnitblog.com/yang55xiaoguang/articles/59581.html" target="_blank" rel="noopener">http://www.cnitblog.com/yang55xiaoguang/articles/59581.html</a></p><h3 id="1-6-5-防火墙状态机制配置"><a href="#1-6-5-防火墙状态机制配置" class="headerlink" title="1.6.5 防火墙状态机制配置"></a>1.6.5 防火墙状态机制配置</h3><p>状态集简单说明:</p><table><thead><tr><th><strong>状态集</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>NEW</strong></td><td>表示新建立连接的数据包状态</td></tr><tr><td><strong>ESTABLISHED</strong></td><td>表示新建立连接数据包发送之后，回复响应的数据包状态</td></tr><tr><td><strong>RELATED</strong></td><td>表示借助已经建立的链路，发送新的连接数据包</td></tr><tr><td><strong>INVALID</strong></td><td>无效无法识别的数据包</td></tr></tbody></table><p>注意：允许关联的状态包通过（web服务不要使用FTP服务）</p><p>防火墙服务配置在FTP服务器上时，需要配置以下策略</p><pre><code>iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPTiptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</code></pre><p>实现发现sent_syn状态</p><pre><code>iptables -A INPUT -m state --state NEW -j DROP    # 防火墙所连接客户端上配置</code></pre><p>实现发现sent_rcvd状态</p><pre><code>iptables -I INPUT -i eth0 -s 10.0.0.201 -m state --state ESTABLISHED -j DROP  # 防护墙上配置的</code></pre><h3 id="1-6-6-使用iptables实现限速功能"><a href="#1-6-6-使用iptables实现限速功能" class="headerlink" title="1.6.6 使用iptables实现限速功能"></a>1.6.6 使用iptables实现限速功能</h3><p>limit是iptables的一个匹配模块，用它结合iptables的其它命令可以实现限速的功能。</p><p>不过首先必须明确，limit本身只是一个“匹配”模块。我们知道，iptables的基本原理是“匹配–处理”，limit在这个工作过程中只能起到匹配的作用，它本身是无法对网络数据包进行任何处理的。我看到网上有些limit的例子里面说只 用一条包含limit匹配规则的iptables语句就可以实现限速，那是错误的。</p><p>实际上，利用imit来限速需要包括两个步骤:</p><p>1.对符合limit匹配规则包放行</p><p>2.丢弃/拒绝未放行的包</p><p>示例：</p><pre><code>iptables -I INPUT -s 10.0.0.7 -p icmp --icmp-type 8 -m limit --limit 6/min --limit-burst 5 -j ACCEPT iptables -I INPUT -s 10.0.0.7 -p icmp --icmp-type 8 -j DROP</code></pre><p>   语句含义：当来自10.0.0.7 的ping包超过5个时进行限速，限制为每10s一个。</p><p>参数说明：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>参数含义</strong></th></tr></thead><tbody><tr><td><strong>–limit n/{second/minute/hour}</strong></td><td>指定时间内的请求速率”n”为速率，后面为时间分别为：秒 分 时</td></tr><tr><td><strong>–limit-burst [n]</strong></td><td>在同一时间内允许通过的请求”n”为数字，不指定默认为5</td></tr></tbody></table><p><strong>limit</strong> <strong>模块具体是如何工作的。？</strong></p><p>limit的匹配是基于令牌桶 (Token bucket）模型的。</p><p>令牌桶是一种网络通讯中常见的缓冲区工作原理，它有两个重要的参数，令牌桶容量n和令牌产生速率s。</p><blockquote><p>我们可以把令牌当成是门票，而令牌桶则是负责制作和发放门票的管理员，它手里最多有n张令牌。一开始，管理员开始手里有n张令牌。每当一个数据包到达后，管理员就看看手里是否还有可用的令牌。如果有，就把令牌发给这个数据包，limit就告诉iptables，这个数据包被匹配了。而当管理员把手上所有的令牌都发完了，再来的数据包就拿不到令牌了。这时，limit模块就告诉iptables，这个数据包不能被匹配。除了发放令牌之外，只要令牌桶中的令牌数量少于n，它就会以速率s来产生新的令牌，直到令牌数量到达n为止。</p></blockquote><p>通过令牌桶机制，即可以有效的控制单位时间内通过（匹配）的数据包数量，又可以容许短时间内突发的大量数据包的通过（只要数据包数量不超过令牌桶n）。</p><p>limit模块提供了两个参数–limit和–limit-burst，分别对应于令牌产生速率和令牌桶容量。除了令牌桶模型外，limit匹配的另外一个重要概念是匹配项。在limit中，每个匹配项拥有一个单独的令牌桶，执行独立的匹配计算。</p><h3 id="1-6-7防火墙配置"><a href="#1-6-7防火墙配置" class="headerlink" title="1.6.7防火墙配置"></a>1.6.7防火墙配置</h3><p>清除防火墙规则</p><pre><code>[root@clsn ~]# iptables -F[root@clsn ~]# iptables -X[root@clsn ~]# iptables -Z</code></pre><p>修改默认规则为拒绝（修改前先放行22端口，保证自己能够连上主机）</p><pre><code>[root@clsn ~]# iptables -A INPUT -p tcp --dport  22 -j ACCEPT[root@clsn ~]# iptables -P INPUT DROP [root@clsn ~]# iptables -P FORWARD DROP</code></pre><p>放行指定的端口</p><pre><code>[root@clsn ~]# iptables -A INPUT -i lo -j ACCEPT[root@clsn ~]# iptables -A INPUT  -p tcp  -m multiport --dport  80,443 -j ACCEPT [root@clsn ~]# iptables -A INPUT -s 172.16.1.0/24 -j ACCEPT[root@clsn ~]# iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT#multiport多个不连续   21:25,80,443</code></pre><p><strong>保存iptables**</strong>配置**</p><p>\01. 第一种方式</p><pre><code>[root@clsn ~]# /etc/init.d/iptables saveiptables: Saving firewall rules to /etc/sysconfig/iptables:[  OK  ][root@clsn ~]# cat /etc/sysconfig/iptables# Generated by iptables-save v1.4.7 on Tue Apr  4 12:24:43 2017*filter:INPUT DROP [0:0]:FORWARD DROP [0:0]:OUTPUT ACCEPT [159:10664]-A INPUT -s 10.0.0.0/24 -j ACCEPT -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT -A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT -A INPUT -s 172.16.1.0/24 -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT COMMIT# Completed on Tue Apr  4 12:24:43 2017</code></pre><p>\02. 第二种方式</p><pre><code>iptables-save &gt;/etc/sysconfig/iptables</code></pre><h2 id="1-7-iptables-nat表配置实例-理论"><a href="#1-7-iptables-nat表配置实例-理论" class="headerlink" title="1.7 iptables nat表配置实例(理论)"></a>1.7 iptables nat表配置实例(理论)</h2><p>(理论掌握)</p><h3 id="1-7-1-iptables实现共享上网"><a href="#1-7-1-iptables实现共享上网" class="headerlink" title="1.7.1 iptables实现共享上网"></a>1.7.1 iptables实现共享上网</h3><p> <img src="https://s1.ax1x.com/2020/04/26/JRuF58.png" alt="JRuF58.png"></p><p>图 - SNAT 配置原理图</p><p>第一个里程碑：配置内网服务器，设置网关地址</p><pre><code>/etc/init.d/iptables stop      # 内网服务器停止防火墙服务ifdown eth0                    # 模拟关闭内网服务器外网网卡setup                          # 修改内网网卡网关和DNS地址信息</code></pre><p>也可以使用命令添加默认网关</p><pre><code>route add default gw 172.16.1.188</code></pre><p>查看默认的路由信息</p><pre><code>[root@test ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface172.16.1.0      0.0.0.0         255.255.255.0   U     0      0        0 eth1169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth10.0.0.0         172.16.1.188    0.0.0.0         UG    0      0        0 eth1</code></pre><p>说明：内网服务器网关地址指定为共享上网服务器内网网卡地址</p><p>第二个里程碑：配置共享上网服务器，开启共享上网服务器路由转发功能</p><pre><code>[root@clsn ~]# vim /etc/sysctl.conf [root@clsn ~]# sysctl -p~~~net.ipv4.ip_forward = 1~~~</code></pre><p>第三个里程碑：配置共享上网服务器，实现内网访问外网的NAT映射</p><pre><code>iptables -t nat -A POSTROUTING -s 172.16.1.0/24 -o eth0 -j SNAT --to-source 10.0.0.188</code></pre><p>参数详解：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>参数说明</strong></th></tr></thead><tbody><tr><td><strong>-s 172.16.1.0/24</strong></td><td>指定将哪些内网网段进行映射转换</td></tr><tr><td><strong>-o eth0</strong></td><td>指定在共享上网哪个网卡接口上做NAT地址转换</td></tr><tr><td><strong>-j SNAT</strong></td><td>将源地址进行转换变更</td></tr><tr><td><strong>-j DNAT</strong></td><td>将目标地址进行转换变更</td></tr><tr><td><strong>–to-source ip**</strong>地址**</td><td>将源地址映射为什么IP地址</td></tr><tr><td><strong>–to-destination ip**</strong>地址**</td><td>将目标地址映射为什么IP地址</td></tr></tbody></table><p>当filter表中的forward默认为drop策略时，如何配置forward链？</p><p> <img src="https://s1.ax1x.com/2020/04/26/JRuubq.png" alt="JRuubq.png"></p><p>图 - forward工作原理</p><p>   <strong>配置示例</strong></p><pre><code>iptables -A FORWARD -i eth1 -s 172.16.1.0/24 -j ACCEPT# iptables -A FORWARD -o eth0 -s 172.16.1.0/24 -j ACCEPT  # 可以不进行配置iptables -A FORWARD -i eth0 -d 172.16.1.0/24 -j ACCEPT# iptables -A FORWARD -o eth1 -d 172.16.1.0/24 -j ACCEPT   # 可以不进行配置</code></pre><p>当外网ip不固定时如何配置？</p><pre><code>iptables -t nat -A POSTROUTING -s 172.16.1.0/24 -o eth0 -j MASQUERADE   # 伪装共享上网</code></pre><p>说明：在工作中如何没有固定外网IP地址，可以采取以上伪装映射的方式进行共享上网</p><p><strong>配置映射方法小结</strong></p><blockquote><p> \01. 指定哪些网段需要进行映射     -s 172.16.1.0/24</p><p> \02. 指定在哪做映射               -o eth0</p><p> \03. 用什么方法做映射             -j SNAT/DNAT MASQUERADE</p><p> \04. 映射成什么地址               –to-source  ip地址/–to-destination ip地址</p></blockquote><h3 id="1-7-2-iptables实现外网IP的端口映射到内网IP的端口"><a href="#1-7-2-iptables实现外网IP的端口映射到内网IP的端口" class="headerlink" title="1.7.2 iptables实现外网IP的端口映射到内网IP的端口"></a>1.7.2 iptables实现外网IP的端口映射到内网IP的端口</h3><p>实际需求：将网关的IP和9000端口映射到内网服务器的22端口</p><p>端口映射 10.0.0.188:9000 –&gt;172.16.1.180:22</p><p>配置实例：</p><pre><code>iptables -t nat -A PREROUTING -d 10.0.0.188 -p tcp --dport 9000 -i eth0 -j DNAT --to-destination 172.16.1.7:22</code></pre><p>参数说明:</p><table><thead><tr><th><strong>参数</strong></th><th><strong>参数说明</strong></th></tr></thead><tbody><tr><td><strong>-d 10.0.0.188</strong></td><td>目标地址。</td></tr><tr><td><strong>-j DNAT</strong></td><td>目的地址改写。</td></tr></tbody></table><h3 id="1-7-3-IP一对一映射"><a href="#1-7-3-IP一对一映射" class="headerlink" title="1.7.3 IP一对一映射"></a>1.7.3 IP一对一映射</h3><p><img src="https://s1.ax1x.com/2020/04/26/JRu3PU.png" alt="JRu3PU.png"></p><p>图 - DNAT 映射原理</p><p>   实际需求：将ip 地址172.16.1.180 映射到10.0.0.188</p><p>通过辅助IP配置：</p><pre><code>ip addr add 10.0.0.81/24 dev eth0 label eth0:0   # 添加辅助IPiptables  -t nat -I PREROUTING -d 10.0.0.81 -j DNAT --to-destination 172.16.1.51iptables  -t nat -I POSTROUTING -s 172.16.1.51 -o eth0 -j SNAT --to-source 10.0.0.81</code></pre><p>适合内网的机器访问NAT外网的IP</p><pre><code>iptables  -t nat -I POSTROUTING -s 172.16.1.0/255.255.240.0 -d 10.0.0.81 -j SNAT --to-source 172.16.1.8</code></pre><p>检查配置：</p><pre><code>ping 10.0.0.81 -ttcpdump|grep -i icmp（两台机器上分别监测）telnet 10.0.0.81 22</code></pre><h3 id="1-7-4-映射多个外网IP上网"><a href="#1-7-4-映射多个外网IP上网" class="headerlink" title="1.7.4 映射多个外网IP上网"></a>1.7.4 映射多个外网IP上网</h3><p>   方法1：</p><pre><code>iptables -t nat -A POSTROUTING -s 10.0.1.0/255.255.240.0 -o eth0 -j SNAT --to-source 124.42.60.11-124.42.60.16</code></pre><p>​      在三层交换机或路由器，划分VLAN。</p><p>   方法2：</p><pre><code>iptables -t nat -A POSTROUTING -s 10.0.1.0/22 -o eth0 -j SNAT --to-source 124.42.60.11iptables -t nat -A POSTROUTING -s 10.0.2.0/22 -o eth0 -j SNAT --to-source 124.42.60.12</code></pre><p>​      扩大子网，会增加广播风暴。</p><h3 id="1-7-5-系统防火墙与网络内核优化标准参数"><a href="#1-7-5-系统防火墙与网络内核优化标准参数" class="headerlink" title="1.7.5 系统防火墙与网络内核优化标准参数"></a>1.7.5 系统防火墙与网络内核优化标准参数</h3><p>有关iptables的内核优化</p><p>调整内核参数文件/etc/sysctl.conf</p><p>以下是我的生产环境的某个服务器的配置：</p><p><strong>解决time-wait**</strong>过多**的解决办法：</p><pre><code>net.ipv4.tcp_fin_timeout = 2net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_syncookies = 1net.ipv4.tcp_keepalive_time = 600net.ipv4.tcp_max_tw_buckets = 36000net.ipv4.ip_local_port_range = 4000  65000net.ipv4.tcp_max_syn_backlog = 16384net.ipv4.route.gc_timeout = 100net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_synack_retries = 1</code></pre><p>在dmesg中显示  ip_conntrack: table full, dropping packet. 的错误提示，什么原因？</p><p>如何解决？</p><p>   #iptables优化</p><pre><code>net.nf_conntrack_max = 25000000net.netfilter.nf_conntrack_max = 25000000net.netfilter.nf_conntrack_tcp_timeout_established = 180net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120</code></pre><h2 id="1-8-自定义链的配置-了解"><a href="#1-8-自定义链的配置-了解" class="headerlink" title="1.8 自定义链的配置(了解)"></a>1.8 自定义链的配置(了解)</h2><p> <img src="https://s1.ax1x.com/2020/04/26/JRuG24.png" alt="JRuG24.png"></p><p>图 - 自定义链原理</p><p>创建自定义链</p><pre><code>#示例：在filter表中创建NOICMP自定义链iptables -t filter -N NOICMP</code></pre><p>引用自定义链</p><pre><code>#示例：在INPUT链中引用刚才创建的自定义链iptables -t filter -I INPUT -p icmp  -j NOICMP</code></pre><p>重命名自定义链</p><pre><code>#示例：将IN_WEB自定义链重命名为WEBiptables -E NOICMP ACCEPTICMP</code></pre><p>删除自定义链</p><blockquote><p> 删除自定义链需要满足两个条件</p><p> 　　1、自定义链没有被引用</p><p> 　　2、自定义链中没有任何规则</p></blockquote><pre><code># 示例： 删除引用数为0且不包含任何规则的ACCEPTICMP链iptables -X ACCEPTICMP</code></pre><h2 id="1-9-附录-防火墙状态机制"><a href="#1-9-附录-防火墙状态机制" class="headerlink" title="1.9 附录-防火墙状态机制"></a>1.9 附录-防火墙状态机制</h2><p>状态机制是iptables中较为特殊的一部分，这也是iptables和比较老的ipchains的一个比较大的区別之一，运行状态机制（连接跟踪）的防火墙称作带有状态机制的防火墙，以下简称为状态防火墙.状态防火墙比非状态防火墙要安全，因为它允许我们编写更严密的规则。</p><p>在iptables上一共有四种状态，分别被称为NEW、ESTABLISHED、INVALID、RELATED,这四种状态对于TCP、UDP、ICMP三种协议均有效。下面，我们来分别阐述四种状态的特性.</p><p><strong>🔔 NEW</strong></p><p>meaning that the packet has started a new connection, or otherwise associated with a connection which has not seen packets in both directions</p><p>NEW说明这个包是我们看到的第一个包。意思就是，这是conntrack模块看到的某个连接的第一个包，它即格被匹配了。比如，我们看到一个SYN包，是我们所留意的连接的第一个包，就要匹配它。</p><p><img src="https://s1.ax1x.com/2020/04/26/JRutM9.png" alt="JRutM9.png"> </p><p><strong>🔔 ESTABLISHED</strong></p><p>meaning that the packet is associated with a connection which has seen packets in both directions</p><p>ESTABLISHED已经注意到两个方向上的数据传输，而且会继续匹配这个连接的包.处于ESTABLISHED状态的连接是非常容易理解的.只要发送并接到应答，连接就是ESTABLISHED的了。一个连接要从NEW变为ESTABLISHED,只需要接到应答包即可，不管这个包是发往防火墙的，还是要由防火墙转发的.ICMP的错误和重定向等信息包也被看作是ESTABLISHED,只要它们是我们所发出的信息的应答。</p><p> <img src="https://s1.ax1x.com/2020/04/26/JRuUq1.png" alt="JRuUq1.png"></p><p><strong>🔔</strong> RELATED</p><p>meaning that the packet is starting a new connection, but is associated with an existing connection, such as an FTP data transfer, or an ICMP error.</p><p>RELATED是个比较麻烦的状态.当一个连接和某个已处于ESTABLISHED状态的连接有关系时，就被认为是RELATED的了，换句话说，一个连接要想是RELATED的，首先要有一个ESTABLISHED的连接。这个ESTABLISHED连接再产生一个主连接之外的连接，这个新的连接就是RELATED的了，当然前提是conntrack模块要能理解RELATED。ftp是个很好的例子，FTP-data连接就是和FTP-control有关联的，如果没有在iptables的策略中配RELATED状态，FTP-data的连接是无法正确建立的，还有其他的例子，比如，通过IRC的DCC连接#有了这个状态，ICMP应答、FTP传输、DCC等才能穿过防火墙正常工作.注意，大部分还有一些UDP协议都依赖这个机制。这些协议是很复杂的，它们把连接信息放在数据包里，并且要求这些信息能被正确理解。</p><p><img src="https://s1.ax1x.com/2020/04/26/JRudVx.png" alt="JRudVx.png"> </p><p><strong>🔔 INVALID</strong></p><p>meaning that the packet is associated with no known connection</p><p>INVALID说明数据包不能被识别属于哪个连接或没有任何状态.有几个原因可以产生这种情况，比如，内存溢出，收到不知厲于哪个连接的ICMP错误信息。一般地，我们DROP这个状态的任何东西，因为防火墙认为这是不安全的东西</p><p> <img src="https://s1.ax1x.com/2020/04/26/JRuwa6.png" alt="JRuwa6.png"></p><h3 id="1-9-1-iptables配置哲学"><a href="#1-9-1-iptables配置哲学" class="headerlink" title="1.9.1 iptables配置哲学"></a>1.9.1 iptables配置哲学</h3><p>如何防止自己被关在门外？</p><blockquote><p> 01、去机房重启系统或者登陆服努器删除刚才的禁止规则。</p><p> 02、让机房人员重启服务器或者让机房人员拿用户密码登录进去。</p><p> 03、通过服务器的远程管理卡管理（推荐）。</p><p> 04、先写一个定时任务，每5分钟就停止防火墙。</p><p> 05、测试环境测试好，写成脚本，批置执行</p></blockquote><p>配置禁用22端口策略:</p><pre><code>iptables -I INPUT -p tcp - dport 22 -j DROP# 说明：利用-I参数，实现强行阻止访问22端口，将Jffc规则放在第一位</code></pre><p>删除配置的禁止连接22端口的规则</p><pre><code>iptables -t filter -D INPUT -p tcp —dport 22 -j DROPiptables -F/etc/init.d/iptables restart</code></pre><p> 1.10 参考文献</p><blockquote><p> [1]  <a href="http://www.aichengxu.com/linux/3122717.htm" target="_blank" rel="noopener">http://www.aichengxu.com/linux/3122717.htm</a></p><p> [2]  <a href="http://blog.csdn.net/huguohu2006/article/details/6453522" target="_blank" rel="noopener">http://blog.csdn.net/huguohu2006/article/details/6453522</a></p><p> [3]  <a href="http://blog.csdn.net/lin_credible/article/details/8614907" target="_blank" rel="noopener">http://blog.csdn.net/lin_credible/article/details/8614907</a></p><p> [4]  <a href="http://blog.chinaunix.net/uid-27057175-id-5179329.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-27057175-id-5179329.html</a></p><p> [5]  <a href="http://blog.51cto.com/oldboy/974194" target="_blank" rel="noopener">http://blog.51cto.com/oldboy/974194</a></p><p> [6]  <a href="http://blog.sina.com.cn/s/blog_773d9b6701018rwo.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_773d9b6701018rwo.html</a></p><p> [7]  <a href="http://www.zsythink.net/archives/1625" target="_blank" rel="noopener">http://www.zsythink.net/archives/1625</a></p></blockquote><pre><code># iptables  -t  表名  动作(命令)   链名   匹配条件  -j  目标动作        -t 表名  raw mangle nat filter  （如果不写-t 默认使用filter表） 链名(各表对应的链)raw(PROROUTING、OUPUT)mangle(PROROUTING、FORWARD、OUTPUT、POSTROUTING)nat(PREROUTING、INPUT、FORWARD、OUTPUT、POSTROUING)filter(INPUT、FORWARD、OUTPUT)      动作(官方叫命令)：-A  添加规则：  (append追加)  # iptables -t filter -A INPUT -p icmp -j REJECT(拒绝)     //拒绝所有的icmp，即任何人不能ping同你   # iptables -t filter -A INPUT -p tcp --dport 22 -s 10.18.44.158  -j REJECT    拒绝源地址10.18.44.158的tcp协议的22端口   -I 插入规则  ：     #   iptables -t filter -I INPUT 2  -p tcp --dport 22 -s 10.18.44.171  -j REJECT   //INPUT不加数字默认是第一行，数字代表插入到哪一行前边-R 替换规则：      #  iptables -t filter -R INPUT 1 -p tcp --dport 22 -s 10.18.44.181  -j REJECT    //替换的时候 INPUT必须跟上行号-D 删除规则      #  iptables -t filter -D INPUT -p icmp -j REJECT      #  iptables -D INPUT 2-P 修改默认策略：只能使用DROP和ACCEPT       #  iptables -P INPUT DROP         #  iptables -P INPUT ACCEPT -N 添加自定义链          #iptables -N tiger        #iptables -A tiger -p tcp --dport 22 -s 10.18.44.208 -j REJECT     存储规则         自定义链里的规则在没有被调用的情况下不生效 使用自定义链(关联自定义链) #iptables -A INPUT -j tiger 修改自定义链名称  #iptables -E tiger TIGER删掉自定义链：    1.不能被关联    2.必须是空链     #iptables  -X  链名-F  清空规则     # iptables  -F 链名             //指定链的所有规则     #iptables -F                     //所有的规则-Z  计数清零      字节数        数据包个数      #iptables -Z                          //喜爱嗯看到计数用#iptables -L -n -v   (v可有号多个)-L  查看规则  -n以数字的形式显示ip和端口协议 --line 显示规则行号  -v流量计数(verbose 数据包的计数)  #iptables  -L   #iptables  -L -n  #iptables -L -n --line    #iptables  -L -n   -v                       匹配条件：基本匹配    在使用协议的时候不必非得写端口，但是使用端口是必须跟协议    协议                          /etc/protocols  ---icmp协议簇    /etc/servers --TCP/IP协议簇        -p            tcp udp  icmp           -ptcp    端口                                  --sport    //源端口                 # iptables -A INPUT -p tcp --sport 22 -s 10.18.44.208 -j REJECT                            # iptables _A INPUT -p tcp --sport 22:30 -s 10.18.44.208,10.18.44.209,10.18.44.210 -j REJECT              --dport    //目标端口                # iptables -A INPUT -p tcp --dport 22 -s 10.18.44.208 -j REJECT    ip          -s                  #iptables -A INPUT -p tcp --dport 20:30 -s 10.18.44.208/24 -j REJECT   // 在iptables中  10.18.44.208/24  其实是10.18.44.0/24          -d</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="2018/12/05/sql/redis/"/>
      <url>2018/12/05/sql/redis/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p><img src="https://i.loli.net/2019/05/03/5ccc19cfabc71.jpg" alt=""></p><h3 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h3><pre><code>什么是redisREmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。redis的官网：redis.io注:域名后缀io属于国家域名，是british Indian Ocean territory，即英属印度洋领地1.Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。2.在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。3.Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</code></pre><pre><code>Redis 与其他 key - value 缓存产品有以下三个特点：- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。- Redis支持数据的备份，即master-slave模式的数据备份。</code></pre><h3 id="redis优势"><a href="#redis优势" class="headerlink" title="redis优势"></a>redis优势</h3><pre><code>- 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。- 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。- 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。- 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</code></pre><h3 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h3><pre><code>下载地址http://redis.io/download，下载最新稳定版本。$ wget http://download.redis.io/releases/redis-5.0.4.tar.gz$ tar xzf redis-5.0.4.tar.gz$ cd redis-5.0.4.tar.gz$ yum install -y make gcc$ make</code></pre><h3 id="redis简单配置"><a href="#redis简单配置" class="headerlink" title="redis简单配置"></a>redis简单配置</h3><pre><code># cp redis.conf redis.conf.bak# vim redis.conf     ---修改如下bind 127.0.0.1　　#只监听内网IPdaemonize yes　　　　　#开启后台模式将on改为yestimeout 300　　　　　　#连接超时时间port 6379                      #端口号databases 0                 存储Session的Redis库编号dir ./　　#本地数据库存放目录该目录需要存在pidfile /var/run/redis_6379.pid　　#定义pid文件logfile /var/log/redis_6379.log　　#定义log文件requirepass cyy     # 设置密码</code></pre><h3 id="配置redis为systemctl启动"><a href="#配置redis为systemctl启动" class="headerlink" title="配置redis为systemctl启动"></a>配置redis为systemctl启动</h3><pre><code># cd /lib/systemd/system# vim /lib/systemd/system/redis.service[Unit]Description=RedisAfter=network.target[Service]ExecStart=/usr/local/redis-5.0.4/src/redis-server /usr/local/redis-5.0.4/redis.conf  --daemonize noExecStop=/usr/local/redis-5.0.4/src/redis-cli -h 127.0.0.1 -p 6379 shutdown[Install]WantedBy=multi-user.target=====================参数详解:• [Unit] 表示这是基础信息 • Description 是描述• After 是在那个服务后面启动，一般是网络服务启动后启动• [Service] 表示这里是服务信息 • ExecStart 是启动服务的命令• ExecStop 是停止服务的指令• [Install] 表示这是是安装相关信息 • WantedBy 是以哪种方式启动：multi-user.target表明当系统以多用户方式（默认的运行级别）启动时，这个服务需要被自动运行。</code></pre><h3 id="redis启动"><a href="#redis启动" class="headerlink" title="redis启动"></a>redis启动</h3><pre><code>make完后 redis-5.0.4目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：下面启动redis服务.</code></pre><p><img src="https://i.loli.net/2019/05/07/5cd186575317a.jpg" alt=""></p><pre><code>$ src/redis-server注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。$ cd src$ ./redis-server ../redis.confredis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。</code></pre><h3 id="redis客户端测试"><a href="#redis客户端测试" class="headerlink" title="redis客户端测试"></a>redis客户端测试</h3><pre><code>$ src/redis-cli127.0.0.1:6379&gt; set 2020 GZOK127.0.0.1:6379&gt; get 2020&quot;GZ&quot;127.0.0.1:6379&gt; pingPONG</code></pre><h3 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h3><pre><code>redis的配置默认位于redis安装目录下，文件名未redis.confRedis CONFIG 命令格式如下：redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME也可以通过命令查看或设置相关配置127.0.0.1:6379&gt; config get loglevel1) &quot;loglevel&quot;2) &quot;notice&quot;通过* 查看所有配置127.0.0.1:6379&gt; config get *  1) &quot;dbfilename&quot;  2) &quot;dump.rdb&quot;  3) &quot;requirepass&quot;  4) &quot;&quot;  5) &quot;masterauth&quot;  6) &quot;&quot;  7) &quot;cluster-announce-ip&quot;  8) &quot;&quot;  9) &quot;unixsocket&quot; 10) &quot;&quot; 11) &quot;logfile&quot; 12) &quot;&quot; 13) &quot;pidfile&quot; 14) &quot;&quot; 15) &quot;slave-announce-ip&quot; 16) &quot;&quot; 17) &quot;replica-announce-ip&quot; 18) &quot;&quot; 19) &quot;maxmemory&quot; 20) &quot;0&quot; 21) &quot;proto-max-bulk-len&quot; 22) &quot;536870912&quot; 23) &quot;client-query-buffer-limit&quot; 24) &quot;1073741824&quot; 25) &quot;maxmemory-samples&quot; 26) &quot;5&quot; 27) &quot;lfu-log-factor&quot; 28) &quot;10&quot; 29) &quot;lfu-decay-time&quot; 30) &quot;1&quot; 31) &quot;timeout&quot; 32) &quot;0&quot; 33) &quot;active-defrag-threshold-lower&quot; 34) &quot;10&quot; 35) &quot;active-defrag-threshold-upper&quot; 36) &quot;100&quot; 37) &quot;active-defrag-ignore-bytes&quot; 38) &quot;104857600&quot; 39) &quot;active-defrag-cycle-min&quot; 40) &quot;5&quot; 41) &quot;active-defrag-cycle-max&quot; 42) &quot;75&quot; 43) &quot;active-defrag-max-scan-fields&quot; 44) &quot;1000&quot; 45) &quot;auto-aof-rewrite-percentage&quot; 46) &quot;100&quot; 47) &quot;auto-aof-rewrite-min-size&quot; 48) &quot;67108864&quot; 49) &quot;hash-max-ziplist-entries&quot; 50) &quot;512&quot; 51) &quot;hash-max-ziplist-value&quot; 52) &quot;64&quot; 53) &quot;stream-node-max-bytes&quot; 54) &quot;4096&quot; 55) &quot;stream-node-max-entries&quot; 56) &quot;100&quot; 57) &quot;list-max-ziplist-size&quot; 58) &quot;-2&quot; 59) &quot;list-compress-depth&quot; 60) &quot;0&quot; 61) &quot;set-max-intset-entries&quot; 62) &quot;512&quot; 63) &quot;zset-max-ziplist-entries&quot; 64) &quot;128&quot; 65) &quot;zset-max-ziplist-value&quot; 66) &quot;64&quot; 67) &quot;hll-sparse-max-bytes&quot; 68) &quot;3000&quot; 69) &quot;lua-time-limit&quot; 70) &quot;5000&quot; 71) &quot;slowlog-log-slower-than&quot; 72) &quot;10000&quot; 73) &quot;latency-monitor-threshold&quot; 74) &quot;0&quot; 75) &quot;slowlog-max-len&quot; 76) &quot;128&quot; 77) &quot;port&quot; 78) &quot;6379&quot; 79) &quot;cluster-announce-port&quot; 80) &quot;0&quot;。。。</code></pre><p>编辑配置</p><p>可以通过修改redis.conf文件或者使用 CONFIG setm命令修改配置</p><pre><code>CONFIG set 语法如下redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE示例redis 127.0.0.1:6379&gt; CONFIG SET loglevel &quot;notice&quot;OKredis 127.0.0.1:6379&gt; CONFIG GET loglevel1) &quot;loglevel&quot;2) &quot;notice&quot;</code></pre><p>相关配置参数详解</p><pre><code> Redis配置文件参数说明:1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程daemonize no2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定pidfile /var/run/redis.pid3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字port 63794. 绑定的主机地址bind 127.0.0.15.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能timeout 3006. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verboseloglevel verbose7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/nulllogfile stdout8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库iddatabases 169. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合save &lt;seconds&gt; &lt;changes&gt;Redis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大rdbcompression yes11. 指定本地数据库文件名，默认值为dump.rdbdbfilename dump.rdb12. 指定本地数据库存放目录dir ./13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步slaveof &lt;masterip&gt; &lt;masterport&gt;14. 当master服务设置了密码保护时，slav服务连接master的密码masterauth &lt;master-password&gt;15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭requirepass foobared16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息maxclients 12817. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区maxmemory &lt;bytes&gt;18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为noappendonly no19. 指定更新日志文件名，默认为appendonly.aofappendfilename appendonly.aof20. 指定更新日志条件，共有3个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）vm-enabled no22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享vm-swap-file /tmp/redis.swap23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0vm-max-memory 024. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值vm-page-size 3225. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。vm-pages 13421772826. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4vm-max-threads 427. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启glueoutputbuf yes28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法hash-max-zipmap-entries 64hash-max-zipmap-value 51229. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）activerehashing yes</code></pre><h3 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h3><pre><code>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</code></pre><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><pre><code>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB127.0.0.1:6379&gt; set name cyylogOK127.0.0.1:6379&gt; get name&quot;cyylog&quot;我们使用了 Redis 的 SET 和 GET 命令。键为 name，对应的值为 cyylog</code></pre><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><pre><code>Redis hash 是一个键值(key=&gt;value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。示例:127.0.0.1:6379&gt; hmset myhash name tiger name2 fiveOK127.0.0.1:6379&gt; hget myhash name&quot;tiger&quot;127.0.0.1:6379&gt; hget myhash name2&quot;five&quot;实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。每个 hash 可以存储 232 -1 键值对（40多亿）。</code></pre><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><pre><code>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。示例127.0.0.1:6379&gt; lpush mylist redis1(integer) 1127.0.0.1:6379&gt; lpush mylist redis2 redis3 redis4(integer) 4127.0.0.1:6379&gt; lpush mylist tiger 2020(integer) 6127.0.0.1:6379&gt; lrange mylist 0 31) &quot;2020&quot;2) &quot;tiger&quot;3) &quot;redis4&quot;4) &quot;redis3&quot;127.0.0.1:6379&gt; lrange mylist 0 101) &quot;2020&quot;2) &quot;tiger&quot;3) &quot;redis4&quot;4) &quot;redis3&quot;5) &quot;redis2&quot;6) &quot;redis1&quot;上述示例我们通过 lpush 创建list并添加数据，通过lrange获取列表中的数据列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</code></pre><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><pre><code>Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。sadd 命令添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。示例127.0.0.1:6379&gt; sadd myset GZ BJ ZZ BK(integer) 4127.0.0.1:6379&gt; sadd myset TJ(integer) 1127.0.0.1:6379&gt; sadd myset TJ(integer) 0127.0.0.1:6379&gt; smembers myset 1) &quot;BJ&quot;2) &quot;BK&quot;3) &quot;TJ&quot;4) &quot;GZ&quot;5) &quot;ZZ&quot;127.0.0.1:6379&gt; sadd myset SZ(integer) 1127.0.0.1:6379&gt; smembers myset 1) &quot;BJ&quot;2) &quot;BK&quot;3) &quot;TJ&quot;4) &quot;GZ&quot;5) &quot;ZZ&quot;6) &quot;SZ&quot;注意：以上实例中 TJ 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</code></pre><h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><pre><code>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。zadd 命令添加元素到集合，元素在集合中存在则更新对应score示例127.0.0.1:6379&gt; zadd myzset 0 GZ(integer) 1127.0.0.1:6379&gt; zadd myzset 0 BJ(integer) 1127.0.0.1:6379&gt; zadd myzset 0 ZZ(integer) 1127.0.0.1:6379&gt; zrangebyscore myzset 0 51) &quot;BJ&quot;2) &quot;GZ&quot;3) &quot;ZZ&quot;</code></pre><pre><code>注意：Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库，如要选择1号数据库：示例:127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; get name(nil)127.0.0.1:6379[1]&gt; get myzset(nil)127.0.0.1:6379[1]&gt; select 0OK127.0.0.1:6379&gt; get name&quot;cyylog&quot;127.0.0.1:6379&gt; zrangebyscore myzset 0 21) &quot;BJ&quot;2) &quot;GZ&quot;3) &quot;ZZ&quot;然而这些以数字命名的数据库又与我们理解的数据库有所区别。首先Redis不支持自定义数据库的名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。另外Redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。最重要的一点是多个数据库之间并不是完全隔离的，比如FLUSHALL命令可以清空一个Redis实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库B应用的数据，不同的应用应该使用不同的Redis实例存储数据。由于Redis非常轻量级，一个空Redis实例占用的内在只有1M左右，所以不用担心多个Redis实例会额外占用很多内存。</code></pre><h3 id="redis命令"><a href="#redis命令" class="headerlink" title="redis命令"></a>redis命令</h3><pre><code>Redis 命令用于在 redis 服务上执行操作。要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。语法Redis 客户端的基本语法为：$ redis-cli在远程服务上执行命令如果需要在远程 redis 服务上执行命令，同样我们使用的也是 redis-cli 命令。语法$ redis-cli -h host -p port -a password</code></pre><h3 id="redis数据备份和恢复"><a href="#redis数据备份和恢复" class="headerlink" title="redis数据备份和恢复"></a>redis数据备份和恢复</h3><pre><code>Redis SAVE 命令用于创建当前数据库的备份。语法redis Save 命令基本语法如下：127.0.0.1:6379&gt; saveOK该命令会在redis安装目录下创建dump.rdb文件恢复数据如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令，如下所示：127.0.0.1:6379&gt; config get dir1) &quot;dir&quot;2) &quot;/usr/local/redis/src&quot;以上命令 CONFIG GET dir 输出的 redis 安装目录为/usr/local/redis/srcBgsave创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。127.0.0.1:6379&gt; BGSAVEBackground saving started</code></pre><h3 id="redis安全"><a href="#redis安全" class="headerlink" title="redis安全"></a>redis安全</h3><pre><code>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;&quot;默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。你可以通过以下命令来修改该参数：127.0.0.1:6379&gt; CONFIG set requirepass &quot;tiger&quot;OK127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;tiger&quot;登录redis-cli -h 127.0.0.1 -p 6379 -a tiger或者登陆后认证127.0.0.1:6379&gt; AUTH &quot;tiger&quot;OK127.0.0.1:6379&gt; SET name &quot;Test value&quot;OK127.0.0.1:6379&gt; GET name&quot;Test value&quot;</code></pre><h3 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h3><pre><code>redis持久化 – 两种方式开启持久化功能后，重启redis后，数据会自动通过持久化文件恢复！！redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。RDB，是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。redis持久化 – RDBRDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。                -------------&gt;----------&gt;------------------&gt;                1 2 3 4 5  6 7 8 9  10 11 12 13  14 15 16                              -----------&gt;                   --------&gt;                              1 2 3 4 5                  1 2 3 4 5  6 7 8 9  10 11 12 13对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。redis持久化 – AOFAOF，英文是Append Only File，即只允许追加不允许改写的文件。AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点可以放心。AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。1 2 3 4 5 6     6zi0如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：1.备份被写坏的AOF文件2.运行redis-check-aof –fix进行修复3.用diff -u来看下两个文件的差异，确认问题点4.重启redis，加载修复后的AOF文件redis持久化 – AOF重写AOF重写的内部运行原理，有必要了解一下。在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。redis持久化 – 如何选择RDB和AOF对于我们应该选择RDB还是AOF，官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。写入速度快 AOF写入速度慢 RDBredis的事务处理众所周知，事务是指“一个完整的动作，要么全部执行，要么什么也没有做”。在聊redis事务处理之前，要先和大家介绍四个redis指令，即MULTI、EXEC、DISCARD、WATCH。这四个指令构成了redis事务处理的基础。1.MULTI用来组装一个事务；2.EXEC用来执行一个事务；3.DISCARD用来取消一个事务；4.WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。一个MULTI和EXEC的例子：redis&gt; MULTI //标记事务开始OKredis&gt; INCR user_id //多条命令按顺序入队QUEUEDredis&gt; INCR user_idQUEUEDredis&gt; INCR user_idQUEUEDredis&gt; PINGQUEUEDredis&gt; EXEC //执行1) (integer) 12) (integer) 23) (integer) 34) PONG在上面的例子中，看到了QUEUED的字样，这表示我们在用MULTI组装事务时，每一个命令都会进入到内存队列中缓存起来，如果出现QUEUED则表示我们这个命令成功插入了缓存队列，在将来执行EXEC时，这些被QUEUED的命令都会被组装成一个事务来执行。对于事务的执行来说，如果redis开启了AOF持久化的话，那么一旦事务被成功执行，事务中的命令就会通过write命令一次性写到磁盘中去，如果在向磁盘中写的过程中恰好出现断电、硬件故障等问题，那么就可能出现只有部分命令进行了AOF持久化，这时AOF文件就会出现不完整的情况，这时，可以使用redis-check-aof工具来修复这一问题，这个工具会将AOF文件中不完整的信息移除，确保AOF文件完整可用。有关事务，经常会遇到的是两类错误：1.调用EXEC之前的错误2.调用EXEC之后的错误“调用EXEC之前的错误”，有可能是由于语法有误导致的，也可能时由于内存不足导致的。只要出现某个命令无法成功写入缓冲队列的情况，redis都会进行记录，在客户端调用EXEC时，redis会拒绝执行这一事务。（这时2.6.5版本之后的策略。在2.6.5之前的版本中，redis会忽略那些入队失败的命令，只执行那些入队成功的命令）。我们来看一个这样的例子：127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; haha //一个明显错误的指令(error) ERR unknown command &#39;haha&#39;127.0.0.1:6379&gt; pingQUEUED127.0.0.1:6379&gt; exec//redis无情的拒绝了事务的执行，原因是“之前出现了错误”(error) EXECABORT Transaction discarded because of previous errors.而对于“调用EXEC之后的错误”，redis则采取了完全不同的策略，即redis不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是redis自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行。我们也来看一个例子：127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set age 23QUEUED//age不是集合，所以如下是一条明显错误的指令127.0.0.1:6379&gt; sadd age 15 QUEUED127.0.0.1:6379&gt; set age 29QUEUED127.0.0.1:6379&gt; exec //执行事务时，redis不会理睬第2条指令执行错误1) OK2) (error) WRONGTYPE Operation against a key holding the wrong kind of value3) OK127.0.0.1:6379&gt; get age&quot;29&quot; //可以看出第3条指令被成功执行了最后一个指令“WATCH”，这是一个很好用的指令，它可以帮我们实现类似于“乐观锁”的效果，即CAS（check and set）。WATCH本身的作用是“监视key是否被改动过”，而且支持同时监视多个key，只要还没真正触发事务，WATCH都会尽职尽责的监视，一旦发现某个key被修改了，在执行EXEC时就会返回nil，表示事务无法触发。127.0.0.1:6379&gt; set age 23OK127.0.0.1:6379&gt; watch age //开始监视ageOK127.0.0.1:6379&gt; set age 24 //在EXEC之前，age的值被修改了OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set age 25QUEUED127.0.0.1:6379&gt; get ageQUEUED127.0.0.1:6379&gt; exec //触发EXEC(nil) //事务无法被执行</code></pre><h2 id="redis主从-哨兵"><a href="#redis主从-哨兵" class="headerlink" title="redis主从  + 哨兵"></a>redis主从  + 哨兵</h2><h3 id="主从-用法"><a href="#主从-用法" class="headerlink" title="主从 - 用法"></a>主从 - 用法</h3><pre><code>像MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。但是从服务器仍然可以接受CONFIG等指令，所以还是不应该将从服务器直接暴露到不安全的网络环境中。如果必须如此，那可以考虑给重要指令进行重命名，来避免命令被外人误执行。</code></pre><h3 id="主从-同步原理"><a href="#主从-同步原理" class="headerlink" title="主从 - 同步原理"></a>主从 - 同步原理</h3><pre><code>从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中。在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。另外，要说的一点是，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游。在redis2.8版本之前，如果从服务器与主服务器因某些原因断开连接的话，都会进行一次主从之间的全量的数据同步；而在2.8版本之后，redis支持了效率更高的增量同步策略，这大大降低了连接断开的恢复成本。主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给从服务器的内容。从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，从服务器就会把“希望同步的主服务器ID”和“希望请求的数据的偏移位置（replication offset）”发送出去。主服务器接收到这样的同步请求后，首先会验证主服务器ID是否和自己的ID匹配，其次会检查“请求的偏移位置”是否存在于自己的缓冲区中，如果两者都满足的话，主服务器就会向从服务器发送增量内容。增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。</code></pre><h3 id="sentinel介绍"><a href="#sentinel介绍" class="headerlink" title="sentinel介绍"></a><strong>sentinel介绍</strong></h3><pre><code>Sentinel(哨兵)是用于监控redis集群中Master状态的工具，其已经被集成在redis2.4+的版本中Sentinel作用： 1)：Master状态检测 2)：如果Master异常，则会进行Master-Slave切换，将其中一个Slave作为Master，将之前的Master作为Slave 3)：Master-Slave切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换 Sentinel工作方式： 1)：每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令 2)：如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。 3)：如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 4)：当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 5)：在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 6)：当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 7)：若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。=============================================================主观下线和客观下线 主观下线：Subjectively Down，简称 SDOWN，指的是当前 Sentinel 实例对某个redis服务器做出的下线判断。 客观下线：Objectively Down， 简称 ODOWN，指的是多个 Sentinel 实例在对Master Server做出 SDOWN  判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的Master  Server下线判断，然后开启failover.</code></pre><h3 id="主从同步部署"><a href="#主从同步部署" class="headerlink" title="主从同步部署"></a>主从同步部署</h3><pre><code>测试环境:centos7.4redis-master:192.168.19.129   vm1redis-slave1:192.168.19.136   vm4redis-slave2:192.168.19.135   vm51.首先三台服务器将redis单机部署完成。编辑master的redis配置文件:[root@redis-master ~]# cd /usr/local/redis-5.0.4[root@redis-master redis]# vim redis.conf</code></pre><img src="https://i.loli.net/2019/05/07/5cd19e2caa3bf.jpg" /><p>2.修改slave1的配置文件：<br>[root@redis-slave1 ~]# cd /data/application/redis/<br>[root@redis-slave1 redis]# vim redis.conf      —修改如下：</p><img src="https://i.loli.net/2019/05/07/5cd19e5ea0f84.jpg" /><img src="https://i.loli.net/2019/05/07/5cd19e838e43e.jpg" /><p>3.配置slave2的配置文件:<br>[root@redis-slave2 ~]# cd /data/application/redis/<br>[root@redis-slave2 redis]# vim redis.conf       —修改如下  和slave1 相同</p><p>4.重启三台redis</p><img src="https://i.loli.net/2019/05/07/5cd19ebbe787b.jpg" /><p>5.测试主从</p><img src="https://i.loli.net/2019/05/07/5cd19f3641529.jpg" /><p><img src="C:%5CUsers%5Cw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557241701339.png" alt="1557241701339"></p><p>三台均测试无误，主从同步部署完成</p><h3 id="配置哨兵模式"><a href="#配置哨兵模式" class="headerlink" title="配置哨兵模式"></a>配置哨兵模式</h3><pre><code>1.每台机器上修改redis主配置文件redis.conf文件设置：bind 0.0.0.0       ---配置主从时已经完成2.每台机器上修改sentinel.conf配置文件：修改如下配置[root@redis-master src]# cd ..[root@redis-master redis]# vim sentinel.conf        sentinel monitor mymaster 192.168.233.10 6379 2 (slave上面写的是master的ip，master写自己ip)        sentinel down-after-milliseconds mymaster 3000        sentinel failover-timeout mymaster 10000        protected-mode no</code></pre><pre><code>关闭加密protected-mode no构成master客观下线的前提，至少有两个sentinel(哨兵)主观认为master已经下线sentinel monitor mymaster 192.168.19.129 6379 2 sentinel每隔一定时间向其已知的master发送ping指令，在设置的这个时间内如果没有收master返回的数据包，就会把master标记为主观下线。单位为毫秒sentinel down-after-milliseconds mymaster 3000在这个时间内如果主从切换没有完成就停止切换。单位毫秒sentinel failover-timeout mymaster 10000</code></pre><pre><code>3.每台机器启动哨兵服务：        # ./src/redis-sentinel sentinel.conf注意:在生产环境下将哨兵模式启动放到后台执行:         ./src/redis-sentinel sentinel.conf &amp;在master上面执行这是启动成功的！</code></pre><img src="https://i.loli.net/2019/05/07/5cd1a228086b6.jpg" /><img src="https://i.loli.net/2019/05/07/5cd1a2797a3e7.jpg" /><p>将master的哨兵模式退出，再将redis服务stop了，在两台slave上面查看其中一台是否切换为master:(没有优先级，为随机切换)</p><p>master 192.168.19.129</p><img src="https://i.loli.net/2019/05/07/5cd1a2ef82487.jpg" /><p>slave 192.168.19.136</p><p><img src="C:%5CUsers%5Cw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557242911037.png" alt="1557242911037"></p><p>​               主从+哨兵模式测试部署完成！</p><p>==========================================================</p><p>了解</p><p>主从+哨兵+lvs  制作redis主从的高科用</p><p>redis切片等</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找出Java中CPU使用率最高的线程，并打印这些线程的堆栈。</title>
      <link href="2018/09/28/linux/zhao-chu-java-zhong-cpu-shi-yong-lu-zui-gao-de-xian-cheng-bing-da-yin-zhe-xie-xian-cheng-de-dui-zhan/"/>
      <url>2018/09/28/linux/zhao-chu-java-zhong-cpu-shi-yong-lu-zui-gao-de-xian-cheng-bing-da-yin-zhe-xie-xian-cheng-de-dui-zhan/</url>
      
        <content type="html"><![CDATA[<h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><pre class=" language-shell"><code class="language-shell">#!/bin/bash# @Function# Find out the highest cpu consumed threads of java, and print the stack of these threads.## @Usage#   $ ./show-busy-java-threads.sh## @author Jerry Leereadonly PROG=`basename $0`readonly -a COMMAND_LINE=("$0" "$@")usage() {    cat <<EOFUsage: ${PROG} [OPTION]...Find out the highest cpu consumed threads of java, and print the stack of these threads.Example: ${PROG} -c 10Options:    -p, --pid       find out the highest cpu consumed threads from the specifed java process,                    default from all java process.    -c, --count     set the thread count to show, default is 5    -h, --help      display this help and exitEOF    exit $1}readonly ARGS=`getopt -n "$PROG" -a -o c:p:h -l count:,pid:,help -- "$@"`[ $? -ne 0 ] && usage 1eval set -- "${ARGS}"while true; do    case "$1" in    -c|--count)        count="$2"        shift 2        ;;    -p|--pid)        pid="$2"        shift 2        ;;    -h|--help)        usage        ;;    --)        shift        break        ;;    esacdonecount=${count:-5}redEcho() {    [ -c /dev/stdout ] && {        # if stdout is console, turn on color output.        echo -ne "\033[1;31m"        echo -n "$@"        echo -e "\033[0m"    } || echo "$@"}yellowEcho() {    [ -c /dev/stdout ] && {        # if stdout is console, turn on color output.        echo -ne "\033[1;33m"        echo -n "$@"        echo -e "\033[0m"    } || echo "$@"}blueEcho() {    [ -c /dev/stdout ] && {        # if stdout is console, turn on color output.        echo -ne "\033[1;36m"        echo -n "$@"        echo -e "\033[0m"    } || echo "$@"}# Check the existence of jstack command!if ! which jstack &> /dev/null; then    [ -z "$JAVA_HOME" ] && {        redEcho "Error: jstack not found on PATH!"        exit 1    }    ! [ -f "$JAVA_HOME/bin/jstack" ] && {        redEcho "Error: jstack not found on PATH and $JAVA_HOME/bin/jstack file does NOT exists!"        exit 1    }    ! [ -x "$JAVA_HOME/bin/jstack" ] && {        redEcho "Error: jstack not found on PATH and $JAVA_HOME/bin/jstack is NOT executalbe!"        exit 1    }    export PATH="$JAVA_HOME/bin:$PATH"fireadonly uuid=`date +%s`_${RANDOM}_$$cleanupWhenExit() {    rm /tmp/${uuid}_* &> /dev/null}trap "cleanupWhenExit" EXITprintStackOfThread() {    local line    local count=1    while IFS=" " read -a line ; do        local pid=${line[0]}        local threadId=${line[1]}        local threadId0x=`printf %x ${threadId}`        local user=${line[2]}        local pcpu=${line[4]}        local jstackFile=/tmp/${uuid}_${pid}        [ ! -f "${jstackFile}" ] && {            {                if [ "${user}" == "${USER}" ]; then                    jstack ${pid} > ${jstackFile}                else                    if [ $UID == 0 ]; then                        sudo -u ${user} jstack ${pid} > ${jstackFile}                    else                        redEcho "[$((count++))] Fail to jstack Busy(${pcpu}%) thread(${threadId}/0x${threadId0x}) stack of java process(${pid}) under user(${user})."                        redEcho "User of java process($user) is not current user($USER), need sudo to run again:"                        yellowEcho "    sudo ${COMMAND_LINE[@]}"                        echo                        continue                    fi                fi            } || {                redEcho "[$((count++))] Fail to jstack Busy(${pcpu}%) thread(${threadId}/0x${threadId0x}) stack of java process(${pid}) under user(${user})."                echo                rm ${jstackFile}                continue            }        }        blueEcho "[$((count++))] Busy(${pcpu}%) thread(${threadId}/0x${threadId0x}) stack of java process(${pid}) under user(${user}):"        sed "/nid=0x${threadId0x} /,/^$/p" -n ${jstackFile}    done}ps -Leo pid,lwp,user,comm,pcpu --no-headers | {    [ -z "${pid}" ] &&    awk '$4=="java"{print $0}' ||    awk -v "pid=${pid}" '$1==pid,$4=="java"{print $0}'} | sort -k5 -r -n | head --lines "${count}" | printStackOfThread</code></pre><p>原文地址：<a href="https://files-cdn.cnblogs.com/files/clsn/show-busy-java-threads.sh" target="_blank" rel="noopener">https://files-cdn.cnblogs.com/files/clsn/show-busy-java-threads.sh</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控体系</title>
      <link href="2018/06/05/jian-kong/jian-kong-ti-xi/"/>
      <url>2018/06/05/jian-kong/jian-kong-ti-xi/</url>
      
        <content type="html"><![CDATA[<h6 id="监控对象："><a href="#监控对象：" class="headerlink" title="监控对象："></a>监控对象：</h6><p>　　　　1. 监控对象的理解：CPU是怎么工作的，原理<br>　　　　2. 监控对象的指标：CPU使用率 CPU负载 CPU个数 上下文切换<br>　　　　3. 确定性能基准线：怎么样才算故障？CPU负载多上才算高<br>监控范围：<br>　　　　1.硬件监控服务器的硬件故障<br>　　　　2.操作系统监控 CPU、内存、硬盘、IO、进程<br>　　　　3.应用服务监控 nginx、MySQL、等服务<br>　　　　4.业务监控</p><hr><h3 id="硬件监控："><a href="#硬件监控：" class="headerlink" title="硬件监控："></a>硬件监控：</h3><p>　　1.使用IPMI<br>　　2.机房巡检<br>远程控制卡：<br>　　　　DELL服务器：iDRAC<br>　　　　HP服务器：ILO ————-Linux就可以使用IPMI（依赖于BMC控制器）<br>　　　　IBM服务器：IMM |<br>　　　　Linux是管理IPMI工具<br>　　　　‘ipmitool’（监控和控制）</p><h4 id="1-硬件要支持"><a href="#1-硬件要支持" class="headerlink" title="1.硬件要支持"></a>1.硬件要支持</h4><h4 id="2-操作系统-‘Linux-IPMI’"><a href="#2-操作系统-‘Linux-IPMI’" class="headerlink" title="2.操作系统 ‘Linux IPMI’"></a>2.操作系统 ‘Linux IPMI’</h4><p>ipmitool安装:</p><pre><code>[root@localhost ~]# yum install OpenIPMI ipmitool -y[root@localhost ~]# rpm -qa OpenIPMI ipmitoolipmitool-1.8.13-8.el7_1.x86_64OpenIPMI-2.0.19-11.el7.x86_64</code></pre><p>使用IPMI有两种方式<br>1、本地进行调用<br>2、远程调用 （IP地址 用户名和密码）</p><pre><code>[root@localhost ~]# systemctl start ipmi  #启动本次以Centos7进行演示</code></pre><p>IPMI相关命令</p><pre><code>[root@localhost ~]# ipmitool --helpipmitool: invalid option -- &#39;-&#39;ipmitool version 1.8.13usage: ipmitool [options...] &lt;command&gt;       -h             This help       -V             Show version information       -v             Verbose (can use multiple times)       -c             Display output in comma separated format       -d N           Specify a /dev/ipmiN device to use (default=0)       -I intf        Interface to use       -H hostname    Remote host name for LAN interface       -p port        Remote RMCP port [default=623]       -U username    Remote session username       -f file        Read remote session password from file       -z size        Change Size of Communication Channel (OEM)       -S sdr         Use local file for remote SDR cache       -D tty:b[:s]   Specify the serial device, baud rate to use                      and, optionally, specify that interface is the system one       -a             Prompt for remote password       -Y             Prompt for the Kg key for IPMIv2 authentication       -e char        Set SOL escape character       -C ciphersuite Cipher suite to be used by lanplus interface       -k key         Use Kg key for IPMIv2 authentication       -y hex_key     Use hexadecimal-encoded Kg key for IPMIv2 authentication       -L level       Remote session privilege level [default=ADMINISTRATOR]                      Append a &#39;+&#39; to use name/privilege lookup in RAKP1       -A authtype    Force use of auth type NONE, PASSWORD, MD2, MD5 or OEM       -P password    Remote session password       -E             Read password from IPMI_PASSWORD environment variable       -K             Read kgkey from IPMI_KGKEY environment variable       -m address     Set local IPMB address       -b channel     Set destination channel for bridged request       -t address     Bridge request to remote target address       -B channel     Set transit channel for bridged request (dual bridge)       -T address     Set transit address for bridge request (dual bridge)       -l lun         Set destination lun for raw commands       -o oemtype     Setup for OEM (use &#39;list&#39; to see available OEM types)       -O seloem      Use file for OEM SEL event descriptions       -N seconds     Specify timeout for lan [default=2] / lanplus [default=1] interface       -R retry       Set the number of retries for lan/lanplus interface [default=4]Interfaces:    open          Linux OpenIPMI Interface [default]    imb           Intel IMB Interface     lan           IPMI v1.5 LAN Interface     lanplus       IPMI v2.0 RMCP+ LAN Interface     serial-terminal  Serial Interface, Terminal Mode     serial-basic  Serial Interface, Basic Mode Commands:    raw           Send a RAW IPMI request and print response    i2c           Send an I2C Master Write-Read command and print response    spd           Print SPD info from remote I2C device    lan           Configure LAN Channels    chassis       Get chassis status and set power state    power         Shortcut to chassis power commands    event         Send pre-defined events to MC    mc            Management Controller status and global enables    sdr           Print Sensor Data Repository entries and readings    sensor        Print detailed sensor information    fru           Print built-in FRU and scan SDR for FRU locators    gendev        Read/Write Device associated with Generic Device locators sdr    sel           Print System Event Log (SEL)    pef           Configure Platform Event Filtering (PEF)    sol           Configure and connect IPMIv2.0 Serial-over-LAN    tsol          Configure and connect with Tyan IPMIv1.5 Serial-over-LAN    isol          Configure IPMIv1.5 Serial-over-LAN    user          Configure Management Controller users    channel       Configure Management Controller channels    session       Print session information    dcmi          Data Center Management Interface    sunoem        OEM Commands for Sun servers    kontronoem    OEM Commands for Kontron devices    picmg         Run a PICMG/ATCA extended cmd    fwum          Update IPMC using Kontron OEM Firmware Update Manager    firewall      Configure Firmware Firewall    delloem       OEM Commands for Dell systems    shell         Launch interactive IPMI shell    exec          Run list of commands from file    set           Set runtime variable for shell and exec    hpm           Update HPM components using PICMG HPM.1 file    ekanalyzer    run FRU-Ekeying analyzer using FRU files    ime           Update Intel Manageability Engine Firmware</code></pre><p>IPMI配置网络，有两种方式：<br>ipmi over lan（大体意思是通过网卡来进行连接）<br>独立 （给服务器单独插一个网线） DELL服务器可以在小面板中设置ipmi 云主机我们不需要考虑IPMI</p><p>对于路由器和交换机：SNMP<br>对于这些设备，就不做具体描述了，毕竟没有接触过</p><h3 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h3><p>做为系统运维来说系统监控是重点</p><pre><code>- CPU- 内存- IO Input/Ouput（网络、磁盘）</code></pre><h4 id="CPU三个重要的概念："><a href="#CPU三个重要的概念：" class="headerlink" title="CPU三个重要的概念："></a>CPU三个重要的概念：</h4><p>　　1.上下文切换：CPU调度器实施的进程的切换过程，上下文切换<br>　　2.运行队列（负载）：运行队列，排队 可以参考我是一个进程文章<br>　　3.使用率<br>监控CPU需要确定服务类型：<br>（1） IO密集型 （数据库）<br>（2） CPU密集型（Web/mail）</p><p>确定性能的基准线<br>　　运行队列：1-3个线程 1CPU 4核 负载不超过12<br>　　CPU使用：65%-70%用户态利用率<br>　　　　　　　30%-35%内核态利用率<br>　　　　　　　0%-5% 空闲<br>　　上下文切换： 越少越好<br>所有的监控都要根据业务来考虑</p><h4 id="常见的系统监控工具"><a href="#常见的系统监控工具" class="headerlink" title="常见的系统监控工具"></a>常见的系统监控工具</h4><p>Top、sysstat、mpstat</p><p>工具的使用方法<br>TOP参数解释</p><p>top的详细可以参考我在51cto的这篇文章 <a href="http://blog.51cto.com/12419955/2052642" target="_blank" rel="noopener">http://blog.51cto.com/12419955/2052642</a></p><p>其实对于Top，现在我更喜欢htop和gtop，gtop虽然色彩和功能更强大，但是因为gtop不在epel源里，导致gtop的使用没有htop用的广泛</p><p>当然gtop这么好用，当然要用一下，这是另一片关于gtop的文章 <a href="https://tigerfivegit.github.io/2018/12/14/Linux性能监控工具-gtop/" target="_blank" rel="noopener">https://tigerfivegit.github.io/2018/12/14/Linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7-gtop/</a></p><p>第一行 分别显示：系统当前时间 系统运行时间 当前用户登陆数 系统负载。<br>　　系统负载（load average），这里有三个数值，分别是系统最近1分钟，5分钟，15分钟的平均负载。一般对于单个处理器来说，负载在0 — 1.00 之间是正常的，超过1.00就要引起注意了。在多核处理器中，你的系统均值不应该高于处理器核心的总数。</p><p>第二行 分别显示：total进程总数、 running正在运行的进程数、 sleeping睡眠的进程数、stopped停止的进程数、 zombie僵尸进程数。</p><p>第三行<br>分别显示：<br>%us用户空间占用CPU百分比、<br>%sy内核空间占用CPU百分比、<br>%ni用户进程空间内改变过优先级的进程占用CPU百分比、<br>%id空闲CPU百分比、<br>%wa等待输入输出（I/O）的CPU时间百分比 、<br>%hi指的是cpu处理硬件中断的时间、%si指的是cpu处理软中断的时间 、<br>%st用于有虚拟cpu的情况，用来指示被虚拟机偷掉的cpu时间。<br>通常id%值可以反映一个系统cpu的闲忙程度。</p><p>第四行 MEM ：total 物理内存总量、 used 使用的物理内存总量、free 空闲内存总量、 buffers 用作内核缓存的内存量。</p><p>第五行 SWAP：total 交换区总量、 used使用的交换区总量、free 空闲交换区总量、 cached缓冲的交换区总量。<br>buffers和cached的区别需要说明一下，buffers指的是块设备的读写缓冲区，cached指的是文件系统本身的页面缓存。它们都是linux操作系统底层的机制，目的就是为了加速对磁盘的访问。</p><p>第六行 PID(进程号)、 USER（运行用户）、PR（优先级）、NI（任务nice值）、VIRT（虚拟内存用量）VIRT=SWAP+RES 、RES（物理内存用量）、SHR（共享内存用量）、S（进程状态）、%CPU（CPU占用比）、%MEM（物理内存占用比）、TIME+（累计CPU占 用时间)、　COMMAND 命令名/命令行。</p><p>下面简单介绍top命令的使用方法：<br>top [-] [d]</p><p>[q] [c] [C] [S] [n]<br>运维必会！<br>参数说明<br>d指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。<br>p通过指定监控进程ID来仅仅监控某个进程的状态。<br>q该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。<br>S指定累计模式。<br>s使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。<br>i使top不显示任何闲置或者僵死进程。<br>c显示整个命令行而不只是显示命令名。<br>下面介绍在top命令执行过程中可以使用的一些交互命令<br>　　从使用角度来看，熟练的掌握这些命令比掌握选项还重要一些。<br>　　这些命令都是单字母的，如果在命令行选项中使用了s选项，则可能其中一些命令会被屏蔽掉。<br>Ctrl+L 擦除并且重写屏幕。<br>h或者? 显示帮助画面，给出一些简短的命令总结说明。<br>k 终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。<br>i 忽略闲置和僵死进程。这是一个开关式命令。<br>q 退出程序。<br>r 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。<br>s 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。<br>f或者F 从当前显示中添加或者删除项目。<br>o或者O 改变显示项目的顺序。<br>l 切换显示平均负载和启动时间信息。<br>m 切换显示内存信息。<br>t 切换显示进程和CPU状态信息。<br>c 切换显示命令名称和完整命令行。<br>M 根据驻留内存大小进行排序。<br>P 根据CPU使用百分比大小进行排序。<br>T 根据时间/累计时间进行排序。<br>W 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。<br>Shift+M 可按内存占用情况进行排序。</p><h4 id="sysstat-说明"><a href="#sysstat-说明" class="headerlink" title="sysstat 说明"></a>sysstat 说明</h4><pre><code>yum install sysstat -yvmstat --helpusage: vmstat [-V] [-n] [delay [count]]              -V prints version.              -n causes the headers not to be reprinted regularly.              -a print inactive/active page stats.              -d prints disk statistics              -D prints disk table              -p prints disk partition statistics              -s prints vm table              -m prints slabinfo              -t add timestamp to output              -S unit size              delay is the delay between updates in seconds.               unit size k:1000 K:1024 m:1000000 M:1048576 (default is K)              count is the number of updates.</code></pre><p>例子：每隔1秒获取1次，次数不限</p><pre><code># vmstat 1procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 0  0      0 547332 177544 535336    0    0     1     6    5   41  1  0 98  0  0     0  0      0 547324 177544 535336    0    0     0     0  210  445  1  0 99  0  0     0  0      0 547324 177544 535336    0    0     0     0  195  435  0  0 100  0  0 0  0      0 547324 177544 535336    0    0     0     0  208  440  1  0 99  0  0     0  0      0 547332 177544 535336    0    0     0     0  209  446  0  0 100  0  0 0  0      0 547332 177544 535336    0    0     0     0  207  442  1  1 98  0  0     0  0      0 547332 177544 535336    0    0     0     0  201  438  0  0 100  0  0</code></pre><p>#r表示CPU排队的情况，b代表 进程堵塞，等待io<br>每隔1秒获取1次，次数10次</p><pre><code># vmstat 1 10procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 1  0      0 547340 177544 535344    0    0     1     6    5   41  1  0 98  0  0     0  0      0 547332 177544 535344    0    0     0    28  210  453  1  1 97  1  0     0  0      0 547332 177544 535344    0    0     0     0  200  433  0  0 100  0  0 0  0      0 547332 177544 535344    0    0     0     0  211  445  1  0 99  0  0     0  0      0 547332 177544 535344    0    0     0     0  201  439  0  1 99  0  0     0  0      0 547332 177544 535344    0    0     0     0  197  436  0  0 100  0  0 0  0      0 547332 177544 535344    0    0     0     0  201  442  1  0 99  0  0     0  0      0 547324 177544 535348    0    0     0     0  240  484  2  1 97  0  0     0  0      0 547324 177544 535348    0    0     0     0  203  438  0  0 100  0  0 0  0      0 547324 177544 535348    0    0     0     0  197  430  1  0 99  0  0</code></pre><p>mpstat<br>查看所有CPU的平均值</p><pre><code>mpstat 1Linux 2.6.32-431.23.3.el6.x86_64 (www)  08/30/2016  _x86_64_    (1 CPU)05:13:22 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest   %idle05:13:23 PM  all    1.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.00105:13:24 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.0005:13:25 PM  all    2.00    0.00    1.00    0.00    0.00    0.00    0.00    0.00   97.0005:13:26 PM  all    1.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.00</code></pre><pre><code>mpstat 1 10Linux 2.6.32-431.23.3.el6.x86_64 (www)  08/30/2016  _x86_64_    (1 CPU)05:13:38 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest   %idle05:13:39 PM  all    2.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   98.0005:13:40 PM  all    0.00    0.00    1.00    0.00    0.00    0.00    0.00    0.00   99.0005:13:41 PM  all    1.01    0.00    0.00    0.00    0.00    0.00    0.00    0.00   98.99</code></pre><p>上述是CPU监控，CPU监控主要靠经验。因为业务不同指标不同，指标越低越好是不变的道理</p><p>sar命令也有类似的功能，但是sar命令更能看到历史的信息，对于问题排查有更好的作用<br>当然对于我这种喜欢骚操作的人，sar命令不可能不搞啊，这里放个链接 <a href="https://tigerfivegit.github.io/2018/11/21/sar/" target="_blank" rel="noopener">https://tigerfivegit.github.io/2018/11/21/sar/</a></p><h4 id="内存硬盘监控："><a href="#内存硬盘监控：" class="headerlink" title="内存硬盘监控："></a>内存硬盘监控：</h4><p>硬盘格式化后分成块（blog）<br>内存默认是页（大小4kb）读取按照页来进行读取<br>内存：free vmstat</p><pre><code>free -m             total       used       free     shared    buffers     cachedMem:          1875       1338        537          0        173        523-/+ buffers/cache:        640       1234Swap:            0          0          0</code></pre><p>total 总内存<br>used 已使用内存<br>free 空闲内存<br>shared 共享内存（进程间相互通信使用共享内存）<br>buffers 缓冲<br>cached 缓存<br>Centos7 会有一个available，活动内存</p><p>#云服务器一般不分配swap分区，物理机能不使用交换分区就不使用交换分区</p><pre><code>vmstat 1procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 0  0      0 550628 177684 536324    0    0     1     6    7   46  1  0 98  0  0     0  0      0 550620 177684 536324    0    0     0    40  187  429  0  0 100  0  0 0  0      0 550620 177684 536324    0    0     0     0  183  427  1  0 99  0  0     0  0      0 550620 177684 536324    0    0     0     0  197  436  0  1 99  0  0</code></pre><p>swpd交换分区的大小<br>free可用的物理内存大小<br>buff 缓冲区的大小<br>cache 缓存区的大小<br>si 数据从交换分区读取到内存的大小<br>so 数据从内存到交换分区<br>bi 从交换分区读到内存（block）<br>bo 内存写到硬盘的</p><pre><code>内存达到多少报警呢？ 80%</code></pre><h4 id="硬盘：IOPS-IO’s-Per-Second-iotop-df-h-iostat"><a href="#硬盘：IOPS-IO’s-Per-Second-iotop-df-h-iostat" class="headerlink" title="硬盘：IOPS IO’s Per Second iotop df -h iostat"></a>硬盘：IOPS IO’s Per Second iotop df -h iostat</h4><p>　　顺序IO（快）<br>　　随机IO（慢）<br>查看磁盘剩余空间</p><pre><code>df -hFilesystem      Size  Used Avail Use% Mounted on/dev/xvda1       40G  4.1G   34G  11% /tmpfs           938M     0  938M   0% /dev/shm</code></pre><p>监控磁盘IO iotop</p><pre><code>yum install iotop -y</code></pre><p><img src="https://i.loli.net/2018/12/14/5c139a40ccaac.jpg" alt="htop"></p><pre><code>可以使用dd命令生成一个文件夹进行测试 生成命令如下：# dd if=/dev/zero of=/tmp/1.txt bs=1M count=10001000+0 records in1000+0 records out1048576000 bytes (1.0 GB) copied, 20.509 s, 51.1 MB/s[root@www ~]# ls -lh /tmp/1.txt -rw-r--r-- 1 root root 1000M Aug 30 19:48 /tmp/1.txt</code></pre><p>此时IO写入如下图<br><img src="https://i.loli.net/2018/12/14/5c139a7dbf4d3.jpg" alt="IO写如图"><br>iostat命令，可以看到那块磁盘，比iotop更加细致</p><pre><code># iostat 1 2Linux 2.6.32-431.23.3.el6.x86_64 (www)  08/30/2016  _x86_64_    (1 CPU)avg-cpu:  %user   %nice %system %iowait  %steal   %idle           1.10    0.00    0.27    0.16    0.00   98.46Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtnxvda              1.51         2.26        17.09     986748    7467560avg-cpu:  %user   %nice %system %iowait  %steal   %idle           1.02    0.00    0.00    0.00    0.00   98.98Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtnxvda              0.00         0.00         0.00          0          0</code></pre><p>tps 设备每秒的传输次数（每秒多少的io请求）<br>Blk_read/s 每秒从设备读取的数据量<br>Blk_wrtn/s 每秒像设备写入的数据量<br>Blk_read 写入数据的总数<br>Blk_wrtn 读取数据的总数</p><h4 id="网络监控：iftop"><a href="#网络监控：iftop" class="headerlink" title="网络监控：iftop"></a>网络监控：iftop</h4><pre><code># yum install iftop -y# iftop -n    #-n不做域名解析</code></pre><p><img src="https://i.loli.net/2018/12/14/5c139adfd7ab3.jpg" alt="iftop"></p><p>正常监控只需要监控网卡带宽即可<br>其中网络监控是最复杂的，ping监控网络延迟网络丢包等。但是此类的网络监控只是监控自己到客户端是否丢包，并不能保证客户端到服务器这边不丢包<br>　其中就产生了如：阿里测、奇云测、站长工具等一系列多节点的监控工具</p><p>性能测试常用工具：IBM nmon （nmon analyser—生成AIX性能报告的免费工具）<br><a href="http://nmon.sourceforge.net/pmwiki.php" target="_blank" rel="noopener">http://nmon.sourceforge.net/pmwiki.php</a> #下载地址（需要翻墙工具）<br>所以我们提供了百度云下载<br>链接：<a href="http://pan.baidu.com/s/1boXV6R9" target="_blank" rel="noopener">http://pan.baidu.com/s/1boXV6R9</a> 密码：sblf<br>只需要下载对应的版本，给执行权限。执行即可</p><pre><code># chmod +x nmon16e_x86_rhel72 # ./nmon16e_x86_rhel72</code></pre><p><img src="https://i.loli.net/2018/12/14/5c139b3a8ece4.jpg" alt="nmon"></p><p>我们可以直接输入一个c 一个m一个d。这个是实时的一个状态</p><p><img src="https://i.loli.net/2018/12/14/5c139b6978986.jpg" alt="nmon1"></p><pre><code>./nmon16e_x86_rhel72 --help./nmon16e_x86_rhel72: invalid option -- &#39;-&#39;Hint for nmon16e_x86_rhel72 version 16e    Full Help Info : nmon16e_x86_rhel72 -h    On-screen Stats: nmon16e_x86_rhel72    Data Collection: nmon16e_x86_rhel72 -f [-s &lt;seconds&gt;] [-c &lt;count&gt;] [-t|-T]    Capacity Plan  : nmon16e_x86_rhel72 -xInteractive-Mode:    Read the Welcome screen &amp; at any time type: &quot;h&quot; for more help    Type &quot;q&quot; to exit nmonFor Data-Collect-Mode    -f            Must be the first option on the line (switches off interactive mode)                  Saves data to a CSV Spreadsheet format .nmon file in then local directory                  Note: -f sets a defaults -s300 -c288    which you can then modify    Further Data Collection Options:    -s &lt;seconds&gt;  time between data snapshots    -c &lt;count&gt;    of snapshots before exiting    -t            Includes Top Processes stats (-T also collects command arguments)    -x            Capacity Planning=15 min snapshots for 1 day. (nmon -ft -s 900 -c 96)---- End of Hints-c  采集的次数-s  采集的间隔时间-f  生成一个文件-m  指定生成文件位置</code></pre><p>采集10次 间隔10秒</p><pre><code># ./nmon16e_x86_rhel72 -c 10 -s 10 -f -m /tmp/# lslocalhost_160831_0435.nmon  nmon16e_x86_rhel72</code></pre><p>前面为主机名后面是日期（年月日时分）<br>因为测试可能需要，我们要制作成表格，所以现在将文件上传到桌面上</p><h1 id="sz-localhost-160831-0435-nmon"><a href="#sz-localhost-160831-0435-nmon" class="headerlink" title="sz localhost_160831_0435.nmon"></a>sz localhost_160831_0435.nmon</h1><p>我们打开下载的工具</p><p><img src="https://i.loli.net/2018/12/14/5c139bd30d9d5.jpg" alt="img"></p><p>解压文件夹，打开nmon analyser v34a.xls</p><p><img src="https://i.loli.net/2018/12/14/5c139be8400bd.jpg" alt="img"></p><p>点击Analyse nmon data找到我们刚刚复制出来的文件，就可以看到了。</p><p><img src="https://i.loli.net/2018/12/14/5c139bf883548.jpg" alt="img"></p><h4 id="应用服务监控："><a href="#应用服务监控：" class="headerlink" title="应用服务监控："></a>应用服务监控：</h4><p>举例：Nginx<br>安装nginx</p><pre><code># yum install -y gcc glibc gcc-c++ prce-devel openssl-devel pcre-devel</code></pre><p>提示：nginx可以使用稳定版的最新版，因为安全性会不断的提高。如果是特别老的版本会有一些漏洞和功能<br>　　要想监控nginx需要在编译时添加如下参数</p><pre><code>--with-http_stub_status_module</code></pre><p>下载Nginx</p><pre><code>wget http://nginx.org/download/nginx-1.10.1.tar.gz</code></pre><p>解压，后面步骤太简单不说了<br>安装</p><pre><code>[root@localhost nginx-1.10.1]# useradd -s /sbin/nologin www[root@localhost nginx-1.10.1]# ./configure --prefix=/usr/local/nginx-1.10.1 --user=www --group=www --with-http_ssl_module --with-http_stub_status_module</code></pre><p>#configure 是一个shell脚本，执行它的作用是生成MAKEFILE（编译make需要）</p><pre><code>[root@localhost nginx-1.10.1]# make &amp;&amp; make install[root@localhost nginx-1.10.1]# lltotal 676drwxr-xr-x 6 1001 1001   4096 Aug 31 06:02 auto-rw-r--r-- 1 1001 1001 262898 May 31 09:47 CHANGES-rw-r--r-- 1 1001 1001 400701 May 31 09:47 CHANGES.rudrwxr-xr-x 2 1001 1001   4096 Aug 31 06:02 conf-rwxr-xr-x 1 1001 1001   2481 May 31 09:47 configuredrwxr-xr-x 4 1001 1001     68 Aug 31 06:02 contribdrwxr-xr-x 2 1001 1001     38 Aug 31 06:02 html-rw-r--r-- 1 1001 1001   1397 May 31 09:47 LICENSE-rw-r--r-- 1 root root    404 Aug 31 07:46 Makefiledrwxr-xr-x 2 1001 1001     20 Aug 31 06:02 mandrwxr-xr-x 3 root root    119 Aug 31 07:46 objs-rw-r--r-- 1 1001 1001     49 May 31 09:47 READMEdrwxr-xr-x 9 1001 1001     84 Aug 31 06:02 src</code></pre><p>#make是生成文件，make install是将生成的文件拷贝到不同的地方<br>make install 完成之后可以直接将当前目录拷贝到其他服务器上，安装相同的依赖就可以进行使用。</p><pre><code>[root@localhost nginx-1.10.1]# ln -s /usr/local/nginx-1.10.1/ /usr/local/nginx[root@localhost nginx-1.10.1]# netstat -lntp|grep nginxtcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      7058/nginx: master</code></pre><p>修改nginx.conf配置文件</p><pre><code>    location /status {    stub_status on;    access_log off;        allow 192.168.56.0/24;    deny all;}</code></pre><p>设置只允许56网段访问，并开启日志和状态模块</p><p>#这个比较基础，如果不知道怎么添加。可以参考<a href="http://www.nginx.org/" target="_blank" rel="noopener">www.nginx.org</a> 状态模块<br>浏览器访问：<a href="http://192.168.56.11/status" target="_blank" rel="noopener">http://192.168.56.11/status</a></p><pre><code>Active connections: 1 server accepts handled requests 3 3 163 Reading: 0 Writing: 1 Waiting: 0</code></pre><p>Active connections: 当前活跃的连接数<br>3—-&gt; 一共处理了多少个链接（请求）<br>3—-&gt; 成功创建多少次握手<br>163–&gt; 总共创建了多少个请求<br>Reading:当前读取客户端heardr的数量<br>Writing:当前返回给客户端heardr的数量 　#如果这个指标飙升，说明是后面的节点挂掉了，例如数据库等。<br>Waiting:大体意思是已经处理完，等待下次请求的数量<br>提示：我们只需要关注活动链接即可</p><p>监控最基础的功能<br>采集 存储 展示 告警</p><p>几款监控软件说明：<br>几款监控软件大家都知道应该是zabbix，这个入门和部署比较简单，对于中小企业都是友好的，但是难以细化和深入化。<br>后来因业务需求从zabbix逐渐转用小米的开源监控open-falcon，这个对于新手不太友好，但是后期的添加和细化都是特别友好的，模块化、分支化</p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux日志切割工具Logrotate配置详解</title>
      <link href="2018/04/05/linux/linux-ri-zhi-qie-ge-gong-ju-logrotate-pei-zhi-xiang-jie/"/>
      <url>2018/04/05/linux/linux-ri-zhi-qie-ge-gong-ju-logrotate-pei-zhi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="Linux日志切割工具Logrotate配置详解"><a href="#Linux日志切割工具Logrotate配置详解" class="headerlink" title="[Linux日志切割工具Logrotate配置详解]"></a>[Linux日志切割工具Logrotate配置详解]</h1><p>文章目录</p><p>[TOC]</p><p>Logrotate 程序是一个日志文件管理工具。用于分割日志文件，压缩转存、删除旧的日志文件，并创建新的日志文件，下面就对logrotate日志轮转的记录：</p><h2 id="1-Logrotate配置文件介绍"><a href="#1-Logrotate配置文件介绍" class="headerlink" title="1. Logrotate配置文件介绍"></a>1. Logrotate配置文件介绍</h2><p><a href="https://www.centos.bz/tag/linux/" target="_blank" rel="noopener">Linux</a>系统默认安装logrotate，默认的配置文件：</p><ul><li><code>/etc/logrotate.conf</code></li><li><code>/etc/logrotate.d/</code></li><li><code>logrotate.conf</code>：为主配置文件</li><li><code>logrotate.d</code>：为配置相关子系统，用于隔离每个应用配置（<a href="https://www.centos.bz/category/web-server/nginx/" target="_blank" rel="noopener">Nginx</a>、PHP、<a href="https://www.centos.bz/category/web-server/tomcat/" target="_blank" rel="noopener">Tomcat</a>…）</li></ul><p>Logrotate是基于CRON来运行的，其脚本是/etc/cron.daily/logrotate，日志轮转是系统自动完成的。<br>实际运行时，Logrotate会调用配置文件/etc/logrotate.conf。</p><p>Logrotate可以由自动或者手动触发日志轮转：</p><pre class=" language-shell"><code class="language-shell">logrotate -f /etc/logrotate.d/nginxlogrotate -f /etc/logrotate.d/php</code></pre><p>不过正式执行前最好通过<a href="https://www.centos.bz/tag/debug/" target="_blank" rel="noopener">Debug</a>选项来验证一下（-d参数）<br>具体logrotate命令格式如下：</p><pre class=" language-shell"><code class="language-shell">logrotate [OPTION...] <configfile></code></pre><ul><li><code>-d</code>, <code>--debug</code> ：debug模式，测试配置文件是否有错误。</li><li><code>-f</code>, <code>--force</code> ：强制转储文件。</li><li><code>-m</code>, <code>--mail=command</code> ：压缩日志后，发送日志到指定邮箱。</li><li><code>-s</code>, <code>--state=statefile</code> ：使用指定的状态文件。</li><li><code>-v</code>, <code>--verbose</code> ：显示转储过程。</li></ul><h2 id="2-Logrotater日志文件切割策略"><a href="#2-Logrotater日志文件切割策略" class="headerlink" title="2. Logrotater日志文件切割策略"></a>2. Logrotater日志文件切割策略</h2><p>查看logrotate.conf配置：</p><pre class=" language-shell"><code class="language-shell">cat /etc/logrotate.confweekly //默认每一周执行一次rotate轮转工作rotate 4 //保留多少个日志文件(轮转几次).默认保留四个.就是指定日志文件删除之前轮转的次数，0 指没有备份create //自动创建新的日志文件，新的日志文件具有和原来的文件相同的权限；因为日志被改名,因此要创建一个新的来继续存储之前的日志dateext //这个参数很重要！就是切割后的日志文件以当前日期为格式结尾，如xxx.log-20131216这样,如果注释掉,切割出来是按数字递增,即前面说的 xxx.log-1这种格式compress //是否通过gzip压缩转储以后的日志文件，如xxx.log-20131216.gz ；如果不需要压缩，注释掉就行include /etc/logrotate.d //导入/etc/logrotate.d/ 目录中的各个应用配置/var/log/wtmp { //仅针对 /var/log/wtmp 所设定的参数monthly //每月一次切割,取代默认的一周minsize 1M //文件大小超过 1M 后才会切割create 0664 root utmp //指定新建的日志文件权限以及所属用户和组rotate 1 //只保留一个日志.}#这个 wtmp 可记录用户登录系统及系统重启的时间#因为有 minsize 的参数，因此不见得每个月一定会执行一次喔.要看文件大小。</code></pre><p>Logrotate中其他可配置参数，具体如下：</p><pre class=" language-shell"><code class="language-shell">compress //通过gzip 压缩转储以后的日志nocompress //不做gzip压缩处理copytruncate //用于还在打开中的日志文件，把当前日志备份并截断；是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据。nocopytruncate //备份日志文件不过不截断create mode owner group //轮转时指定创建新文件的属性，如create 0777 nobody nobodynocreate //不建立新的日志文件delaycompress //和compress 一起使用时，转储的日志文件到下一次转储时才压缩nodelaycompress //覆盖 delaycompress 选项，转储同时压缩。missingok //如果日志丢失，不报错继续滚动下一个日志errors address //专储时的错误信息发送到指定的Email 地址ifempty //即使日志文件为空文件也做轮转，这个是logrotate的缺省选项。notifempty //当日志文件为空时，不进行轮转mail address //把转储的日志文件发送到指定的E-mail 地址nomail //转储时不发送日志文件olddir directory //转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统noolddir //转储后的日志文件和当前日志文件放在同一个目录下sharedscripts //运行postrotate脚本，作用是在所有日志都轮转后统一执行一次脚本。如果没有配置这个，那么每个日志轮转后都会执行一次脚本prerotate //在logrotate转储之前需要执行的指令，例如修改文件的属性等动作；必须独立成行postrotate //在logrotate转储之后需要执行的指令，例如重新启动 (kill -HUP) 某个服务！必须独立成行daily //指定转储周期为每天weekly //指定转储周期为每周monthly //指定转储周期为每月rotate count //指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份dateext //使用当期日期作为命名格式dateformat .%s //配合dateext使用，紧跟在下一行出现，定义文件切割后的文件名，必须配合dateext使用，只支持 %Y %m %d %s 这四个参数size(或minsize) log-size //当日志文件到达指定的大小时才转储，log-size能指定bytes(缺省)及KB (sizek)或MB(sizem).当日志文件 >= log-size 的时候就转储。 以下为合法格式：（其他格式的单位大小写没有试过）size = 5 或 size 5 （>= 5 个字节就转储）size = 100k 或 size 100ksize = 100M 或 size 100M</code></pre><h2 id="3-NGINX日志的配置实例参考"><a href="#3-NGINX日志的配置实例参考" class="headerlink" title="3. NGINX日志的配置实例参考:"></a>3. NGINX日志的配置实例参考:</h2><pre class=" language-shell"><code class="language-shell">vim /etc/logrotate.d/nginx/var/log/weblog/*.log {    daily  //指定转储周期为每天    compress  //通过gzip 压缩转储以后的日志    rotate 7  //保存7天的日志    missingok  //如果日志文件丢失，不要显示错误    notifempty  //当日志文件为空时，不进行轮转    dateext  //使用当期日期作为命名格式，exp: nginx_access.log-20190120    sharedscripts  //运行postrotate脚本    postrotate  //执行的指令            if [ -f /run/nginx.pid ]; then                    kill -USR1 `cat /run/nginx.pid`            fi    endscript  //结束指令}</code></pre><h2 id="4-PHP-FPM日志的配置实例参考"><a href="#4-PHP-FPM日志的配置实例参考" class="headerlink" title="4. PHP-FPM日志的配置实例参考:"></a>4. PHP-FPM日志的配置实例参考:</h2><pre class=" language-shell"><code class="language-shell">vim /etc/logrotate.d/nginx/usr/local/php/var/log/*.log {dailycompressrotate 7missingoknotifemptydateextsharedscriptspostrotate    if [ -f /usr/local/php/var/run/php-fpm.pid ]; then        kill -USR2 `cat /usr/local/php/var/run/php-fpm.pid`    fiendscript}</code></pre><h2 id="5-Logrotater日志切割轮询"><a href="#5-Logrotater日志切割轮询" class="headerlink" title="5. Logrotater日志切割轮询"></a>5. Logrotater日志切割轮询</h2><p>由于Logrotate是基于CRON运行的，所以这个日志轮转的时间是由CRON控制的，具体可以查询CRON的配置文件/etc/anacrontab，过往的老版本的文件为（/etc/crontab）</p><p>查看轮转文件：/etc/anacrontab</p><pre class=" language-shell"><code class="language-shell">cat /etc/anacrontab    SHELL=/bin/sh    PATH=/sbin:/bin:/usr/sbin:/usr/bin    MAILTO=root    RANDOM_DELAY=45    START_HOURS_RANGE=3-22    1   5   cron.daily      nice run-parts /etc/cron.daily    7   25  cron.weekly     nice run-parts /etc/cron.weekly    @monthly 45 cron.monthly        nice run-parts /etc/cron.monthly</code></pre><p>使用anacrontab轮转的配置文件，日志切割的生效时间是在凌晨3点到22点之间，而且随机延迟时间是45分钟，但是这样配置无法满足我们在现实中的应用</p><p>现在的需求是将切割时间调整到每天的晚上12点，即每天切割的日志是前一天的0-24点之间的内容，操作如下：</p><pre class=" language-shell"><code class="language-shell">mv /etc/anacrontab /etc/anacrontab.bak          //取消日志自动轮转的设置</code></pre><p>使用crontab来作为日志轮转的触发容器来修改Logrotate默认执行时间</p><pre class=" language-shell"><code class="language-shell">vi /etc/crontab SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=rootHOME=/# run-parts01 * * * * root run-parts /etc/cron.hourly59 23 * * * root run-parts /etc/cron.daily22 4 * * 0 root run-parts /etc/cron.weekly42 4 1 * * root run-parts /etc/cron.monthly</code></pre><h2 id="6-解决logrotate无法自动轮询日志的办法"><a href="#6-解决logrotate无法自动轮询日志的办法" class="headerlink" title="6. 解决logrotate无法自动轮询日志的办法"></a>6. 解决logrotate无法自动轮询日志的办法</h2><p>现象说明：</p><p>使用logrotate轮询nginx日志，配置好之后，发现nginx日志连续两天没被切割，检查后确定配置文件一切正常，这是为什么呢？？</p><p>强行启动记录文件维护操作，纵使logrotate指令认为没有需要，应该有可能是logroate认为nginx日志太小，不进行轮询。<br>故需要强制轮询，即在/etc/cron.daily/logrotate脚本中将 -t 参数替换成 -f 参数</p><pre class=" language-shell"><code class="language-shell">vim /etc/cron.daily/logrotate #!/bin/sh/usr/sbin/logrotate /etc/logrotate.confEXITVALUE=$?if [ $EXITVALUE != 0 ]; then    /usr/bin/logger -f logrotate "ALERT exited abnormally with [$EXITVALUE]"fiexit 0</code></pre><p>最后最后重启下cron服务：</p><pre class=" language-shell"><code class="language-shell">/etc/init.d/crond restartStopping crond: [ OK ]Starting crond: [ OK ]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
